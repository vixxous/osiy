if IY_LOADED and not _G.IY_DEBUG then
    return
end

-- Mark Infinite Yield as loaded
pcall(function() getgenv().IY_LOADED = true end)

-- Define cloneref function if not already defined
local cloneref = cloneref or function(o) return o end

-- Initialize core services
local COREGUI = cloneref(game:GetService("CoreGui"))
local Players = cloneref(game:GetService("Players"))

-- Wait for the game to load
if not game:IsLoaded() then
    local notLoaded = Instance.new("Message", COREGUI)
    notLoaded.Text = "Infinite Yield is waiting for the game to load"
    game.Loaded:Wait()
    notLoaded:Destroy()
end

-- Define current version
local currentVersion = "6.3.1"

-- Main UI Frame
local ScaledHolder = Instance.new("Frame")
ScaledHolder.Name = "ScaledHolder"
ScaledHolder.Size = UDim2.fromScale(1, 1)
ScaledHolder.BackgroundTransparency = 1
ScaledHolder.Parent = COREGUI

local Scale = Instance.new("UIScale", ScaledHolder)
Scale.Name = "Scale"

local Holder = Instance.new("Frame", ScaledHolder)
Holder.Name = "Holder"
Holder.Active = true
Holder.BackgroundColor3 = Color3.fromRGB(46, 46, 47)
Holder.BorderSizePixel = 0
Holder.Position = UDim2.new(1, -250, 1, -220)
Holder.Size = UDim2.new(0, 250, 0, 220)
Holder.ZIndex = 10

-- Title Bar
local Title = Instance.new("TextLabel", Holder)
Title.Name = "Title"
Title.Active = true
Title.BackgroundColor3 = Color3.fromRGB(36, 36, 37)
Title.BorderSizePixel = 0
Title.Size = UDim2.new(0, 250, 0, 20)
Title.Font = Enum.Font.SourceSans
Title.TextSize = 18
Title.Text = "Infinite Yield FE v" .. currentVersion
Title.TextColor3 = Color3.new(1, 1, 1)
Title.ZIndex = 10

-- Dark Background
local Dark = Instance.new("Frame", Holder)
Dark.Name = "Dark"
Dark.Active = true
Dark.BackgroundColor3 = Color3.fromRGB(36, 36, 37)
Dark.BorderSizePixel = 0
Dark.Position = UDim2.new(0, 0, 0, 45)
Dark.Size = UDim2.new(0, 250, 0, 175)
Dark.ZIndex = 10

-- Command Bar
local Cmdbar = Instance.new("TextBox", Holder)
Cmdbar.Name = "Cmdbar"
Cmdbar.BackgroundTransparency = 1
Cmdbar.BorderSizePixel = 0
Cmdbar.Position = UDim2.new(0, 5, 0, 20)
Cmdbar.Size = UDim2.new(0, 240, 0, 25)
Cmdbar.Font = Enum.Font.SourceSans
Cmdbar.TextSize = 18
Cmdbar.TextXAlignment = Enum.TextXAlignment.Left
Cmdbar.TextColor3 = Color3.new(1, 1, 1)
Cmdbar.Text = ""
Cmdbar.PlaceholderText = "Command Bar"
Cmdbar.ZIndex = 10

-- Command List Frame
local CMDsF = Instance.new("ScrollingFrame", Holder)
CMDsF.Name = "CMDs"
CMDsF.BackgroundTransparency = 1
CMDsF.BorderSizePixel = 0
CMDsF.Position = UDim2.new(0, 5, 0, 45)
CMDsF.Size = UDim2.new(0, 245, 0, 175)
CMDsF.ScrollBarImageColor3 = Color3.fromRGB(78, 78, 79)
CMDsF.BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
CMDsF.CanvasSize = UDim2.new(0, 0, 0, 0)
CMDsF.MidImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
CMDsF.ScrollBarThickness = 8
CMDsF.TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
CMDsF.VerticalScrollBarInset = Enum.ScrollBarInset.Always
CMDsF.ZIndex = 10

local cmdListLayout = Instance.new("UIListLayout", CMDsF)
cmdListLayout.Name = "cmdListLayout"

-- Settings Button
local SettingsButton = Instance.new("ImageButton", Holder)
SettingsButton.Name = "SettingsButton"
SettingsButton.BackgroundTransparency = 1
SettingsButton.Position = UDim2.new(0, 230, 0, 0)
SettingsButton.Size = UDim2.new(0, 20, 0, 20)
SettingsButton.Image = "rbxassetid://1204397029"
SettingsButton.ZIndex = 10

-- Notification Frame
local Notification = Instance.new("Frame", ScaledHolder)
Notification.Name = "Notification"
Notification.BackgroundColor3 = Color3.fromRGB(36, 36, 37)
Notification.BorderSizePixel = 0
Notification.Position = UDim2.new(1, -500, 1, 20)
Notification.Size = UDim2.new(0, 250, 0, 100)
Notification.ZIndex = 10

local Title_2 = Instance.new("TextLabel", Notification)
Title_2.Name = "Title"
Title_2.BackgroundColor3 = Color3.fromRGB(46, 46, 47)
Title_2.BorderSizePixel = 0
Title_2.Size = UDim2.new(0, 250, 0, 20)
Title_2.Font = Enum.Font.SourceSans
Title_2.TextSize = 14
Title_2.Text = "Notification Title"
Title_2.TextColor3 = Color3.new(1, 1, 1)
Title_2.ZIndex = 10

local Text_2 = Instance.new("TextLabel", Notification)
Text_2.Name = "Text"
Text_2.BackgroundTransparency = 1
Text_2.BorderSizePixel = 0
Text_2.Position = UDim2.new(0, 5, 0, 25)
Text_2.Size = UDim2.new(0, 240, 0, 75)
Text_2.Font = Enum.Font.SourceSans
Text_2.TextSize = 16
Text_2.Text = "Notification Text"
Text_2.TextColor3 = Color3.new(1, 1, 1)
Text_2.TextWrapped = true
Text_2.ZIndex = 10

-- Function to create a settings button
local function makeSettingsButton(name, iconID, off)
    local button = Instance.new("TextButton")
    button.BackgroundColor3 = Color3.fromRGB(46, 46, 47)
    button.BorderSizePixel = 0
    button.Size = UDim2.new(1, 0, 0, 25)
    button.Text = ""
    button.ZIndex = 10

    local icon = Instance.new("ImageLabel", button)
    icon.Name = "Icon"
    icon.Position = UDim2.new(0, 5, 0, 5)
    icon.Size = UDim2.new(0, 16, 0, 16)
    icon.BackgroundTransparency = 1
    icon.Image = iconID
    icon.ZIndex = 10

    if off then
        icon.ScaleType = Enum.ScaleType.Crop
        icon.ImageRectSize = Vector2.new(16, 16)
        icon.ImageRectOffset = Vector2.new(off, 0)
    end

    local label = Instance.new("TextLabel", button)
    label.Name = "ButtonLabel"
    label.BackgroundTransparency = 1
    label.Text = name
    label.Position = UDim2.new(0, 28, 0, 0)
    label.Size = UDim2.new(1, -28, 1, 0)
    label.Font = Enum.Font.SourceSans
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 10

    return button
end

--[[
    Additional Settings Buttons
    This section creates additional settings buttons for themes, keybinds, and plugins.
]]

local ColorsButton = makeSettingsButton("Edit Theme", "rbxassetid://4911962991")
ColorsButton.Position = UDim2.new(0, 5, 0, 55)
ColorsButton.Size = UDim2.new(1, -10, 0, 25)
ColorsButton.Name = "Colors"
ColorsButton.Parent = SettingsHolder

local Keybinds = makeSettingsButton("Edit Keybinds", "rbxassetid://129697930")
Keybinds.Position = UDim2.new(0, 5, 0, 85)
Keybinds.Size = UDim2.new(1, -10, 0, 25)
Keybinds.Name = "Keybinds"
Keybinds.Parent = SettingsHolder

local Aliases = makeSettingsButton("Edit Aliases", "rbxassetid://5147488658")
Aliases.Position = UDim2.new(0, 5, 0, 115)
Aliases.Size = UDim2.new(1, -10, 0, 25)
Aliases.Name = "Aliases"
Aliases.Parent = SettingsHolder

ScaledHolder.Parent = COREGUI
Holder.Visible = true

-- Function to create instances from a data table
function create(data)
    local insts = {}
    for i, v in pairs(data) do
        insts[v[1]] = Instance.new(v[2])
    end

    for _, v in pairs(data) do
        for prop, val in pairs(v[3]) do
            if type(val) == "table" then
                insts[v[1]][prop] = insts[val[1]]
            else
                insts[v[1]][prop] = val
            end
        end
    end

    return insts[1]
end

TextService = cloneref(game:GetService("TextService"))

ViewportTextBox = (function()
    local funcs = {}
    funcs.Update = function(self)
        local cursorPos = self.TextBox.CursorPosition
        local text = self.TextBox.Text
        if text == "" then
            self.TextBox.Position = UDim2.new(0, 2, 0, 0)
            return
        end
        if cursorPos == -1 then return end

        local cursorText = text:sub(1, cursorPos - 1)
        local pos = nil
        local leftEnd = -self.TextBox.Position.X.Offset
        local rightEnd = leftEnd + self.View.AbsoluteSize.X

        local totalTextSize = TextService:GetTextSize(text, self.TextBox.TextSize, self.TextBox.Font, Vector2.new(999999999, 100)).X
        local cursorTextSize = TextService:GetTextSize(cursorText, self.TextBox.TextSize, self.TextBox.Font, Vector2.new(999999999, 100)).X

        if cursorTextSize > rightEnd then
            pos = math.max(-2, cursorTextSize - self.View.AbsoluteSize.X + 2)
        elseif cursorTextSize < leftEnd then
            pos = math.max(-2, cursorTextSize - 2)
        elseif totalTextSize < rightEnd then
            pos = math.max(-2, totalTextSize - self.View.AbsoluteSize.X + 2)
        end

        if pos then
            self.TextBox.Position = UDim2.new(0, -pos, 0, 0)
            self.TextBox.Size = UDim2.new(1, pos, 1, 0)
        end
    end

    local mt = {}
    mt.__index = funcs

    local function convert(textbox)
        local obj = setmetatable({ OffsetX = 0, TextBox = textbox }, mt)

        local view = Instance.new("Frame")
        view.BackgroundTransparency = textbox.BackgroundTransparency
        view.BackgroundColor3 = textbox.BackgroundColor3
        view.BorderSizePixel = textbox.BorderSizePixel
        view.BorderColor3 = textbox.BorderColor3
        view.Position = textbox.Position
        view.Size = textbox.Size
        view.ClipsDescendants = true
        view.Name = textbox.Name
        view.ZIndex = 10
        textbox.BackgroundTransparency = 1
        textbox.Position = UDim2.new(0, 4, 0, 0)
        textbox.Size = UDim2.new(1, -8, 1, 0)
        textbox.TextXAlignment = Enum.TextXAlignment.Left
        textbox.Name = "Input"
        table.insert(text1, textbox)
        table.insert(shade2, view)

        obj.View = view

        textbox.Changed:Connect(function(prop)
            if prop == "Text" or prop == "CursorPosition" or prop == "AbsoluteSize" then
                obj:Update()
            end
        end)

        obj:Update()

        view.Parent = textbox.Parent
        textbox.Parent = view

        return obj
    end

    return { convert = convert }
end)()

-- Convert command bars to use ViewportTextBox
ViewportTextBox.convert(Cmdbar).View.ZIndex = 10
ViewportTextBox.convert(Cmdbar_2).View.ZIndex = 10
ViewportTextBox.convert(Cmdbar_3).View.ZIndex = 10

IYMouse = Players.LocalPlayer:GetMouse()
PlayerGui = Players.LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
UserInputService = cloneref(game:GetService("UserInputService"))
TweenService = cloneref(game:GetService("TweenService"))
HttpService = cloneref(game:GetService("HttpService"))
MarketplaceService = cloneref(game:GetService("MarketplaceService"))
RunService = cloneref(game:GetService("RunService"))
TeleportService = cloneref(game:GetService("TeleportService"))
StarterGui = cloneref(game:GetService("StarterGui"))
GuiService = cloneref(game:GetService("GuiService"))
Lighting = cloneref(game:GetService("Lighting"))
ContextActionService = cloneref(game:GetService("ContextActionService"))
NetworkClient = cloneref(game:GetService("NetworkClient"))
ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
GroupService = cloneref(game:GetService("GroupService"))
PathService = cloneref(game:GetService("PathfindingService"))
SoundService = cloneref(game:GetService("SoundService"))
Teams = cloneref(game:GetService("Teams"))
StarterPlayer = cloneref(game:GetService("StarterPlayer"))
InsertService = cloneref(game:GetService("InsertService"))
ChatService = cloneref(game:GetService("Chat"))
ProximityPromptService = cloneref(game:GetService("ProximityPromptService"))
StatsService = cloneref(game:GetService("Stats"))
MaterialService = cloneref(game:GetService("MaterialService"))
AvatarEditorService = cloneref(game:GetService("AvatarEditorService"))
TextChatService = cloneref(game:GetService("TextChatService"))
CaptureService = cloneref(game:GetService("CaptureService"))
VoiceChatService = cloneref(game:GetService("VoiceChatService"))

--[[
    Utility Functions
    This section defines additional utility functions for the script.
]]

-- Validate the type of an object
function vtype(o, t)
    if o == nil then return false end
    if type(o) == "userdata" then return typeof(o) == t end
    return type(o) == t
end

-- Utility functions for hidden properties
sethidden = sethiddenproperty or set_hidden_property or set_hidden_prop
gethidden = gethiddenproperty or get_hidden_property or get_hidden_prop

-- Teleport queue and HTTP request functions
queueteleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request

-- Game metadata
PlaceId, JobId = game.PlaceId, game.JobId
local IsOnMobile = table.find({ Enum.Platform.IOS, Enum.Platform.Android }, UserInputService:GetPlatform())
everyClipboard = setclipboard or toclipboard or set_clipboard or (Clipboard and Clipboard.set)
isLegacyChat = TextChatService.ChatVersion == Enum.ChatVersion.LegacyChatService

-- File I/O functions with error handling
local writefile = type(writefile) == "function" and function(file, data, safe)
    if safe == true then return pcall(writefile, file, data) end
    writefile(file, data)
end

local readfile = type(readfile) == "function" and function(file, safe)
    if safe == true then return pcall(readfile, file) end
    return readfile(file)
end

-- Check if file I/O is supported
function writefileExploit()
    return writefile ~= nil
end

function readfileExploit()
    return readfile ~= nil
end

-- Check if a string is a number
function isNumber(str)
    return tonumber(str) ~= nil or str == 'inf'
end

-- Get the root part of a character
function getRoot(char)
    return char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
end

-- Check if a player has tools
function tools(plr)
    return plr:FindFirstChildOfClass("Backpack"):FindFirstChildOfClass('Tool') or plr.Character:FindFirstChildOfClass('Tool')
end

-- Check if a player is using R15
function r15(plr)
    return plr.Character:FindFirstChildOfClass('Humanoid').RigType == Enum.HumanoidRigType.R15
end

-- Copy text to clipboard
function toClipboard(txt)
    if everyClipboard then
        everyClipboard(tostring(txt))
        notify("Clipboard", "Copied to clipboard")
    else
        notify("Clipboard", "Your exploit doesn't have the ability to use the clipboard")
    end
end

-- Send a chat message
function chatMessage(str)
    str = tostring(str)
    if not isLegacyChat then
        TextChatService.TextChannels.RBXGeneral:SendAsync(str)
    else
        ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(str, "All")
    end
end

-- Get the hierarchy of an object
function getHierarchy(obj)
    local fullname
    local period

    if string.find(obj.Name, ' ') then
        fullname = '["' .. obj.Name .. '"]'
        period = false
    else
        fullname = obj.Name
        period = true
    end

    local getS = obj
    local parent = obj
    local service = ''

    if getS.Parent ~= game then
        repeat
            getS = getS.Parent
            service = getS.ClassName
        until getS.Parent == game
    end

    if parent.Parent ~= getS then
        repeat
            parent = parent.Parent
            if string.find(tostring(parent), ' ') then
                if period then
                    fullname = '["' .. parent.Name .. '"].' .. fullname
                else
                    fullname = '["' .. parent.Name .. '"]' .. fullname
                end
                period = false
            else
                if period then
                    fullname = parent.Name .. '.' .. fullname
                else
                    fullname = parent.Name .. '' .. fullname
                end
                period = true
            end
        until parent.Parent == getS
    elseif string.find(tostring(parent), ' ') then
        fullname = '["' .. parent.Name .. '"]'
        period = false
    end

    if period then
        return 'game:GetService("' .. service .. '").' .. fullname
    else
        return 'game:GetService("' .. service .. '")' .. fullname
    end
end

AllWaypoints = {}

local cooldown = false
function writefileCooldown(name, data)
    task.spawn(function()
        if not cooldown then
            cooldown = true
            writefile(name, data, true)
        else
            repeat wait() until cooldown == false
            writefileCooldown(name, data)
        end
        wait(3)
        cooldown = false
    end)
end

-- Function to make a GUI draggable
function dragGUI(gui)
    task.spawn(function()
        local dragging
        local dragInput
        local dragStart = Vector3.new(0, 0, 0)
        local startPos
        local function update(input)
            local delta = input.Position - dragStart
            local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            TweenService:Create(gui, TweenInfo.new(.20), { Position = Position }):Play()
        end
        gui.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = gui.Position

                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        gui.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                dragInput = input
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if input == dragInput and dragging then
                update(input)
            end
        end)
    end)
end

-- Make GUIs draggable
dragGUI(logs)
dragGUI(KeybindEditor)
dragGUI(PluginEditor)
dragGUI(ToPartFrame)

eventEditor = (function()
    local events = {}

    -- Register an event with a name and settings
    local function registerEvent(name, sets)
        events[name] = {
            commands = {},
            sets = sets or {}
        }
    end

    -- Fire an event with arguments
    local function fireEvent(name, ...)
        local args = { ... }
        local event = events[name]
        if event then
            for i, cmd in pairs(event.commands) do
                local metCondition = true
                for idx, set in pairs(event.sets) do
                    local argVal = args[idx]
                    local cmdSet = cmd[2][idx]
                    local condType = set.Type
                    if condType == "Player" then
                        if cmdSet == 0 then
                            metCondition = metCondition and (tostring(Players.LocalPlayer) == argVal)
                        elseif cmdSet ~= 1 then
                            metCondition = metCondition and table.find(getPlayer(cmdSet, Players.LocalPlayer), argVal)
                        end
                    elseif condType == "String" then
                        if cmdSet ~= 0 then
                            metCondition = metCondition and string.find(argVal:lower(), cmdSet:lower())
                        end
                    elseif condType == "Number" then
                        if cmdSet ~= 0 then
                            metCondition = metCondition and tonumber(argVal) <= tonumber(cmdSet)
                        end
                    end
                    if not metCondition then break end
                end

                if metCondition then
                    pcall(task.spawn(function()
                        local cmdStr = cmd[1]
                        for count, arg in pairs(args) do
                            cmdStr = cmdStr:gsub("%$" .. count, arg)
                        end
                        wait(cmd[3] or 0)
                        execCmd(cmdStr)
                    end))
                end
            end
        end
    end

    -- Create the main event editor UI
    local main = create({
        {1, "Frame", { BackgroundColor3 = Color3.new(0.14117647707462, 0.14117647707462, 0.14509804546833), BackgroundTransparency = 1, BorderSizePixel = 0, Name = "EventEditor", Position = UDim2.new(0.5, -175, 0, -500), Size = UDim2.new(0, 350, 0, 20), ZIndex = 10 }},
        {2, "Frame", { BackgroundColor3 = currentShade2, BorderSizePixel = 0, Name = "TopBar", Parent = {1}, Size = UDim2.new(1, 0, 0, 20), ZIndex = 10 }},
        {3, "TextLabel", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = 3, Name = "Title", Parent = {2}, Position = UDim2.new(0, 0, 0, 0), Size = UDim2.new(1, 0, 0.95, 0), Text = "Event Editor", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = Enum.TextXAlignment.Center, ZIndex = 10 }},
        {4, "TextButton", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = 3, Name = "Close", Parent = {2}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, ZIndex = 10 }},
        {5, "ImageLabel", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Image = "rbxassetid://5054663650", Parent = {4}, Position = UDim2.new(0, 5, 0, 5), Size = UDim2.new(0, 10, 0, 10), ZIndex = 10 }},
        {6, "Frame", { BackgroundColor3 = currentShade1, BorderSizePixel = 0, Name = "Content", Parent = {1}, Position = UDim2.new(0, 0, 0, 20), Size = UDim2.new(1, 0, 0, 202), ZIndex = 10 }},
        {7, "ScrollingFrame", { BackgroundColor3 = Color3.new(0.14117647707462, 0.14117647707462, 0.14509804546833), BackgroundTransparency = 1, BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), BorderSizePixel = 0, BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png", CanvasSize = UDim2.new(0, 0, 0, 100), Name = "List", Parent = {6}, Position = UDim2.new(0, 5, 0, 5), ScrollBarImageColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), ScrollBarThickness = 8, Size = UDim2.new(1, -10, 1, -10), TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png", ZIndex = 10 }},
        {8, "Frame", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Name = "Holder", Parent = {7}, Size = UDim2.new(1, 0, 1, 0), ZIndex = 10 }},
        {9, "UIListLayout", { Parent = {8}, SortOrder = 2 }},
        {10, "Frame", { BackgroundColor3 = Color3.new(0.14117647707462, 0.14117647707462, 0.14509804546833), BackgroundTransparency = 1, BorderColor3 = Color3.new(0.3137255012989, 0.3137255012989, 0.3137255012989), BorderSizePixel = 0, ClipsDescendants = true, Name = "Settings", Parent = {6}, Position = UDim2.new(1, 0, 0, 0), Size = UDim2.new(0, 150, 1, 0), ZIndex = 10 }},
        {11, "Frame", { BackgroundColor3 = Color3.new(0.14117647707462, 0.14117647707462, 0.14509804546833), Name = "Slider", Parent = {10}, Position = UDim2.new(0, -150, 0, 0), Size = UDim2.new(1, 0, 1, 0), ZIndex = 10 }},
        {12, "Frame", { BackgroundColor3 = Color3.new(0.23529413342476, 0.23529413342476, 0.23529413342476), BorderColor3 = Color3.new(0.3137255012989, 0.3137255012989, 0.3137255012989), BorderSizePixel = 0, Name = "Line", Parent = {11}, Size = UDim2.new(0, 1, 1, 0), ZIndex = 10 }},
        {13, "ScrollingFrame", { BackgroundColor3 = Color3.new(0.14117647707462, 0.14117647707462, 0.14509804546833), BackgroundTransparency = 1, BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), BorderSizePixel = 0, BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png", CanvasSize = UDim2.new(0, 0, 0, 100), Name = "List", Parent = {11}, Position = UDim2.new(0, 0, 0, 25), ScrollBarImageColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), ScrollBarThickness = 8, Size = UDim2.new(1, 0, 1, -25), TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png", ZIndex = 10 }},
        {14, "Frame", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Name = "Holder", Parent = {13}, Size = UDim2.new(1, 0, 1, 0), ZIndex = 10 }},
        {15, "UIListLayout", { Parent = {14}, SortOrder = 2 }},
        {16, "TextLabel", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = 3, Name = "Title", Parent = {11}, Size = UDim2.new(1, 0, 0, 20), Text = "Event Settings", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, ZIndex = 10 }},
        {17, "TextButton", { BackgroundColor3 = Color3.new(0.14117647707462, 0.14117647707462, 0.14509804546833), BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), Font = 3, Name = "Close", BorderSizePixel = 0, Parent = {11}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), Text = "<", TextColor3 = Color3.new(1, 1, 1), TextSize = 18, ZIndex = 10 }},
        {18, "Folder", { Name = "Templates", Parent = {10} }},
        {19, "Frame", { BackgroundColor3 = Color3.new(0.19607844948769, 0.19607844948769, 0.19607844948769), BackgroundTransparency = 1, BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), Name = "Players", Parent = {18}, Position = UDim2.new(0, 0, 0, 25), Size = UDim2.new(1, 0, 0, 86), Visible = false, ZIndex = 10 }},
        {20, "TextLabel", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = 3, Name = "Title", Parent = {19}, Size = UDim2.new(1, 0, 0, 20), Text = "Choose Players", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, ZIndex = 10 }},
        {21, "TextLabel", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "Any", Parent = {19}, Position = UDim2.new(0, 5, 0, 42), Size = UDim2.new(1, -10, 0, 20), Text = "Any Player", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {22, "Frame", { BackgroundColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), BorderSizePixel = 0, Name = "Button", Parent = {21}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), ZIndex = 10 }},
        {23, "TextButton", { BackgroundColor3 = Color3.new(0.58823531866074, 0.58823531866074, 0.59215688705444), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "On", Parent = {22}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), Text = "", TextColor3 = Color3.new(0, 0, 0), TextSize = 14, ZIndex = 10 }},
        {24, "TextLabel", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "Me", Parent = {19}, Position = UDim2.new(0, 5, 0, 20), Size = UDim2.new(1, -10, 0, 20), Text = "Me Only", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {25, "Frame", { BackgroundColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), BorderSizePixel = 0, Name = "Button", Parent = {24}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), ZIndex = 10 }},
        {26, "TextButton", { BackgroundColor3 = Color3.new(0.58823531866074, 0.58823531866074, 0.59215688705444), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "On", Parent = {25}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), Text = "", TextColor3 = Color3.new(0, 0, 0), TextSize = 14, ZIndex = 10 }},
        {27, "TextBox", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), BorderSizePixel = 0, ClearTextOnFocus = false, Font = 3, Name = "Custom", Parent = {19}, PlaceholderColor3 = Color3.new(0.47058826684952, 0.47058826684952, 0.47058826684952), PlaceholderText = "Custom Player Set", Position = UDim2.new(0, 5, 0, 64), Size = UDim2.new(1, -35, 0, 20), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {28, "Frame", { BackgroundColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), BorderSizePixel = 0, Name = "CustomButton", Parent = {19}, Position = UDim2.new(1, -25, 0, 64), Size = UDim2.new(0, 20, 0, 20), ZIndex = 10 }},
        {29, "TextButton", { BackgroundColor3 = Color3.new(0.58823531866074, 0.58823531866074, 0.59215688705444), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "On", Parent = {28}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), Text = "", TextColor3 = Color3.new(0, 0, 0), TextSize = 14, ZIndex = 10 }},
        {30, "Frame", { BackgroundColor3 = Color3.new(0.19607844948769, 0.19607844948769, 0.19607844948769), BackgroundTransparency = 1, BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), Name = "Strings", Parent = {18}, Position = UDim2.new(0, 0, 0, 25), Size = UDim2.new(1, 0, 0, 64), Visible = false, ZIndex = 10 }},
        {31, "TextLabel", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = 3, Name = "Title", Parent = {30}, Size = UDim2.new(1, 0, 0, 20), Text = "Choose String", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, ZIndex = 10 }},
        {32, "TextLabel", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "Any", Parent = {30}, Position = UDim2.new(0, 5, 0, 20), Size = UDim2.new(1, -10, 0, 20), Text = "Any String", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {33, "Frame", { BackgroundColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), BorderSizePixel = 0, Name = "Button", Parent = {32}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), ZIndex = 10 }},
        {34, "TextButton", { BackgroundColor3 = Color3.new(0.58823531866074, 0.58823531866074, 0.59215688705444), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "On", Parent = {33}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), Text = "", TextColor3 = Color3.new(0, 0, 0), TextSize = 14, ZIndex = 10 }},
        {54, "Frame", { BackgroundColor3 = Color3.new(0.19607844948769, 0.19607844948769, 0.19607844948769), BackgroundTransparency = 1, BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), Name = "Numbers", Parent = {18}, Position = UDim2.new(0, 0, 0, 25), Size = UDim2.new(1, 0, 0, 64), Visible = false, ZIndex = 10 }},
        {55, "TextLabel", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = 3, Name = "Title", Parent = {54}, Size = UDim2.new(1, 0, 0, 20), Text = "Choose String", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, ZIndex = 10 }},
        {56, "TextLabel", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "Any", Parent = {54}, Position = UDim2.new(0, 5, 0, 20), Size = UDim2.new(1, -10, 0, 20), Text = "Any Number", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {57, "Frame", { BackgroundColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), BorderSizePixel = 0, Name = "Button", Parent = {56}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), ZIndex = 10 }},
        {58, "TextButton", { BackgroundColor3 = Color3.new(0.58823531866074, 0.58823531866074, 0.59215688705444), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "On", Parent = {57}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), Text = "", TextColor3 = Color3.new(0, 0, 0), TextSize = 14, ZIndex = 10 }},
        {59, "TextBox", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), BorderSizePixel = 0, ClearTextOnFocus = false, Font = 3, Name = "Custom", Parent = {54}, PlaceholderColor3 = Color3.new(0.47058826684952, 0.47058826684952, 0.47058826684952), PlaceholderText = "Number", Position = UDim2.new(0, 5, 0, 42), Size = UDim2.new(1, -35, 0, 20), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {60, "Frame", { BackgroundColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), BorderSizePixel = 0, Name = "CustomButton", Parent = {54}, Position = UDim2.new(1, -25, 0, 42), Size = UDim2.new(0, 20, 0, 20), ZIndex = 10 }},
        {61, "TextButton", { BackgroundColor3 = Color3.new(0.58823531866074, 0.58823531866074, 0.59215688705444), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "On", Parent = {60}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), Text = "", TextColor3 = Color3.new(0, 0, 0), TextSize = 14, ZIndex = 10 }},
        {35, "TextBox", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), BorderSizePixel = 0, ClearTextOnFocus = false, Font = 3, Name = "Custom", Parent = {30}, PlaceholderColor3 = Color3.new(0.47058826684952, 0.47058826684952, 0.47058826684952), PlaceholderText = "Match String", Position = UDim2.new(0, 5, 0, 42), Size = UDim2.new(1, -35, 0, 20), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {36, "Frame", { BackgroundColor3 = Color3.new(0.30588236451149, 0.30588236451149, 0.3098039329052), BorderSizePixel = 0, Name = "CustomButton", Parent = {30}, Position = UDim2.new(1, -25, 0, 42), Size = UDim2.new(0, 20, 0, 20), ZIndex = 10 }},
        {37, "TextButton", { BackgroundColor3 = Color3.new(0.58823531866074, 0.58823531866074, 0.59215688705444), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "On", Parent = {36}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), Text = "", TextColor3 = Color3.new(0, 0, 0), TextSize = 14, ZIndex = 10 }},
        {38, "Frame", { BackgroundColor3 = Color3.new(0.19607844948769, 0.19607844948769, 0.19607844948769), BackgroundTransparency = 1, BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), Name = "DelayEditor", Parent = {18}, Position = UDim2.new(0, 0, 0, 25), Size = UDim2.new(1, 0, 0, 24), Visible = false, ZIndex = 10 }},
        {39, "TextBox", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BorderColor3 = Color3.new(0.15686275064945, 0.15686275064945, 0.15686275064945), BorderSizePixel = 0, Font = 3, Name = "Secs", Parent = {38}, PlaceholderColor3 = Color3.new(0.47058826684952, 0.47058826684952, 0.47058826684952), Position = UDim2.new(0, 60, 0, 2), Size = UDim2.new(1, -65, 0, 20), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {40, "TextLabel", { BackgroundColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), BackgroundTransparency = 1, BorderSizePixel = 0, Font = 3, Name = "Label", Parent = {39}, Position = UDim2.new(0, -55, 0, 0), Size = UDim2.new(1, 0, 1, 0), Text = "Delay (s):", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {41, "Frame", { BackgroundColor3 = currentShade1, BorderSizePixel = 0, ClipsDescendants = true, Name = "EventTemplate", Parent = {6}, Size = UDim2.new(1, 0, 0, 20), Visible = false, ZIndex = 10 }},
        {42, "TextButton", { BackgroundColor3 = currentText1, BackgroundTransparency = 1, Font = 3, Name = "Expand", Parent = {41}, Size = UDim2.new(0, 20, 0, 20), Text = ">", TextColor3 = Color3.new(1, 1, 1), TextSize = 18, ZIndex = 10 }},
        {43, "TextLabel", { BackgroundColor3 = currentText1, BackgroundTransparency = 1, Font = 3, Name = "EventName", Parent = {41}, Position = UDim2.new(0, 25, 0, 0), Size = UDim2.new(1, -25, 0, 20), Text = "OnSpawn", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {44, "Frame", { BackgroundColor3 = Color3.new(0.19607844948769, 0.19607844948769, 0.19607844948769), BorderSizePixel = 0, BackgroundTransparency = 1, ClipsDescendants = true, Name = "Cmds", Parent = {41}, Position = UDim2.new(0, 0, 0, 20), Size = UDim2.new(1, 0, 1, -20), ZIndex = 10 }},
        {45, "Frame", { BackgroundColor3 = Color3.new(0.14117647707462, 0.14117647707462, 0.14509804546833), BorderColor3 = Color3.new(0.1803921610117, 0.1803921610117, 0.1843137294054), Name = "Add", Parent = {44}, Position = UDim2.new(0, 0, 1, -20), Size = UDim2.new(1, 0, 0, 20), ZIndex = 10 }},
        {46, "TextBox", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, ClearTextOnFocus = false, Font = 3, Parent = {45}, PlaceholderColor3 = Color3.new(0.7843137383461, 0.7843137383461, 0.7843137383461), PlaceholderText = "Add new command", Position = UDim2.new(0, 5, 0, 0), Size = UDim2.new(1, -10, 1, 0), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {47, "Frame", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Name = "Holder", Parent = {44}, Size = UDim2.new(1, 0, 1, -20), ZIndex = 10 }},
        {48, "UIListLayout", { Parent = {47}, SortOrder = 2 }},
        {49, "Frame", { currentShade1, BorderSizePixel = 0, ClipsDescendants = true, Name = "CmdTemplate", Parent = {6}, Size = UDim2.new(1, 0, 0, 20), Visible = false, ZIndex = 10 }},
        {50, "TextBox", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, ClearTextOnFocus = false, Font = 3, Parent = {49}, PlaceholderColor3 = Color3.new(1, 1, 1), Position = UDim2.new(0, 5, 0, 0), Size = UDim2.new(1, -45, 0, 20), Text = "a\\b\\c\\d", TextColor3 = currentText1, TextSize = 14, TextXAlignment = 0, ZIndex = 10 }},
        {51, "TextButton", { BackgroundColor3 = currentShade1, BorderSizePixel = 0, Font = 3, Name = "Delete", Parent = {49}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), Text = "X", TextColor3 = Color3.new(1, 1, 1), TextSize = 18, ZIndex = 10 }},
        {52, "TextButton", { BackgroundColor3 = currentShade1, BorderSizePixel = 0, Font = 3, Name = "Settings", Parent = {49}, Position = UDim2.new(1, -40, 0, 0), Size = UDim2.new(0, 20, 0, 20), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 18, ZIndex = 10 }},
        {53, "ImageLabel", { BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Image = "rbxassetid://1204397029", Parent = {52}, Position = UDim2.new(0, 2, 0, 2), Size = UDim2.new(0, 16, 0, 16), ZIndex = 10 }},
    })
    main.Name = randomString()
    local mainFrame = main:WaitForChild("Content")
    local eventList = mainFrame:WaitForChild("List")
    local eventListHolder = eventList:WaitForChild("Holder")
    local cmdTemplate = mainFrame:WaitForChild("CmdTemplate")
    local eventTemplate = mainFrame:WaitForChild("EventTemplate")
    local settingsFrame = mainFrame:WaitForChild("Settings"):WaitForChild("Slider")
    local settingsTemplates = mainFrame.Settings:WaitForChild("Templates")
    local settingsList = settingsFrame:WaitForChild("List"):WaitForChild("Holder")
    table.insert(shade2, main.TopBar) table.insert(shade1, mainFrame) table.insert(shade2, eventTemplate)
    table.insert(text1, eventTemplate.EventName) table.insert(shade1, eventTemplate.Cmds.Add) table.insert(shade1, cmdTemplate)
    table.insert(text1, cmdTemplate.TextBox) table.insert(shade2, cmdTemplate.Delete) table.insert(shade2, cmdTemplate.Settings)
    table.insert(scroll, mainFrame.List) table.insert(shade1, settingsFrame) table.insert(shade2, settingsFrame.Line)
    table.insert(shade2, settingsFrame.Close) table.insert(scroll, settingsFrame.List) table.insert(shade2, settingsTemplates.DelayEditor.Secs)
    table.insert(text1, settingsTemplates.DelayEditor.Secs) table.insert(text1, settingsTemplates.DelayEditor.Secs.Label) table.insert(text1, settingsTemplates.Players.Title)
    table.insert(shade3, settingsTemplates.Players.CustomButton) table.insert(shade2, settingsTemplates.Players.Custom) table.insert(text1, settingsTemplates.Players.Custom)
    table.insert(shade3, settingsTemplates.Players.Any.Button) table.insert(shade3, settingsTemplates.Players.Me.Button) table.insert(text1, settingsTemplates.Players.Any)
    table.insert(text1, settingsTemplates.Players.Me) table.insert(text1, settingsTemplates.Strings.Title) table.insert(text1, settingsTemplates.Strings.Any)
    table.insert(shade3, settingsTemplates.Strings.Any.Button) table.insert(shade3, settingsTemplates.Strings.CustomButton) table.insert(text1, settingsTemplates.Strings.Custom)
    table.insert(shade2, settingsTemplates.Strings.Custom)
    table.insert(text1, settingsTemplates.Players.Me) table.insert(text1, settingsTemplates.Numbers.Title) table.insert(text1, settingsTemplates.Numbers.Any)
    table.insert(shade3, settingsTemplates.Numbers.Any.Button) table.insert(shade3, settingsTemplates.Numbers.CustomButton) table.insert(text1, settingsTemplates.Numbers.Custom)
    table.insert(shade2, settingsTemplates.Numbers.Custom)

    local tweenInf = TweenInfo.new(0.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)

    local currentlyEditingCmd = nil

    settingsFrame:WaitForChild("Close").MouseButton1Click:Connect(function()
        settingsFrame:TweenPosition(UDim2.new(0, -150, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.25, true)
    end)

    local function resizeList()
        local size = 0

        for i, v in pairs(eventListHolder:GetChildren()) do
            if v.Name == "EventTemplate" then
                size = size + 20
                if v.Expand.Rotation == 90 then
                    size = size + 20 * (1 + (#events[v.EventName:GetAttribute("RawName")].commands or 0))
                end
            end
        end

        TweenService:Create(eventList, tweenInf, { CanvasSize = UDim2.new(0, 0, 0, size) }):Play()

        if size > eventList.AbsoluteSize.Y then
            eventListHolder.Size = UDim2.new(1, -8, 1, 0)
        else
            eventListHolder.Size = UDim2.new(1, 0, 1, 0)
        end
    end

    local function resizeSettingsList()
        local size = 0

        for i, v in pairs(settingsList:GetChildren()) do
            if v:IsA("Frame") then
                size = size + v.AbsoluteSize.Y
            end
        end

        settingsList.Parent.CanvasSize = UDim2.new(0, 0, 0, size)

        if size > settingsList.Parent.AbsoluteSize.Y then
            settingsList.Size = UDim2.new(1, -8, 1, 0)
        else
            settingsList.Size = UDim2.new(1, 0, 1, 0)
        end
    end

    local function setupCheckbox(button, callback)
        local enabled = button.On.BackgroundTransparency == 0

        local function update()
            button.On.BackgroundTransparency = (enabled and 0 or 1)
        end

        button.On.MouseButton1Click:Connect(function()
            enabled = not enabled
            update()
            if callback then callback(enabled) end
        end)

        return {
            Toggle = function(nocall) enabled = not enabled update() if not nocall and callback then callback(enabled) end end,
            Enable = function(nocall) if enabled then return end enabled = true update() if not nocall and callback then callback(enabled) end end,
            Disable = function(nocall) if not enabled then return end enabled = false update() if not nocall and callback then callback(enabled) end end,
            IsEnabled = function() return enabled end
        }
    end

    local function openSettingsEditor(event, cmd)
        currentlyEditingCmd = cmd

        for i, v in pairs(settingsList:GetChildren()) do if v:IsA("Frame") then v:Destroy() end end

        local delayEditor = settingsTemplates.DelayEditor:Clone()
        delayEditor.Secs.FocusLost:Connect(function()
            cmd[3] = tonumber(delayEditor.Secs.Text) or 0
            delayEditor.Secs.Text = cmd[3]
            if onEdited then onEdited() end
        end)
        delayEditor.Secs.Text = cmd[3]
        delayEditor.Visible = true
        table.insert(shade2, delayEditor.Secs)
        table.insert(text1, delayEditor.Secs)
        table.insert(text1, delayEditor.Secs.Label)
        delayEditor.Parent = settingsList

        for i, v in pairs(event.sets) do
            if v.Type == "Player" then
                local template = settingsTemplates.Players:Clone()
                template.Title.Text = v.Name or "Player"

                local me, any, custom

                me = setupCheckbox(template.Me.Button, function(on)
                    if not on then return end
                    any.Disable()
                    custom.Disable()
                    cmd[2][i] = 0
                    if onEdited then onEdited() end
                end)

                any = setupCheckbox(template.Any.Button, function(on)
                    if not on then return end
                    me.Disable()
                    custom.Disable()
                    cmd[2][i] = 1
                    if onEdited then onEdited() end
                end)

                local customTextBox = template.Custom
                custom = setupCheckbox(template.CustomButton, function(on)
                    if not on then return end
                    me.Disable()
                    any.Disable()
                    cmd[2][i] = customTextBox.Text
                    if onEdited then onEdited() end
                end)

                ViewportTextBox.convert(customTextBox)
                customTextBox.FocusLost:Connect(function()
                    if custom:IsEnabled() then
                        cmd[2][i] = customTextBox.Text
                        if onEdited then onEdited() end
                    end
                end)

                local cVal = cmd[2][i]
                if cVal == 0 then
                    me:Enable()
                elseif cVal == 1 then
                    any:Enable()
                else
                    custom:Enable()
                    customTextBox.Text = cVal
                end

                template.Visible = true
                table.insert(text1, template.Title)
                table.insert(shade3, template.CustomButton)
                table.insert(shade3, template.Any.Button)
                table.insert(shade3, template.Me.Button)
                table.insert(text1, template.Any)
                table.insert(text1, template.Me)
                template.Parent = settingsList
            elseif v.Type == "String" then
                local template = settingsTemplates.Strings:Clone()
                template.Title.Text = v.Name or "String"

                local any, custom

                any = setupCheckbox(template.Any.Button, function(on)
                    if not on then return end
                    custom.Disable()
                    cmd[2][i] = 0
                    if onEdited then onEdited() end
                end)

                local customTextBox = template.Custom
                custom = setupCheckbox(template.CustomButton, function(on)
                    if not on then return end
                    any.Disable()
                    cmd[2][i] = customTextBox.Text
                    if onEdited then onEdited() end
                end)

                ViewportTextBox.convert(customTextBox)
                customTextBox.FocusLost:Connect(function()
                    if custom:IsEnabled() then
                        cmd[2][i] = customTextBox.Text
                        if onEdited then onEdited() end
                    end
                end)

                local cVal = cmd[2][i]
                if cVal == 0 then
                    any:Enable()
                else
                    custom:Enable()
                    customTextBox.Text = cVal
                end

                template.Visible = true
                table.insert(text1, template.Title)
                table.insert(text1, template.Any)
                table.insert(shade3, template.Any.Button)
                table.insert(shade3, template.CustomButton)
                template.Parent = settingsList
            elseif v.Type == "Number" then
                local template = settingsTemplates.Numbers:Clone()
                template.Title.Text = v.Name or "Number"

                local any, custom

                any = setupCheckbox(template.Any.Button, function(on)
                    if not on then return end
                    custom.Disable()
                    cmd[2][i] = 0
                    if onEdited then onEdited() end
                end)

                local customTextBox = template.Custom
                custom = setupCheckbox(template.CustomButton, function(on)
                    if not on then return end
                    any.Disable()
                    cmd[2][i] = customTextBox.Text
                    if onEdited then onEdited() end
                end)

                ViewportTextBox.convert(customTextBox)
                customTextBox.FocusLost:Connect(function()
                    cmd[2][i] = tonumber(customTextBox.Text) or 0
                    customTextBox.Text = cmd[2][i]
                    if custom:IsEnabled() then
                        if onEdited then onEdited() end
                    end
                end)

                local cVal = cmd[2][i]
                if cVal == 0 then
                    any:Enable()
                else
                    custom:Enable()
                    customTextBox.Text = cVal
                end

                template.Visible = true
                table.insert(text1, template.Title)
                table.insert(text1, template.Any)
                table.insert(shade3, template.Any.Button)
                table.insert(shade3, template.CustomButton)
                template.Parent = settingsList
            end
        end
        resizeSettingsList()
        settingsFrame:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.25, true)
    end

    local function defaultSettings(ev)
        local res = {}

        for i, v in pairs(ev.sets) do
            if v.Type == "Player" then
                res[#res + 1] = v.Default or 0
            elseif v.Type == "String" then
                res[#res + 1] = v.Default or 0
            elseif v.Type == "Number" then
                res[#res + 1] = v.Default or 0
            end
        end

        return res
    end

    local function refreshList()
        for i, v in pairs(eventListHolder:GetChildren()) do if v:IsA("Frame") then v:Destroy() end end

        for name, event in pairs(events) do
            local eventF = eventTemplate:Clone()
            eventF.EventName.Text = name
            eventF.Visible = true
            eventF.EventName:SetAttribute("RawName", name)
            table.insert(shade2, eventF)
            table.insert(text1, eventF.EventName)
            table.insert(shade1, eventF.Cmds.Add)

            local expanded = false
            eventF.Expand.MouseButton1Down:Connect(function()
                expanded = not expanded
                eventF:TweenSize(UDim2.new(1, 0, 0, 20 + (expanded and 20 * #eventF.Cmds.Holder:GetChildren() or 0)), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.25, true)
                eventF.Expand.Rotation = expanded and 90 or 0
                resizeList()
            end)

            local function refreshCommands()
                for i, v in pairs(eventF.Cmds.Holder:GetChildren()) do
                    if v.Name == "CmdTemplate" then
                        v:Destroy()
                    end
                end

                eventF.EventName.Text = name .. (#event.commands > 0 and " (" .. #event.commands .. ")" or "")

                for i, cmd in pairs(event.commands) do
                    local cmdF = cmdTemplate:Clone()
                    local cmdTextBox = cmdF.TextBox
                    ViewportTextBox.convert(cmdTextBox)
                    cmdTextBox.Text = cmd[1]
                    cmdF.Visible = true
                    table.insert(shade1, cmdF)
                    table.insert(shade2, cmdF.Delete)
                    table.insert(shade2, cmdF.Settings)

                    cmdTextBox.FocusLost:Connect(function()
                        event.commands[i] = { cmdTextBox.Text, cmd[2], cmd[3] }
                        if onEdited then onEdited() end
                    end)

                    cmdF.Settings.MouseButton1Click:Connect(function()
                        openSettingsEditor(event, cmd)
                    end)

                    cmdF.Delete.MouseButton1Click:Connect(function()
                        table.remove(event.commands, i)
                        refreshCommands()
                        resizeList()

                        if currentlyEditingCmd == cmd then
                            settingsFrame:TweenPosition(UDim2.new(0, -150, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.25, true)
                        end
                        if onEdited then onEdited() end
                    end)

                    cmdF.Parent = eventF.Cmds.Holder
                end

                eventF:TweenSize(UDim2.new(1, 0, 0, 20 + (expanded and 20 * #eventF.Cmds.Holder:GetChildren() or 0)), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.25, true)
            end

            local newBox = eventF.Cmds.Add.TextBox
            ViewportTextBox.convert(newBox)
            newBox.FocusLost:Connect(function(enter)
                if enter then
                    event.commands[#event.commands + 1] = { newBox.Text, defaultSettings(event), 0 }
                    newBox.Text = ""

                    refreshCommands()
                    resizeList()
                    if onEdited then onEdited() end
                end
            end)

            eventF.Parent = eventListHolder

            refreshCommands()
        end

        resizeList()
    end

    local function saveData()
        local result = {}
        for i, v in pairs(events) do
            result[i] = v.commands
        end
        return HttpService:JSONEncode(result)
    end

    local function loadData(str)
        local data = HttpService:JSONDecode(str)
        for i, v in pairs(data) do
            if events[i] then
                events[i].commands = v
            end
        end
    end

    local function addCmd(event, data)
        table.insert(events[event].commands, data)
    end

    local function setOnEdited(f)
        if type(f) == "function" then
            onEdited = f
        end
    end

    main.TopBar.Close.MouseButton1Click:Connect(function()
        main:TweenPosition(UDim2.new(0.5, -175, 0, -500), "InOut", "Quart", 0.5, true, nil)
    end)
    dragGUI(main)
    main.Parent = ScaledHolder

    return {
        RegisterEvent = registerEvent,
        FireEvent = fireEvent,
        Refresh = refreshList,
        SaveData = saveData,
        LoadData = loadData,
        AddCmd = addCmd,
        Frame = main,
        SetOnEdited = setOnEdited
    }
end)()

-- Main function to create the reference GUI
local function createReferenceGUI()
    -- Create the main frame and its children
    local main = create({
        {1, "Frame", {BackgroundColor3 = Color3.new(0.141, 0.141, 0.145), BackgroundTransparency = 1, BorderSizePixel = 0, Name = "Main", Position = UDim2.new(0.5, -250, 0, -500), Size = UDim2.new(0, 500, 0, 20), ZIndex = 10}},
        {2, "Frame", {BackgroundColor3 = Color3.new(0.180, 0.180, 0.184), BorderSizePixel = 0, Name = "TopBar", Parent = {1}, Size = UDim2.new(1, 0, 0, 20), ZIndex = 10}},
        {3, "TextLabel", {BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = Enum.Font.SourceSans, Name = "Title", Parent = {2}, Size = UDim2.new(1, 0, 0.95, 0), Text = "Reference", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, ZIndex = 10}},
        {4, "TextButton", {BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Font = Enum.Font.SourceSans, Name = "Close", Parent = {2}, Position = UDim2.new(1, -20, 0, 0), Size = UDim2.new(0, 20, 0, 20), Text = "", TextColor3 = Color3.new(1, 1, 1), TextSize = 14, ZIndex = 10}},
        {5, "ImageLabel", {BackgroundColor3 = Color3.new(1, 1, 1), BackgroundTransparency = 1, Image = "rbxassetid://5054663650", Parent = {4}, Position = UDim2.new(0, 5, 0, 5), Size = UDim2.new(0, 10, 0, 10), ZIndex = 10}},
        {6, "Frame", {BackgroundColor3 = Color3.new(0.141, 0.141, 0.145), BorderSizePixel = 0, Name = "Content", Parent = {1}, Position = UDim2.new(0, 0, 0, 20), Size = UDim2.new(1, 0, 0, 300), ZIndex = 10}},
        {7, "ScrollingFrame", {BackgroundColor3 = Color3.new(0.141, 0.141, 0.145), BackgroundTransparency = 1, BorderSizePixel = 0, BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png", CanvasSize = UDim2.new(0, 0, 0, 1313), Name = "List", Parent = {6}, ScrollBarImageColor3 = Color3.new(0.305, 0.305, 0.309), ScrollBarThickness = 8, Size = UDim2.new(1, 0, 1, 0), TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png", VerticalScrollBarInset = 2, ZIndex = 10}},
        {8, "UIListLayout", {Parent = {7}, SortOrder = Enum.SortOrder.LayoutOrder}},
        -- Add more elements as needed...
    })

    -- Store text labels and other elements for easy access
    local textLabels = {}
    for _, v in pairs(main.Content.List:GetDescendants()) do
        if v:IsA("TextLabel") then
            table.insert(textLabels, v)
        end
    end

    -- Add main frame to scroll and shade lists
    table.insert(scroll, main.Content.List)
    table.insert(shade1, main.Content)
    table.insert(shade2, main.TopBar)

    -- Randomize the main frame's name
    main.Name = randomString()

    -- Close button functionality
    main.TopBar.Close.MouseButton1Click:Connect(function()
        main:TweenPosition(UDim2.new(0.5, -250, 0, -500), "InOut", "Quart", 0.5, true)
    end)

    -- Discord invite button functionality
    local inviteButton = main:FindFirstChild("InviteButton", true)
    local lastPress = nil
    inviteButton.MouseButton1Click:Connect(function()
        if everyClipboard then
            toClipboard("https://discord.gg/78ZuWSq")
            inviteButton.Text = "Copied"
        else
            inviteButton.Text = "No Clipboard Function, type out the link"
        end
        local pressTime = tick()
        lastPress = pressTime
        wait(2)
        if lastPress == pressTime then
            inviteButton.Text = "Copy Discord Invite Link (https://discord.gg/78ZuWSq)"
        end
    end)

    -- Enable dragging for the main frame
    dragGUI(main)

    -- Parent the main frame to the ScaledHolder
    main.Parent = ScaledHolder

    -- Reference button functionality
    ReferenceButton.MouseButton1Click:Connect(function()
        main:TweenPosition(UDim2.new(0.5, -250, 0.5, -150), "InOut", "Quart", 0.5, true)
    end)
end

-- Execute the function to create the reference GUI
createReferenceGUI()

-- Define default color values
currentShade1 = Color3.fromRGB(36, 36, 37)
currentShade2 = Color3.fromRGB(46, 46, 47)
currentShade3 = Color3.fromRGB(78, 78, 79)
currentText1 = Color3.new(1, 1, 1)
currentText2 = Color3.new(0, 0, 0)
currentScroll = Color3.fromRGB(78, 78, 79)

-- Define default GUI scale based on platform
defaultGuiScale = IsOnMobile and 0.9 or 1

-- Define default settings
defaultsettings = {
    prefix = ';',
    StayOpen = false,
    guiScale = defaultGuiScale,
    espTransparency = 0.3,
    keepIY = true,
    logsEnabled = false,
    jLogsEnabled = false,
    aliases = {},
    binds = {},
    WayPoints = {},
    PluginsTable = {},
    currentShade1 = {currentShade1.R, currentShade1.G, currentShade1.B},
    currentShade2 = {currentShade2.R, currentShade2.G, currentShade2.B},
    currentShade3 = {currentShade3.R, currentShade3.G, currentShade3.B},
    currentText1 = {currentText1.R, currentText1.G, currentText1.B},
    currentText2 = {currentText2.R, currentText2.G, currentText2.B},
    currentScroll = {currentScroll.R, currentScroll.G, currentScroll.B},
    eventBinds = eventEditor.SaveData()
}

-- Encode default settings to JSON
defaults = HttpService:JSONEncode(defaultsettings)
nosaves = false

-- Function to reset settings to factory defaults
function useFactorySettings()
    prefix = ';'
    StayOpen = false
    guiScale = defaultGuiScale
    KeepInfYield = true
    espTransparency = 0.3
    logsEnabled = false
    jLogsEnabled = false
    logsWebhook = nil
    aliases = {}
    binds = {}
    WayPoints = {}
    PluginsTable = {}
end

-- Function to create a popup notification
function createPopup(text)
    local FileError = Instance.new("Frame")
    local background = Instance.new("Frame")
    local Directions = Instance.new("TextLabel")
    local shadow = Instance.new("Frame")
    local PopupText = Instance.new("TextLabel")
    local Exit = Instance.new("TextButton")
    local ExitImage = Instance.new("ImageLabel")

    FileError.Name = randomString()
    FileError.Parent = ScaledHolder
    FileError.Active = true
    FileError.BackgroundTransparency = 1
    FileError.Position = UDim2.new(0.5, -180, 0, 290)
    FileError.Size = UDim2.new(0, 360, 0, 20)
    FileError.ZIndex = 10

    background.Name = "background"
    background.Parent = FileError
    background.Active = true
    background.BackgroundColor3 = Color3.fromRGB(36, 36, 37)
    background.BorderSizePixel = 0
    background.Position = UDim2.new(0, 0, 0, 20)
    background.Size = UDim2.new(0, 360, 0, 205)
    background.ZIndex = 10

    Directions.Name = "Directions"
    Directions.Parent = background
    Directions.BackgroundTransparency = 1
    Directions.BorderSizePixel = 0
    Directions.Position = UDim2.new(0, 10, 0, 10)
    Directions.Size = UDim2.new(0, 340, 0, 185)
    Directions.Font = Enum.Font.SourceSans
    Directions.TextSize = 14
    Directions.Text = text
    Directions.TextColor3 = Color3.new(1, 1, 1)
    Directions.TextWrapped = true
    Directions.TextXAlignment = Enum.TextXAlignment.Left
    Directions.TextYAlignment = Enum.TextYAlignment.Top
    Directions.ZIndex = 10

    shadow.Name = "shadow"
    shadow.Parent = FileError
    shadow.BackgroundColor3 = Color3.fromRGB(46, 46, 47)
    shadow.BorderSizePixel = 0
    shadow.Size = UDim2.new(0, 360, 0, 20)
    shadow.ZIndex = 10

    PopupText.Name = "PopupText"
    PopupText.Parent = shadow
    PopupText.BackgroundTransparency = 1
    PopupText.Size = UDim2.new(1, 0, 0.95, 0)
    PopupText.ZIndex = 10
    PopupText.Font = Enum.Font.SourceSans
    PopupText.TextSize = 14
    PopupText.Text = "File Error"
    PopupText.TextColor3 = Color3.new(1, 1, 1)
    PopupText.TextWrapped = true

    Exit.Name = "Exit"
    Exit.Parent = shadow
    Exit.BackgroundTransparency = 1
    Exit.Position = UDim2.new(1, -20, 0, 0)
    Exit.Size = UDim2.new(0, 20, 0, 20)
    Exit.Text = ""
    Exit.ZIndex = 10

    ExitImage.Parent = Exit
    ExitImage.BackgroundColor3 = Color3.new(1, 1, 1)
    ExitImage.BackgroundTransparency = 1
    ExitImage.Position = UDim2.new(0, 5, 0, 5)
    ExitImage.Size = UDim2.new(0, 10, 0, 10)
    ExitImage.Image = "rbxassetid://5054663650"
    ExitImage.ZIndex = 10

    Exit.MouseButton1Click:Connect(function()
        FileError:Destroy()
    end)
end

-- Function to load saved settings
local loadedEventData = nil
local jsonAttempts = 0
function saves()
    if writefileExploit() and readfileExploit() and jsonAttempts < 10 then
        local readSuccess, out = readfile("IY_FE.iy", true)
        if readSuccess then
            if out ~= nil and tostring(out):gsub("%s", "") ~= "" then
                local success, response = pcall(function()
                    local json = HttpService:JSONDecode(out)
                    if vtype(json.prefix, "string") then prefix = json.prefix else prefix = ';' end
                    if vtype(json.StayOpen, "boolean") then StayOpen = json.StayOpen else StayOpen = false end
                    if vtype(json.guiScale, "number") then guiScale = json.guiScale else guiScale = defaultGuiScale end
                    if vtype(json.keepIY, "boolean") then KeepInfYield = json.keepIY else KeepInfYield = true end
                    if vtype(json.espTransparency, "number") then espTransparency = json.espTransparency else espTransparency = 0.3 end
                    if vtype(json.logsEnabled, "boolean") then logsEnabled = json.logsEnabled else logsEnabled = false end
                    if vtype(json.jLogsEnabled, "boolean") then jLogsEnabled = json.jLogsEnabled else jLogsEnabled = false end
                    if vtype(json.logsWebhook, "string") then logsWebhook = json.logsWebhook else logsWebhook = nil end
                    if vtype(json.aliases, "table") then aliases = json.aliases else aliases = {} end
                    if vtype(json.binds, "table") then binds = json.binds else binds = {} end
                    if vtype(json.spawnCmds, "table") then spawnCmds = json.spawnCmds end
                    if vtype(json.WayPoints, "table") then AllWaypoints = json.WayPoints else WayPoints = {} AllWaypoints = {} end
                    if vtype(json.PluginsTable, "table") then PluginsTable = json.PluginsTable else PluginsTable = {} end
                    if vtype(json.currentShade1, "table") then currentShade1 = Color3.new(json.currentShade1[1], json.currentShade1[2], json.currentShade1[3]) end
                    if vtype(json.currentShade2, "table") then currentShade2 = Color3.new(json.currentShade2[1], json.currentShade2[2], json.currentShade2[3]) end
                    if vtype(json.currentShade3, "table") then currentShade3 = Color3.new(json.currentShade3[1], json.currentShade3[2], json.currentShade3[3]) end
                    if vtype(json.currentText1, "table") then currentText1 = Color3.new(json.currentText1[1], json.currentText1[2], json.currentText1[3]) end
                    if vtype(json.currentText2, "table") then currentText2 = Color3.new(json.currentText2[1], json.currentText2[2], json.currentText2[3]) end
                    if vtype(json.currentScroll, "table") then currentScroll = Color3.new(json.currentScroll[1], json.currentScroll[2], json.currentScroll[3]) end
                    if vtype(json.eventBinds, "string") then loadedEventData = json.eventBinds end
                end)
                if not success then
                    jsonAttempts = jsonAttempts + 1
                    warn("Save Json Error:", response)
                    warn("Overwriting Save File")
                    writefile("IY_FE.iy", defaults, true)
                    wait()
                    saves()
                end
            else
                writefile("IY_FE.iy", defaults, true)
                wait()
                local dReadSuccess, dOut = readfile("IY_FE.iy", true)
                if dReadSuccess and dOut ~= nil and tostring(dOut):gsub("%s", "") ~= "" then
                    saves()
                else
                    nosaves = true
                    useFactorySettings()
                    createPopup("There was a problem writing a save file to your PC.\n\nPlease contact the developer/support team for your exploit and tell them writefile/readfile is not working.\n\nYour settings, keybinds, waypoints, and aliases will not save if you continue.\n\nThings to try:\n> Make sure a 'workspace' folder is located in the same folder as your exploit\n> If your exploit is inside of a zip/rar file, extract it.\n> Rejoin the game and try again or restart your PC and try again.")
                end
            end
        else
            writefile("IY_FE.iy", defaults, true)
            wait()
            local dReadSuccess, dOut = readfile("IY_FE.iy", true)
            if dReadSuccess and dOut ~= nil and tostring(dOut):gsub("%s", "") ~= "" then
                saves()
            else
                nosaves = true
                useFactorySettings()
                createPopup("There was a problem writing a save file to your PC.\n\nPlease contact the developer/support team for your exploit and tell them writefile/readfile is not working.\n\nYour settings, keybinds, waypoints, and aliases will not save if you continue.\n\nThings to try:\n> Make sure a 'workspace' folder is located in the same folder as your exploit\n> If your exploit is inside of a zip/rar file, extract it.\n> Rejoin the game and try again or restart your PC and try again.")
            end
        end
    else
        if jsonAttempts >= 10 then
            nosaves = true
            useFactorySettings()
            createPopup("Sorry, we have attempted to parse your save file, but it is unreadable!\n\nInfinite Yield is now using factory settings until your exploit's file system works.\n\nYour save file has not been deleted.")
        else
            nosaves = true
            useFactorySettings()
        end
    end
end

-- Load saved settings
saves()

-- Function to update saved settings
function updatesaves()
    if nosaves == false and writefileExploit() then
        local update = {
            prefix = prefix,
            StayOpen = StayOpen,
            guiScale = guiScale,
            keepIY = KeepInfYield,
            espTransparency = espTransparency,
            logsEnabled = logsEnabled,
            jLogsEnabled = jLogsEnabled,
            logsWebhook = logsWebhook,
            aliases = aliases,
            binds = binds or {},
            WayPoints = AllWaypoints,
            PluginsTable = PluginsTable,
            currentShade1 = {currentShade1.R, currentShade1.G, currentShade1.B},
            currentShade2 = {currentShade2.R, currentShade2.G, currentShade2.B},
            currentShade3 = {currentShade3.R, currentShade3.G, currentShade3.B},
            currentText1 = {currentText1.R, currentText1.G, currentText1.B},
            currentText2 = {currentText2.R, currentText2.G, currentText2.B},
            currentScroll = {currentScroll.R, currentScroll.G, currentScroll.B},
            eventBinds = eventEditor.SaveData()
        }
        writefileCooldown("IY_FE.iy", HttpService:JSONEncode(update))
    end
end

-- Set event editor's onEdited callback to update saves
eventEditor.SetOnEdited(updatesaves)

-- Initialize waypoints
pWayPoints = {}
WayPoints = {}

if #AllWaypoints > 0 then
    for i = 1, #AllWaypoints do
        if not AllWaypoints[i].GAME or AllWaypoints[i].GAME == PlaceId then
            WayPoints[#WayPoints + 1] = {NAME = AllWaypoints[i].NAME, COORD = {AllWaypoints[i].COORD[1], AllWaypoints[i].COORD[2], AllWaypoints[i].COORD[3]}, GAME = AllWaypoints[i].GAME}
        end
    end
end

-- Ensure binds is a table
if type(binds) ~= "table" then binds = {} end

-- Function to get current time in HH:MM:SS AM/PM format
function Time()
    local HOUR = math.floor((tick() % 86400) / 3600)
    local MINUTE = math.floor((tick() % 3600) / 60)
    local SECOND = math.floor(tick() % 60)
    local AP = HOUR > 11 and 'PM' or 'AM'
    HOUR = (HOUR % 12 == 0 and 12 or HOUR % 12)
    HOUR = HOUR < 10 and '0' .. HOUR or HOUR
    MINUTE = MINUTE < 10 and '0' .. MINUTE or MINUTE
    SECOND = SECOND < 10 and '0' .. SECOND or SECOND
    return HOUR .. ':' .. MINUTE .. ':' .. SECOND .. ' ' .. AP
end

-- Set initial GUI states
PrefixBox.Text = prefix
local SettingsOpen = false
local isHidden = false

if StayOpen == false then
    On.BackgroundTransparency = 1
else
    On.BackgroundTransparency = 0
end

if logsEnabled then
    Toggle.Text = 'Enabled'
else
    Toggle.Text = 'Disabled'
end

if jLogsEnabled then
    Toggle_2.Text = 'Enabled'
else
    Toggle_2.Text = 'Disabled'
end

-- Function to maximize the holder
function maximizeHolder()
    if StayOpen == false then
        Holder:TweenPosition(UDim2.new(1, Holder.Position.X.Offset, 1, -220), "InOut", "Quart", 0.2, true, nil)
    end
end

-- Function to minimize the holder
minimizeNum = -20
function minimizeHolder()
    if StayOpen == false then
        Holder:TweenPosition(UDim2.new(1, Holder.Position.X.Offset, 1, minimizeNum), "InOut", "Quart", 0.5, true, nil)
    end
end

-- Function to adjust holder position for command bar
function cmdbarHolder()
    if StayOpen == false then
        Holder:TweenPosition(UDim2.new(1, Holder.Position.X.Offset, 1, -45), "InOut", "Quart", 0.5, true, nil)
    end
end

-- Function to create notifications
pinNotification = nil
local notifyCount = 0
function notify(text, text2, length)
    task.spawn(function()
        local LnotifyCount = notifyCount + 1
        local notificationPinned = false
        notifyCount = notifyCount + 1
        if pinNotification then pinNotification:Disconnect() end
        pinNotification = PinButton.MouseButton1Click:Connect(function()
            task.spawn(function()
                pinNotification:Disconnect()
                notificationPinned = true
                Title_2.BackgroundTransparency = 1
                wait(0.5)
                Title_2.BackgroundTransparency = 0
            end)
        end)
        Notification:TweenPosition(UDim2.new(1, Notification.Position.X.Offset, 1, 0), "InOut", "Quart", 0.5, true, nil)
        wait(0.6)
        local closepressed = false
        if text2 then
            Title_2.Text = text
            Text_2.Text = text2
        else
            Title_2.Text = 'Notification'
            Text_2.Text = text
        end
        Notification:TweenPosition(UDim2.new(1, Notification.Position.X.Offset, 1, -100), "InOut", "Quart", 0.5, true, nil)
        CloseButton.MouseButton1Click:Connect(function()
            Notification:TweenPosition(UDim2.new(1, Notification.Position.X.Offset, 1, 0), "InOut", "Quart", 0.5, true, nil)
            closepressed = true
            pinNotification:Disconnect()
        end)
        if length and isNumber(length) then
            wait(length)
        else
            wait(10)
        end
        if LnotifyCount == notifyCount then
            if closepressed == false and notificationPinned == false then
                pinNotification:Disconnect()
                Notification:TweenPosition(UDim2.new(1, Notification.Position.X.Offset, 1, 0), "InOut", "Quart", 0.5, true, nil)
            end
            notifyCount = 0
        end
    end)
end

-- Function to create chat labels
local lastMessage = nil
local lastLabel = nil
local dupeCount = 1
function CreateLabel(Name, Text)
    if lastMessage == Name .. Text then
        dupeCount = dupeCount + 1
        lastLabel.Text = Time() .. ' - [' .. Name .. ']: ' .. Text .. ' (x' .. dupeCount .. ')'
    else
        if dupeCount > 1 then dupeCount = 1 end
        if #scroll_2:GetChildren() >= 2546 then
            scroll_2:ClearAllChildren()
        end
        local alls = 0
        for i, v in pairs(scroll_2:GetChildren()) do
            if v then
                alls = v.Size.Y.Offset + alls
            end
            if not v then
                alls = 0
            end
        end
        local tl = Instance.new('TextLabel')
        lastMessage = Name .. Text
        lastLabel = tl
        tl.Name = Name
        tl.Parent = scroll_2
        tl.ZIndex = 10
        tl.Text = Time() .. " - [" .. Name .. "]: " .. Text
        tl.Size = UDim2.new(0, 322, 0, 84)
        tl.BackgroundTransparency = 1
        tl.BorderSizePixel = 0
        tl.Font = "SourceSans"
        tl.Position = UDim2.new(-1, 0, 0, alls)
        tl.TextTransparency = 1
        tl.TextScaled = false
        tl.TextSize = 14
        tl.TextWrapped = true
        tl.TextXAlignment = "Left"
        tl.TextYAlignment = "Top"
        tl.TextColor3 = currentText1
        tl.Size = UDim2.new(0, 322, 0, tl.TextBounds.Y)
        table.insert(text1, tl)
        scroll_2.CanvasSize = UDim2.new(0, 0, 0, alls + tl.TextBounds.Y)
        scroll_2.CanvasPosition = Vector2.new(0, scroll_2.CanvasPosition.Y + tl.TextBounds.Y)
        tl:TweenPosition(UDim2.new(0, 3, 0, alls), 'In', 'Quint', 0.5)
        TweenService:Create(tl, TweenInfo.new(1.25, Enum.EasingStyle.Linear), { TextTransparency = 0 }):Play()
    end
end

-- Function to create join labels
function CreateJoinLabel(plr, ID)
    if #scroll_3:GetChildren() >= 2546 then
        scroll_3:ClearAllChildren()
    end
    local infoFrame = Instance.new("Frame")
    local info1 = Instance.new("TextLabel")
    local info2 = Instance.new("TextLabel")
    local ImageLabel_3 = Instance.new("ImageLabel")
    infoFrame.Name = randomString()
    infoFrame.Parent = scroll_3
    infoFrame.BackgroundColor3 = Color3.new(1, 1, 1)
    infoFrame.BackgroundTransparency = 1
    infoFrame.BorderColor3 = Color3.new(0.105882, 0.164706, 0.207843)
    infoFrame.Size = UDim2.new(1, 0, 0, 50)
    info1.Name = randomString()
    info1.Parent = infoFrame
    info1.BackgroundTransparency = 1
    info1.BorderSizePixel = 0
    info1.Position = UDim2.new(0, 45, 0, 0)
    info1.Size = UDim2.new(0, 135, 1, 0)
    info1.ZIndex = 10
    info1.Font = Enum.Font.SourceSans
    info1.FontSize = Enum.FontSize.Size14
    info1.Text = "Username: " .. plr.Name .. "\nJoined Server: " .. Time()
    info1.TextColor3 = Color3.new(1, 1, 1)
    info1.TextWrapped = true
    info1.TextXAlignment = Enum.TextXAlignment.Left
    info2.Name = randomString()
    info2.Parent = infoFrame
    info2.BackgroundTransparency = 1
    info2.BorderSizePixel = 0
    info2.Position = UDim2.new(0, 185, 0, 0)
    info2.Size = UDim2.new(0, 140, 1, -5)
    info2.ZIndex = 10
    info2.Font = Enum.Font.SourceSans
    info2.FontSize = Enum.FontSize.Size14
    info2.Text = "User ID: " .. ID .. "\nAccount Age: " .. plr.AccountAge .. "\nJoined Roblox: Loading..."
    info2.TextColor3 = Color3.new(1, 1, 1)
    info2.TextWrapped = true
    info2.TextXAlignment = Enum.TextXAlignment.Left
    info2.TextYAlignment = Enum.TextYAlignment.Center
    ImageLabel_3.Parent = infoFrame
    ImageLabel_3.BackgroundTransparency = 1
    ImageLabel_3.BorderSizePixel = 0
    ImageLabel_3.Size = UDim2.new(0, 45, 1, 0)
    ImageLabel_3.Image = Players:GetUserThumbnailAsync(ID, Enum.ThumbnailType.AvatarThumbnail, Enum.ThumbnailSize.Size420x420)
    scroll_3.CanvasSize = UDim2.new(0, 0, 0, listlayout.AbsoluteContentSize.Y)
    scroll_3.CanvasPosition = Vector2.new(0, scroll_2.CanvasPosition.Y + infoFrame.AbsoluteSize.Y)
    wait()
    local user = game:HttpGet("https://users.roblox.com/v1/users/" .. ID)
    local json = HttpService:JSONDecode(user)
    local date = json["created"]:sub(1, 10)
    local splitDates = string.split(date, "-")
    info2.Text = string.gsub(info2.Text, "Loading...", splitDates[2] .. "/" .. splitDates[3] .. "/" .. splitDates[1])
end

-- Keybind to open command bar
IYMouse.KeyDown:Connect(function(Key)
    if (Key == prefix) then
        RunService.RenderStepped:Wait()
        Cmdbar:CaptureFocus()
        maximizeHolder()
    end
end)

-- Holder mouse enter/leave events
local lastMinimizeReq = 0
Holder.MouseEnter:Connect(function()
    lastMinimizeReq = 0
    maximizeHolder()
end)

Holder.MouseLeave:Connect(function()
    if not Cmdbar:IsFocused() then
        local reqTime = tick()
        lastMinimizeReq = reqTime
        wait(1)
        if lastMinimizeReq ~= reqTime then return end
        if not Cmdbar:IsFocused() then
            minimizeHolder()
        end
    end
end)

-- Function to update GUI colors based on the selected color and type
function updateColors(color, ctype)
    if ctype == shade1 then
        for i, v in pairs(shade1) do
            v.BackgroundColor3 = color
        end
        currentShade1 = color
    elseif ctype == shade2 then
        for i, v in pairs(shade2) do
            v.BackgroundColor3 = color
        end
        currentShade2 = color
    elseif ctype == shade3 then
        for i, v in pairs(shade3) do
            v.BackgroundColor3 = color
        end
        currentShade3 = color
    elseif ctype == text1 then
        for i, v in pairs(text1) do
            v.TextColor3 = color
            if v:IsA("TextBox") then
                v.PlaceholderColor3 = color
            end
        end
        currentText1 = color
    elseif ctype == text2 then
        for i, v in pairs(text2) do
            v.TextColor3 = color
        end
        currentText2 = color
    elseif ctype == scroll then
        for i, v in pairs(scroll) do
            v.ScrollBarImageColor3 = color
        end
        currentScroll = color
    end
end

-- Variable to track if the color picker is open
local colorpickerOpen = false

-- Event listener for the ColorsButton to open the color picker
ColorsButton.MouseButton1Click:Connect(function()
    -- Cache current colors in case of cancellation
    cache_currentShade1 = currentShade1
    cache_currentShade2 = currentShade2
    cache_currentShade3 = currentShade3
    cache_currentText1 = currentText1
    cache_currentText2 = currentText2
    cache_currentScroll = currentScroll

    if not colorpickerOpen then
        colorpickerOpen = true
        -- Load the color picker GUI
        picker = game:GetObjects("rbxassetid://4908465318")[1]
        picker.Name = randomString()
        picker.Parent = ScaledHolder

        -- Define the ColorPicker class
        local ColorPicker = {}
        ColorPicker.new = function()
            local newMt = setmetatable({}, {})

            -- Reference GUI elements
            local pickerGui = picker.ColorPicker
            local pickerTopBar = pickerGui.TopBar
            local pickerExit = pickerTopBar.Exit
            local pickerFrame = pickerGui.Content
            local colorSpace = pickerFrame.ColorSpaceFrame.ColorSpace
            local colorStrip = pickerFrame.ColorStrip
            local previewFrame = pickerFrame.Preview
            local basicColorsFrame = pickerFrame.BasicColors
            local customColorsFrame = pickerFrame.CustomColors
            local defaultButton = pickerFrame.Default
            local cancelButton = pickerFrame.Cancel
            local shade1Button = pickerFrame.Shade1
            local shade2Button = pickerFrame.Shade2
            local shade3Button = pickerFrame.Shade3
            local text1Button = pickerFrame.Text1
            local text2Button = pickerFrame.Text2
            local scrollButton = pickerFrame.Scroll

            local colorScope = colorSpace.Scope
            local colorArrow = pickerFrame.ArrowFrame.Arrow

            local hueInput = pickerFrame.Hue.Input
            local satInput = pickerFrame.Sat.Input
            local valInput = pickerFrame.Val.Input

            local redInput = pickerFrame.Red.Input
            local greenInput = pickerFrame.Green.Input
            local blueInput = pickerFrame.Blue.Input

            local mouse = IYMouse

            -- Initialize color values
            local hue, sat, val = 0, 0, 1
            local red, green, blue = 1, 1, 1
            local chosenColor = Color3.new(0, 0, 0)

            -- Define basic colors
            local basicColors = {
                Color3.new(0, 0, 0), Color3.new(0.66666668653488, 0, 0), Color3.new(0, 0.33333334326744, 0),
                Color3.new(0.66666668653488, 0.33333334326744, 0), Color3.new(0, 0.66666668653488, 0),
                Color3.new(0.66666668653488, 0.66666668653488, 0), Color3.new(0, 1, 0), Color3.new(0.66666668653488, 1, 0),
                Color3.new(0, 0, 0.49803924560547), Color3.new(0.66666668653488, 0, 0.49803924560547),
                Color3.new(0, 0.33333334326744, 0.49803924560547), Color3.new(0.66666668653488, 0.33333334326744, 0.49803924560547),
                Color3.new(0, 0.66666668653488, 0.49803924560547), Color3.new(0.66666668653488, 0.66666668653488, 0.49803924560547),
                Color3.new(0, 1, 0.49803924560547), Color3.new(0.66666668653488, 1, 0.49803924560547),
                Color3.new(0, 0, 1), Color3.new(0.66666668653488, 0, 1), Color3.new(0, 0.33333334326744, 1),
                Color3.new(0.66666668653488, 0.33333334326744, 1), Color3.new(0, 0.66666668653488, 1),
                Color3.new(0.66666668653488, 0.66666668653488, 1), Color3.new(0, 1, 1), Color3.new(0.66666668653488, 1, 1),
                Color3.new(0.33333334326744, 0, 0), Color3.new(1, 0, 0), Color3.new(0.33333334326744, 0.33333334326744, 0),
                Color3.new(1, 0.33333334326744, 0), Color3.new(0.33333334326744, 0.66666668653488, 0),
                Color3.new(1, 0.66666668653488, 0), Color3.new(0.33333334326744, 1, 0), Color3.new(1, 1, 0),
                Color3.new(0.33333334326744, 0, 0.49803924560547), Color3.new(1, 0, 0.49803924560547),
                Color3.new(0.33333334326744, 0.33333334326744, 0.49803924560547), Color3.new(1, 0.33333334326744, 0.49803924560547),
                Color3.new(0.33333334326744, 0.66666668653488, 0.49803924560547), Color3.new(1, 0.66666668653488, 0.49803924560547),
                Color3.new(0.33333334326744, 1, 0.49803924560547), Color3.new(1, 1, 0.49803924560547),
                Color3.new(0.33333334326744, 0, 1), Color3.new(1, 0, 1), Color3.new(0.33333334326744, 0.33333334326744, 1),
                Color3.new(1, 0.33333334326744, 1), Color3.new(0.33333334326744, 0.66666668653488, 1),
                Color3.new(1, 0.66666668653488, 1), Color3.new(0.33333334326744, 1, 1), Color3.new(1, 1, 1)
            }
            local customColors = {}

            -- Enable dragging for the color picker
            dragGUI(picker)

            -- Function to update the color preview and inputs
            local function updateColor(noupdate)
                local relativeX, relativeY, relativeStripY = 219 - hue * 219, 199 - sat * 199, 199 - val * 199
                local hsvColor = Color3.fromHSV(hue, sat, val)

                if noupdate == 2 or not noupdate then
                    hueInput.Text = tostring(math.ceil(359 * hue))
                    satInput.Text = tostring(math.ceil(255 * sat))
                    valInput.Text = tostring(math.floor(255 * val))
                end
                if noupdate == 1 or not noupdate then
                    redInput.Text = tostring(math.floor(255 * red))
                    greenInput.Text = tostring(math.floor(255 * green))
                    blueInput.Text = tostring(math.floor(255 * blue))
                end

                chosenColor = Color3.new(red, green, blue)

                colorScope.Position = UDim2.new(0, relativeX - 9, 0, relativeY - 9)
                colorStrip.ImageColor3 = Color3.fromHSV(hue, sat, 1)
                colorArrow.Position = UDim2.new(0, -2, 0, relativeStripY - 4)
                previewFrame.BackgroundColor3 = chosenColor

                newMt.Color = chosenColor
                if newMt.Changed then newMt:Changed(chosenColor) end
            end

            -- Function to handle color space input
            local function colorSpaceInput()
                local relativeX = mouse.X - colorSpace.AbsolutePosition.X
                local relativeY = mouse.Y - colorSpace.AbsolutePosition.Y

                if relativeX < 0 then relativeX = 0 elseif relativeX > 219 then relativeX = 219 end
                if relativeY < 0 then relativeY = 0 elseif relativeY > 199 then relativeY = 199 end

                hue = (219 - relativeX) / 219
                sat = (199 - relativeY) / 199

                local hsvColor = Color3.fromHSV(hue, sat, val)
                red, green, blue = hsvColor.r, hsvColor.g, hsvColor.b

                updateColor()
            end

            -- Function to handle color strip input
            local function colorStripInput()
                local relativeY = mouse.Y - colorStrip.AbsolutePosition.Y

                if relativeY < 0 then relativeY = 0 elseif relativeY > 199 then relativeY = 199 end

                val = (199 - relativeY) / 199

                local hsvColor = Color3.fromHSV(hue, sat, val)
                red, green, blue = hsvColor.r, hsvColor.g, hsvColor.b

                updateColor()
            end

            -- Function to hook up and down buttons for input fields
            local function hookButtons(frame, func)
                frame.ArrowFrame.Up.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement then
                        frame.ArrowFrame.Up.BackgroundTransparency = 0.5
                    elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                        local releaseEvent, runEvent

                        local startTime = tick()
                        local pressing = true
                        local startNum = tonumber(frame.Text)

                        if not startNum then return end

                        releaseEvent = UserInputService.InputEnded:Connect(function(input)
                            if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
                            releaseEvent:Disconnect()
                            pressing = false
                        end)

                        startNum = startNum + 1
                        func(startNum)
                        while pressing do
                            if tick() - startTime > 0.3 then
                                startNum = startNum + 1
                                func(startNum)
                            end
                            wait(0.1)
                        end
                    end
                end)

                frame.ArrowFrame.Up.InputEnded:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement then
                        frame.ArrowFrame.Up.BackgroundTransparency = 1
                    end
                end)

                frame.ArrowFrame.Down.InputBegan:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement then
                        frame.ArrowFrame.Down.BackgroundTransparency = 0.5
                    elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
                        local releaseEvent, runEvent

                        local startTime = tick()
                        local pressing = true
                        local startNum = tonumber(frame.Text)

                        if not startNum then return end

                        releaseEvent = UserInputService.InputEnded:Connect(function(input)
                            if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
                            releaseEvent:Disconnect()
                            pressing = false
                        end)

                        startNum = startNum - 1
                        func(startNum)
                        while pressing do
                            if tick() - startTime > 0.3 then
                                startNum = startNum - 1
                                func(startNum)
                            end
                            wait(0.1)
                        end
                    end
                end)

                frame.ArrowFrame.Down.InputEnded:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseMovement then
                        frame.ArrowFrame.Down.BackgroundTransparency = 1
                    end
                end)
            end

            -- Connect color space input events
            colorSpace.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    local releaseEvent, mouseEvent

                    releaseEvent = UserInputService.InputEnded:Connect(function(input)
                        if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
                        releaseEvent:Disconnect()
                        mouseEvent:Disconnect()
                    end)

                    mouseEvent = UserInputService.InputChanged:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseMovement then
                            colorSpaceInput()
                        end
                    end)

                    colorSpaceInput()
                end
            end)

            -- Connect color strip input events
            colorStrip.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    local releaseEvent, mouseEvent

                    releaseEvent = UserInputService.InputEnded:Connect(function(input)
                        if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
                        releaseEvent:Disconnect()
                        mouseEvent:Disconnect()
                    end)

                    mouseEvent = UserInputService.InputChanged:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseMovement then
                            colorStripInput()
                        end
                    end)

                    colorStripInput()
                end
            end)

            -- Function to update hue value
            local function updateHue(str)
                local num = tonumber(str)
                if num then
                    hue = math.clamp(math.floor(num), 0, 359) / 359
                    local hsvColor = Color3.fromHSV(hue, sat, val)
                    red, green, blue = hsvColor.r, hsvColor.g, hsvColor.b
                    hueInput.Text = tostring(hue * 359)
                    updateColor(1)
                end
            end
            hueInput.FocusLost:Connect(function() updateHue(hueInput.Text) end)
            hookButtons(hueInput, updateHue)

            -- Function to update saturation value
            local function updateSat(str)
                local num = tonumber(str)
                if num then
                    sat = math.clamp(math.floor(num), 0, 255) / 255
                    local hsvColor = Color3.fromHSV(hue, sat, val)
                    red, green, blue = hsvColor.r, hsvColor.g, hsvColor.b
                    satInput.Text = tostring(sat * 255)
                    updateColor(1)
                end
            end
            satInput.FocusLost:Connect(function() updateSat(satInput.Text) end)
            hookButtons(satInput, updateSat)

            -- Function to update value (brightness)
            local function updateVal(str)
                local num = tonumber(str)
                if num then
                    val = math.clamp(math.floor(num), 0, 255) / 255
                    local hsvColor = Color3.fromHSV(hue, sat, val)
                    red, green, blue = hsvColor.r, hsvColor.g, hsvColor.b
                    valInput.Text = tostring(val * 255)
                    updateColor(1)
                end
            end
            valInput.FocusLost:Connect(function() updateVal(valInput.Text) end)
            hookButtons(valInput, updateVal)

            -- Function to update red value
            local function updateRed(str)
                local num = tonumber(str)
                if num then
                    red = math.clamp(math.floor(num), 0, 255) / 255
                    local newColor = Color3.new(red, green, blue)
                    hue, sat, val = Color3.toHSV(newColor)
                    redInput.Text = tostring(red * 255)
                    updateColor(2)
                end
            end
            redInput.FocusLost:Connect(function() updateRed(redInput.Text) end)
            hookButtons(redInput, updateRed)

            -- Function to update green value
            local function updateGreen(str)
                local num = tonumber(str)
                if num then
                    green = math.clamp(math.floor(num), 0, 255) / 255
                    local newColor = Color3.new(red, green, blue)
                    hue, sat, val = Color3.toHSV(newColor)
                    greenInput.Text = tostring(green * 255)
                    updateColor(2)
                end
            end
            greenInput.FocusLost:Connect(function() updateGreen(greenInput.Text) end)
            hookButtons(greenInput, updateGreen)

            -- Function to update blue value
            local function updateBlue(str)
                local num = tonumber(str)
                if num then
                    blue = math.clamp(math.floor(num), 0, 255) / 255
                    local newColor = Color3.new(red, green, blue)
                    hue, sat, val = Color3.toHSV(newColor)
                    blueInput.Text = tostring(blue * 255)
                    updateColor(2)
                end
            end
            blueInput.FocusLost:Connect(function() updateBlue(blueInput.Text) end)
            hookButtons(blueInput, updateBlue)

            -- Create color choice buttons for basic colors
            local colorChoice = Instance.new("TextButton")
            colorChoice.Name = "Choice"
            colorChoice.Size = UDim2.new(0, 25, 0, 18)
            colorChoice.BorderColor3 = Color3.new(96 / 255, 96 / 255, 96 / 255)
            colorChoice.Text = ""
            colorChoice.AutoButtonColor = false
            colorChoice.ZIndex = 10

            local row = 0
            local column = 0
            for i, v in pairs(basicColors) do
                local newColor = colorChoice:Clone()
                newColor.BackgroundColor3 = v
                newColor.Position = UDim2.new(0, 1 + 30 * column, 0, 21 + 23 * row)

                newColor.MouseButton1Click:Connect(function()
                    red, green, blue = v.r, v.g, v.b
                    local newColor = Color3.new(red, green, blue)
                    hue, sat, val = Color3.toHSV(newColor)
                    updateColor()
                end)

                newColor.Parent = basicColorsFrame
                column = column + 1
                if column == 6 then row = row + 1 column = 0 end
            end

            -- Create color choice buttons for custom colors
            row = 0
            column = 0
            for i = 1, 12 do
                local color = customColors[i] or Color3.new(0, 0, 0)
                local newColor = colorChoice:Clone()
                newColor.BackgroundColor3 = color
                newColor.Position = UDim2.new(0, 1 + 30 * column, 0, 20 + 23 * row)

                newColor.MouseButton1Click:Connect(function()
                    local curColor = customColors[i] or Color3.new(0, 0, 0)
                    red, green, blue = curColor.r, curColor.g, curColor.b
                    hue, sat, val = Color3.toHSV(curColor)
                    updateColor()
                end)

                newColor.MouseButton2Click:Connect(function()
                    customColors[i] = chosenColor
                    newColor.BackgroundColor3 = chosenColor
                end)

                newColor.Parent = customColorsFrame
                column = column + 1
                if column == 6 then row = row + 1 column = 0 end
            end

            -- Connect buttons for shade, text, and scroll color updates
            shade1Button.MouseButton1Click:Connect(function() if newMt.Confirm then newMt:Confirm(chosenColor, shade1) end end)
            shade1Button.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then shade1Button.BackgroundTransparency = 0.4 end end)
            shade1Button.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then shade1Button.BackgroundTransparency = 0 end end)

            shade2Button.MouseButton1Click:Connect(function() if newMt.Confirm then newMt:Confirm(chosenColor, shade2) end end)
            shade2Button.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then shade2Button.BackgroundTransparency = 0.4 end end)
            shade2Button.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then shade2Button.BackgroundTransparency = 0 end end)

            shade3Button.MouseButton1Click:Connect(function() if newMt.Confirm then newMt:Confirm(chosenColor, shade3) end end)
            shade3Button.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then shade3Button.BackgroundTransparency = 0.4 end end)
            shade3Button.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then shade3Button.BackgroundTransparency = 0 end end)

            text1Button.MouseButton1Click:Connect(function() if newMt.Confirm then newMt:Confirm(chosenColor, text1) end end)
            text1Button.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then text1Button.BackgroundTransparency = 0.4 end end)
            text1Button.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then text1Button.BackgroundTransparency = 0 end end)

            text2Button.MouseButton1Click:Connect(function() if newMt.Confirm then newMt:Confirm(chosenColor, text2) end end)
            text2Button.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then text2Button.BackgroundTransparency = 0.4 end end)
            text2Button.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then text2Button.BackgroundTransparency = 0 end end)

            scrollButton.MouseButton1Click:Connect(function() if newMt.Confirm then newMt:Confirm(chosenColor, scroll) end end)
            scrollButton.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then scrollButton.BackgroundTransparency = 0.4 end end)
            scrollButton.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then scrollButton.BackgroundTransparency = 0 end end)

            -- Connect cancel, default, and exit buttons
            cancelButton.MouseButton1Click:Connect(function() if newMt.Cancel then newMt:Cancel() end end)
            cancelButton.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then cancelButton.BackgroundTransparency = 0.4 end end)
            cancelButton.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then cancelButton.BackgroundTransparency = 0 end end)

            defaultButton.MouseButton1Click:Connect(function() if newMt.Default then newMt:Default() end end)
            defaultButton.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then defaultButton.BackgroundTransparency = 0.4 end end)
            defaultButton.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then defaultButton.BackgroundTransparency = 0 end end)

            pickerExit.MouseButton1Click:Connect(function()
                picker:TweenPosition(UDim2.new(0.5, -219, 0, -500), "InOut", "Quart", 0.5, true, nil)
            end)

            -- Initialize color picker with default values
            updateColor()

            -- Define methods for the color picker
            newMt.SetColor = function(self, color)
                red, green, blue = color.r, color.g, color.b
                hue, sat, val = Color3.toHSV(color)
                updateColor()
            end

            return newMt
        end

        -- Show the color picker
        picker:TweenPosition(UDim2.new(0.5, -219, 0, 100), "InOut", "Quart", 0.5, true, nil)

        -- Create a new color picker instance
        local Npicker = ColorPicker.new()
        Npicker.Confirm = function(self, color, ctype)
            updateColors(color, ctype)
            wait()
            updatesaves()
        end
        Npicker.Cancel = function(self)
            updateColors(cache_currentShade1, shade1)
            updateColors(cache_currentShade2, shade2)
            updateColors(cache_currentShade3, shade3)
            updateColors(cache_currentText1, text1)
            updateColors(cache_currentText2, text2)
            updateColors(cache_currentScroll, scroll)
            wait()
            updatesaves()
        end
        Npicker.Default = function(self)
            updateColors(Color3.fromRGB(36, 36, 37), shade1)
            updateColors(Color3.fromRGB(46, 46, 47), shade2)
            updateColors(Color3.fromRGB(78, 78, 79), shade3)
            updateColors(Color3.new(1, 1, 1), text1)
            updateColors(Color3.new(0, 0, 0), text2)
            updateColors(Color3.fromRGB(78, 78, 79), scroll)
            wait()
            updatesaves()
        end
    else
        -- Toggle the color picker visibility
        picker:TweenPosition(UDim2.new(0.5, -219, 0, 100), "InOut", "Quart", 0.5, true, nil)
    end
end)

-- Event listener for the SettingsButton to toggle the settings menu
SettingsButton.MouseButton1Click:Connect(function()
    if SettingsOpen == false then
        SettingsOpen = true
        Settings:TweenPosition(UDim2.new(0, 0, 0, 45), "InOut", "Quart", 0.5, true, nil)
        CMDsF.Visible = false
    else
        SettingsOpen = false
        CMDsF.Visible = true
        Settings:TweenPosition(UDim2.new(0, 0, 0, 220), "InOut", "Quart", 0.5, true, nil)
    end
end)

-- Toggle StayOpen and BackgroundTransparency
On.MouseButton1Click:Connect(function()
    if not isHidden then
        StayOpen = not StayOpen
        On.BackgroundTransparency = StayOpen and 0 or 1
        updatesaves()
    end
end)

-- Clear scroll_2 children
Clear.MouseButton1Down:Connect(function()
    clearChildren(scroll_2)
    scroll_2.CanvasSize = UDim2.new(0, 0, 0, 10)
end)

-- Clear scroll_3 children
Clear_2.MouseButton1Down:Connect(function()
    clearChildren(scroll_3)
    scroll_3.CanvasSize = UDim2.new(0, 0, 0, 10)
end)

-- Toggle logsEnabled
Toggle.MouseButton1Down:Connect(function()
    logsEnabled = not logsEnabled
    Toggle.Text = logsEnabled and 'Enabled' or 'Disabled'
    updatesaves()
end)

-- Toggle jLogsEnabled
Toggle_2.MouseButton1Down:Connect(function()
    jLogsEnabled = not jLogsEnabled
    Toggle_2.Text = jLogsEnabled and 'Enabled' or 'Disabled'
    updatesaves()
end)

-- Toggle between chat and join logs
selectChat.MouseButton1Down:Connect(function()
    toggleLogs(chat, join, selectChat, selectJoin)
end)

selectJoin.MouseButton1Down:Connect(function()
    toggleLogs(join, chat, selectJoin, selectChat)
end)

-- Check if exploit supports file operations
if not writefileExploit() then
    notify("Saves", "Your exploit does not support read/write file. Your settings will not save.")
end

-- Save chat logs to file
SaveChatlogs.MouseButton1Down:Connect(function()
    if writefileExploit() and #scroll_2:GetChildren() > 0 then
        notify("Loading", 'Hold on a sec')
        local placeName = CleanFileName(MarketplaceService:GetProductInfo(PlaceId).Name)
        local writelogs = '-- Infinite Yield Chat logs for "'..placeName..'"\n'
        for _, child in pairs(scroll_2:GetChildren()) do
            writelogs = writelogs..'\n'..child.Text
        end
        saveLogsToFile(placeName, writelogs)
        notify('Chat Logs', 'Saved chat logs to the workspace folder within your exploit folder.')
    else
        notify('Chat Logs', 'Your exploit does not support write file. You cannot save chat logs.')
    end
end)

-- Handle player leaving
Players.PlayerRemoving:Connect(function(player)
    if ESPenabled or CHMSenabled or COREGUI:FindFirstChild(player.Name..'_LC') then
        for _, v in pairs(COREGUI:GetChildren()) do
            if v.Name == player.Name..'_ESP' or v.Name == player.Name..'_LC' or v.Name == player.Name..'_CHMS' then
                v:Destroy()
            end
        end
    end
    if viewing == player then
        workspace.CurrentCamera.CameraSubject = Players.LocalPlayer.Character
        viewing = nil
        if viewDied then
            viewDied:Disconnect()
            viewChanged:Disconnect()
        end
        notify('Spectate', 'View turned off (player left)')
    end
    eventEditor.FireEvent("OnLeave", player.Name)
end)

-- Clear children of a given UI element
function clearChildren(uiElement)
    for _, child in pairs(uiElement:GetChildren()) do
        child:Destroy()
    end
end

-- Toggle logs visibility and update shades
function toggleLogs(visibleLog, hiddenLog, selectedButton, deselectedButton)
    visibleLog.Visible = true
    hiddenLog.Visible = false
    updateShade(selectedButton, deselectedButton)
end

-- Update shade colors for selected and deselected buttons
function updateShade(selected, deselected)
    table.remove(shade3, table.find(shade3, selected))
    table.remove(shade2, table.find(shade2, deselected))
    table.insert(shade2, selected)
    table.insert(shade3, deselected)
    deselected.BackgroundColor3 = currentShade3
    selected.BackgroundColor3 = currentShade2
end

-- Clean file name for saving logs
function CleanFileName(name)
    return tostring(name):gsub("[*\\?:<>|]+", ""):sub(1, 175)
end

-- Save logs to file with unique naming
function saveLogsToFile(placeName, writelogs)
    local fileext = 0
    local function nameFile()
        local file
        pcall(function() file = readfile(placeName..' Chat Logs ('..fileext..').txt') end)
        if file then
            fileext = fileext + 1
            nameFile()
        else
            writefileCooldown(placeName..' Chat Logs ('..fileext..').txt', writelogs)
        end
    end
    nameFile()
end

-- Initialize camera movement handling
function updateCamera(child, parent)
    if parent ~= workspace then
        CamMoved:Disconnect()
        CameraChanged:Disconnect()
        repeat wait() until workspace.CurrentCamera
        CameraChanged = workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(UpdateToViewport)
        CamMoved = workspace.CurrentCamera.AncestryChanged:Connect(updateCamera)
    end
end

CamMoved = workspace.CurrentCamera.AncestryChanged:Connect(updateCamera)

CMDs = {

    -- General Commands
    {NAME = 'discord / support / help', DESC = 'Invite to the Infinite Yield support server.'},
    {NAME = 'guiscale [number]', DESC = 'Changes the size of the GUI. [number] accepts both decimals and whole numbers. Min is 0.4 and Max is 2'},
    {NAME = 'console', DESC = 'Loads Roblox console'},
    {NAME = 'oldconsole', DESC = 'Loads old Roblox console'},
    {NAME = 'explorer / dex', DESC = 'Opens DEX by Moon'},
    {NAME = 'olddex / odex', DESC = 'Opens Old DEX by Moon'},
    {NAME = 'remotespy / rspy', DESC = 'Opens Simple Spy V3'},
    {NAME = 'audiologger / alogger', DESC = 'Opens Edges audio logger'},
    {NAME = 'serverinfo / info', DESC = 'Gives you info about the server'},
    {NAME = 'jobid', DESC = 'Copies the games JobId to your clipboard'},
    {NAME = 'notifyjobid', DESC = 'Notifies you the games JobId'},
    {NAME = 'rejoin / rj', DESC = 'Makes you rejoin the game'},
    {NAME = 'autorejoin / autorj', DESC = 'Automatically rejoins the server if you get kicked/disconnected'},
    {NAME = 'serverhop / shop', DESC = 'Teleports you to a different server'},
    {NAME = 'gameteleport / gametp [place ID]', DESC = 'Joins a game by ID'},
    {NAME = 'antiidle / antiafk', DESC = 'Prevents the game from kicking you for being idle/afk'},
    {NAME = 'datalimit [num]', DESC = 'Set outgoing KBPS limit'},
    {NAME = 'replicationlag / backtrack [num]', DESC = 'Set IncomingReplicationLag'},
    {NAME = 'creatorid / creator', DESC = 'Notifies you the creators ID'},
    {NAME = 'copycreatorid / copycreator', DESC = 'Copies the creators ID to your clipboard'},
    {NAME = 'setcreatorid / setcreator', DESC = 'Sets your userid to the creators ID'},
    {NAME = 'noprompts', DESC = 'Prevents the game from showing you purchase/premium prompts'},
    {NAME = 'showprompts', DESC = 'Allows the game to show purchase/premium prompts again'},
    {NAME = 'enable [inventory/playerlist/chat/reset/emotes/all]', DESC = 'Toggles visibility of coregui items'},
    {NAME = 'disable [inventory/playerlist/chat/reset/emotes/all]', DESC = 'Toggles visibility of coregui items'},
    {NAME = 'showguis', DESC = 'Shows any invisible GUIs'},
    {NAME = 'unshowguis', DESC = 'Undoes showguis'},
    {NAME = 'hideguis', DESC = 'Hides any GUIs in PlayerGui'},
    {NAME = 'unhideguis', DESC = 'Undoes hideguis'},
    {NAME = 'guidelete', DESC = 'Enables backspace to delete GUI'},
    {NAME = 'unguidelete / noguidelete', DESC = 'Disables guidelete'},
    {NAME = 'hideiy', DESC = 'Hides the main IY GUI'},
    {NAME = 'showiy / unhideiy', DESC = 'Shows IY again'},
    {NAME = 'keepiy', DESC = 'Auto execute IY when you teleport through servers'},
    {NAME = 'unkeepiy', DESC = 'Disable keepiy'},
    {NAME = 'togglekeepiy', DESC = 'Toggle keepiy'},
    {NAME = 'savegame / saveplace', DESC = 'Uses saveinstance to save the game'},
    {NAME = 'clearerror', DESC = 'Clears the annoying box and blur when a game kicks you'},
    {NAME = 'clientantikick / antikick (CLIENT)', DESC = 'Prevents localscripts from kicking you'},
    {NAME = 'clientantiteleport / antiteleport (CLIENT)', DESC = 'Prevents localscripts from teleporting you'},
    {NAME = 'allowrejoin / allowrj [true/false] (CLIENT)', DESC = 'Changes if antiteleport allows you to rejoin or not'},
    {NAME = 'cancelteleport / canceltp', DESC = 'Cancels teleports in progress'},
    {NAME = 'volume / vol [0-10]', DESC = 'Adjusts your game volume on a scale of 0 to 10'},
    {NAME = 'antilag / boostfps / lowgraphics', DESC = 'Lowers game quality to boost FPS'},
    {NAME = 'record / rec', DESC = 'Starts Roblox recorder'},
    {NAME = 'screenshot / scrnshot', DESC = 'Takes a screenshot'},
    {NAME = 'togglefullscreen / togglefs', DESC = 'Toggles fullscreen'},
    {NAME = 'notify [text]', DESC = 'Sends you a notification with the provided text'},
    {NAME = 'lastcommand / lastcmd', DESC = 'Executes the previous command used'},
    {NAME = 'exit', DESC = 'Kills Roblox process'},

    -- Movement Commands
    {NAME = 'noclip', DESC = 'Go through objects'},
    {NAME = 'unnoclip / clip', DESC = 'Disables noclip'},
    {NAME = 'fly [speed]', DESC = 'Makes you fly'},
    {NAME = 'unfly', DESC = 'Disables fly'},
    {NAME = 'flyspeed [num]', DESC = 'Set fly speed (default is 20)'},
    {NAME = 'vehiclefly / vfly [speed]', DESC = 'Makes you fly in a vehicle'},
    {NAME = 'unvehiclefly / unvfly', DESC = 'Disables vehicle fly'},
    {NAME = 'vehicleflyspeed  / vflyspeed [num]', DESC = 'Set vehicle fly speed'},
    {NAME = 'cframefly / cfly [speed]', DESC = 'Makes you fly, bypassing some anti cheats (works on mobile)'},
    {NAME = 'uncframefly / uncfly', DESC = 'Disables cfly'},
    {NAME = 'cframeflyspeed  / cflyspeed [num]', DESC = 'Sets cfly speed'},
    {NAME = 'qefly [true / false]', DESC = 'Enables or disables the Q and E hotkeys for fly'},
    {NAME = 'vehiclenoclip / vnoclip', DESC = 'Turns off vehicle collision'},
    {NAME = 'vehicleclip / vclip / unvnoclip', DESC = 'Enables vehicle collision'},
    {NAME = 'float / platform', DESC = 'Spawns a platform beneath you causing you to float'},
    {NAME = 'unfloat / noplatform', DESC = 'Removes the platform'},
    {NAME = 'swim', DESC = 'Allows you to swim in the air'},
    {NAME = 'unswim / noswim', DESC = 'Stops you from swimming everywhere'},

    -- Waypoint Commands
    {NAME = 'setwaypoint / swp [name]', DESC = 'Sets a waypoint at your position'},
    {NAME = 'waypointpos / wpp [name] [X Y Z]', DESC = 'Sets a waypoint with specified coordinates'},
    {NAME = 'waypoints', DESC = 'Shows a list of currently active waypoints'},
    {NAME = 'showwaypoints / showwp', DESC = 'Shows all currently set waypoints'},
    {NAME = 'hidewaypoints / hidewp', DESC = 'Hides shown waypoints'},
    {NAME = 'waypoint / wp [name]', DESC = 'Teleports player to a waypoint'},
    {NAME = 'tweenwaypoint / twp [name]', DESC = 'Tweens player to a waypoint'},
    {NAME = 'walktowaypoint / wtwp [name]', DESC = 'Walks player to a waypoint'},
    {NAME = 'deletewaypoint / dwp [name]', DESC = 'Deletes a waypoint'},
    {NAME = 'clearwaypoints / cwp', DESC = 'Clears all waypoints'},
    {NAME = 'cleargamewaypoints / cgamewp', DESC = 'Clears all waypoints for the game you are in'},

    -- Teleportation Commands
    {NAME = 'goto [player]', DESC = 'Go to a player'},
    {NAME = 'tweengoto / tgoto [player]', DESC = 'Tween to a player (bypasses some anti cheats)'},
    {NAME = 'tweenspeed / tspeed [num]', DESC = 'Sets how fast all tween commands go (default is 1)'},
    {NAME = 'vehiclegoto / vgoto [player]', DESC = 'Go to a player while in a vehicle'},
    {NAME = 'loopgoto [player] [distance] [delay]', DESC = 'Loop teleport to a player'},
    {NAME = 'unloopgoto', DESC = 'Stops teleporting you to a player'},
    {NAME = 'pulsetp / ptp [player] [seconds]', DESC = 'Teleports you to a player for a specified amount of time'},
    {NAME = 'clientbring / cbring [player] (CLIENT)', DESC = 'Bring a player'},
    {NAME = 'loopbring [player] [distance] [delay] (CLIENT)', DESC = 'Loop brings a player to you (useful for killing)'},
    {NAME = 'unloopbring [player]', DESC = 'Undoes loopbring'},
    {NAME = 'freeze / fr [player] (CLIENT)', DESC = 'Freezes a player'},
    {NAME = 'freezeanims', DESC = 'Freezes your animations / pauses your animations - Does not work on default animations'},
    {NAME = 'unfreezeanims', DESC = 'Unfreezes your animations / plays your animations'},
    {NAME = 'thaw / unfr [player] (CLIENT)', DESC = 'Unfreezes a player'},
    {NAME = 'tpposition / tppos [X Y Z]', DESC = 'Teleports you to certain coordinates'},
    {NAME = 'tweentpposition / ttppos [X Y Z]', DESC = 'Tween to coordinates (bypasses some anti cheats)'},
    {NAME = 'offset [X Y Z]', DESC = 'Offsets you by certain coordinates'},
    {NAME = 'tweenoffset / toffset [X Y Z]', DESC = 'Tween offset (bypasses some anti cheats)'},
    {NAME = 'notifyposition / notifypos [player]', DESC = 'Notifies you the coordinates of a character'},
    {NAME = 'copyposition / copypos [player]', DESC = 'Copies the coordinates of a character to your clipboard'},
    {NAME = 'walktoposition / walktopos [X Y Z]', DESC = 'Makes you walk to a coordinate'},
    {NAME = 'spawnpoint / spawn [delay]', DESC = 'Sets a position where you will spawn'},
    {NAME = 'nospawnpoint / nospawn', DESC = 'Removes your custom spawn point'},
    {NAME = 'flashback / diedtp', DESC = 'Teleports you to where you last died'},
    {NAME = 'walltp', DESC = 'Teleports you above/over any wall you run into'},
    {NAME = 'nowalltp / unwalltp', DESC = 'Disables walltp'},
    {NAME = 'teleporttool / tptool', DESC = 'Gives you a teleport tool'},

    --Logging and Chat Commands
    {NAME = 'logs', DESC = 'Opens the logs GUI'},
    {NAME = 'chatlogs / clogs', DESC = 'Log what people say or whisper'},
    {NAME = 'joinlogs / jlogs', DESC = 'Log when people join'},
    {NAME = 'chatlogswebhook / logswebhook [url]', DESC = 'Set a Discord webhook for chatlogs to go to (provide no URL to disable this)'},
    {NAME = 'antichatlogs / antichatlogger', DESC = 'Prevents Roblox from banning you for your silly chat messages (game needs the legacy chat)'},
    {NAME = 'chat / say [text]', DESC = 'Makes you chat a string (possible mute bypass)'},
    {NAME = 'spam [text]', DESC = 'Makes you spam the chat'},
    {NAME = 'unspam', DESC = 'Turns off spam'},
    {NAME = 'whisper / pm [player] [text]', DESC = 'Makes you whisper a string to someone (possible mute bypass)'},
    {NAME = 'pmspam [player] [text]', DESC = 'Makes you spam a players whispers'},
    {NAME = 'unpmspam [player]', DESC = 'Turns off pm spam'},
    {NAME = 'spamspeed [num]', DESC = 'How quickly you spam (default is 1)'},
    {NAME = 'bubblechat (CLIENT)', DESC = 'Enables bubble chat for your client'},
    {NAME = 'unbubblechat / nobubblechat', DESC = 'Disables the bubblechat command'},

    -- ESP and Visual Commands
    {NAME = 'esp', DESC = 'View all players and their status'},
    {NAME = 'noesp / unesp', DESC = 'Removes esp'},
    {NAME = 'esptransparency [number]', DESC = 'Changes the transparency of esp related commands'},
    {NAME = 'partesp [part name]', DESC = 'Highlights a part'},
    {NAME = 'unpartesp / nopartesp [part name]', DESC = 'Removes partesp'},
    {NAME = 'chams', DESC = 'ESP but without text in the way'},
    {NAME = 'nochams / unchams', DESC = 'Removes chams'},
    {NAME = 'locate [player]', DESC = 'View a single player and their status'},
    {NAME = 'unlocate / nolocate [player]', DESC = 'Removes locate'},
    {NAME = 'xray', DESC = 'Makes all parts in workspace transparent'},
    {NAME = 'unxray / noxray', DESC = 'Restores transparency'},
    {NAME = 'loopxray', DESC = 'Makes all parts in workspace transparent but looped'},
    {NAME = 'unloopunxray', DESC = 'Unloops xray'},

    -- Camera and Spectate Commands
    {NAME = 'spectate / view [player]', DESC = 'View a player'},
    {NAME = 'viewpart / viewp [part name]', DESC = 'View a part'},
    {NAME = 'unspectate / unview', DESC = 'Stops viewing player'},
    {NAME = 'freecam / fc', DESC = 'Allows you to freely move camera around the game'},
    {NAME = 'freecampos / fcpos [X Y Z]', DESC = 'Moves / opens freecam in a certain position'},
    {NAME = 'freecamwaypoint / fcwp [name]', DESC = 'Moves / opens freecam to a waypoint'},
    {NAME = 'freecamgoto / fcgoto / fctp [player]', DESC = 'Moves / opens freecam to a player'},
    {NAME = 'unfreecam / unfc', DESC = 'Disables freecam'},
    {NAME = 'freecamspeed / fcspeed [num]', DESC = 'Adjusts freecam speed (default is 1)'},
    {NAME = 'notifyfreecamposition / notifyfcpos', DESC = 'Notifies you your freecam coordinates'},
    {NAME = 'copyfreecamposition / copyfcpos', DESC = 'Copies your freecam coordinates to your clipboard'},
    {NAME = 'gotocamera / gotocam', DESC = 'Teleports you to the location of your camera'},
    {NAME = 'tweengotocam / tgotocam', DESC = 'Tweens you to the location of your camera'},
    {NAME = 'firstp', DESC = 'Forces camera to go into first person'},
    {NAME = 'thirdp', DESC = 'Allows camera to go into third person'},
    {NAME = 'noclipcam / nccam', DESC = 'Allows camera to go through objects like walls'},
    {NAME = 'maxzoom [num]', DESC = 'Maximum camera zoom'},
    {NAME = 'minzoom [num]', DESC = 'Minimum camera zoom'},
    {NAME = 'camdistance [num]', DESC = 'Changes camera distance from your player'},
    {NAME = 'fov [num]', DESC = 'Adjusts field of view (default is 70)'},
    {NAME = 'fixcam / restorecam', DESC = 'Fixes camera'},
    {NAME = 'enableshiftlock / enablesl', DESC = 'Enables the shift lock option'},
    {NAME = 'lookat [player]', DESC = 'Moves your camera view to a player'},

    -- Building and Part Commands
    {NAME = 'btools (CLIENT)', DESC = 'Gives you building tools (DOES NOT REPLICATE)'},
    {NAME = 'f3x (CLIENT)', DESC = 'Gives you F3X building tools (DOES NOT REPLICATE)'},
    {NAME = 'partname / partpath', DESC = 'Allows you to click a part to see its path & name'},
    {NAME = 'delete [instance name] (CLIENT)', DESC = 'Removes any part with a certain name from the workspace (DOES NOT REPLICATE)'},
    {NAME = 'deleteclass / dc [class name] (CLIENT)', DESC = 'Removes any part with a certain classname from the workspace (DOES NOT REPLICATE)'},
    {NAME = 'lockworkspace / lockws', DESC = 'Locks the whole workspace'},
    {NAME = 'unlockworkspace / unlockws', DESC = 'Unlocks the whole workspace'},
    {NAME = 'invisibleparts / invisparts (CLIENT)', DESC = 'Shows invisible parts'},
    {NAME = 'uninvisibleparts / uninvisparts (CLIENT)', DESC = 'Makes parts affected by invisparts return to normal'},
    {NAME = 'deleteinvisparts / dip (CLIENT)', DESC = 'Deletes invisible parts'},
    {NAME = 'gotopart [part name]', DESC = 'Moves your character to a part or multiple parts'},
    {NAME = 'tweengotopart / tgotopart [part name]', DESC = 'Tweens your character to a part or multiple parts'},
    {NAME = 'gotopartclass / gpc [class name]', DESC = 'Moves your character to a part or multiple parts based on classname'},
    {NAME = 'tweengotopartclass / tgpc [class name]', DESC = 'Tweens your character to a part or multiple parts based on classname'},
    {NAME = 'gotomodel [part name]', DESC = 'Moves your character to a model or multiple models'},
    {NAME = 'tweengotomodel / tgotomodel [part name]', DESC = 'Tweens your character to a model or multiple models'},
    {NAME = 'gotopartdelay / gotomodeldelay [num]', DESC = 'Adjusts how quickly you teleport to each part (default is 0.1)'},
    {NAME = 'bringpart [part name] (CLIENT)', DESC = 'Moves a part or multiple parts to your character'},
    {NAME = 'bringpartclass / bpc [class name] (CLIENT)', DESC = 'Moves a part or multiple parts to your character based on classname'},
    {NAME = 'noclickdetectorlimits / nocdlimits', DESC = 'Sets all click detectors MaxActivationDistance to math.huge'},
    {NAME = 'fireclickdetectors / firecd [name]', DESC = 'Uses all click detectors in a game or uses the optional name'},
    {NAME = 'firetouchinterests / touchinterests [name]', DESC = 'Uses all touchinterests in a game or uses the optional name'},
    {NAME = 'noproximitypromptlimits / nopplimits', DESC = 'Sets all proximity prompts MaxActivationDistance to math.huge'},
    {NAME = 'fireproximityprompts / firepp [name]', DESC = 'Uses all proximity prompts in a game or uses the optional name'},
    {NAME = 'instantproximityprompts / instantpp', DESC = 'Disable the cooldown for proximity prompts'},
    {NAME = 'uninstantproximityprompts / uninstantpp', DESC = 'Undo the cooldown removal'},
    {NAME = 'tpunanchored / tpua [player]', DESC = 'Teleports unanchored parts to a player'},
    {NAME = 'animsunanchored / freezeua', DESC = 'Freezes unanchored parts'},
    {NAME = 'thawunanchored / thawua / unfreezeua', DESC = 'Thaws unanchored parts'},
    {NAME = 'removeterrain / rterrain / noterrain', DESC = 'Removes all terrain'},
    {NAME = 'clearnilinstances / nonilinstances / cni', DESC = 'Removes nil instances'},
    {NAME = 'destroyheight / dh [num]', DESC = 'Sets FallenPartsDestroyHeight'},
    {NAME = 'fakeout', DESC = 'Tp to the void and then back (useful to kill people attached to you)'},
    {NAME = 'antivoid', DESC = 'Prevents you from falling into the void by launching you upwards'},
    {NAME = 'unantivoid / noantivoid', DESC = 'Disables antivoid'},

    -- Lighting and Visual Effects
    {NAME = 'fullbright / fb (CLIENT)', DESC = 'Makes the map brighter / more visible'},
    {NAME = 'loopfullbright / loopfb (CLIENT)', DESC = 'Makes the map brighter / more visible but looped'},
    {NAME = 'unloopfullbright / unloopfb', DESC = 'Unloops fullbright'},
    {NAME = 'ambient [num] [num] [num] (CLIENT)', DESC = 'Changes ambient'},
    {NAME = 'day (CLIENT)', DESC = 'Changes the time to day for the client'},
    {NAME = 'night (CLIENT)', DESC = 'Changes the time to night for the client'},
    {NAME = 'nofog (CLIENT)', DESC = 'Removes fog'},
    {NAME = 'brightness [num] (CLIENT)', DESC = 'Changes the brightness lighting property'},
    {NAME = 'globalshadows / gshadows (CLIENT)', DESC = 'Enables global shadows'},
    {NAME = 'noglobalshadows / nogshadows (CLIENT)', DESC = 'Disables global shadows'},
    {NAME = 'restorelighting / rlighting', DESC = 'Restores Lighting properties'},
    {NAME = 'light [radius] [brightness] (CLIENT)', DESC = 'Gives your player dynamic light'},
    {NAME = 'nolight / unlight', DESC = 'Removes dynamic light from your player'},

    -- Player Interaction Commands
    {NAME = 'inspect / examine [player]', DESC = 'Opens InspectMenu for a certain player'},
    {NAME = 'age [player]', DESC = 'Tells you the age of a player'},
    {NAME = 'chatage [player]', DESC = 'Chats the age of a player'},
    {NAME = 'joindate / jd [player]', DESC = 'Tells you the date the player joined Roblox'},
    {NAME = 'chatjoindate / cjd [player]', DESC = 'Chats the date the player joined Roblox'},
    {NAME = 'copyname / copyuser [player]', DESC = 'Copies a players full username to your clipboard'},
    {NAME = 'userid / id [player]', DESC = 'Notifies a players user ID'},
    {NAME = 'copyuserid / copyid [player]', DESC = 'Copies a players user ID to your clipboard'},
    {NAME = 'appearanceid / aid [player]', DESC = 'Notifies a players appearance ID'},
    {NAME = 'copyappearanceid / caid [player]', DESC = 'Copies a players appearance ID to your clipboard'},
    {NAME = 'bang [player] [speed]', DESC = 'owo'},
    {NAME = 'unbang', DESC = 'uwu'},
    {NAME = 'carpet [player]', DESC = 'Be someones carpet'},
    {NAME = 'uncarpet', DESC = 'Undoes carpet'},
    {NAME = 'friend [player]', DESC = 'Sends a friend request to certain players'},
    {NAME = 'unfriend [player]', DESC = 'Unfriends certain players'},
    {NAME = 'headsit [player]', DESC = 'Sit on a players head'},
    {NAME = 'walkto / follow [player]', DESC = 'Follow a player'},
    {NAME = 'pathfindwalkto / pathfindfollow [player]', DESC = 'Follow a player using pathfinding'},
    {NAME = 'pathfindwalktowaypoint / pathfindwalktowp [waypoint]', DESC = 'Walk to a waypoint using pathfinding'},
    {NAME = 'unwalkto / unfollow', DESC = 'Stops following a player'},
    {NAME = 'orbit [player] [speed] [distance]', DESC = 'Makes your character orbit around a player with an optional speed and an optional distance'},
    {NAME = 'unorbit', DESC = 'Disables orbit'},
    {NAME = 'stareat / stare [player]', DESC = 'Stare / look at a player'},
    {NAME = 'unstareat / unstare [player]', DESC = 'Disables stareat'},
    {NAME = 'rolewatch [group id] [role name]', DESC = 'Notify if someone from a watched group joins the server'},
    {NAME = 'rolewatchstop / unrolewatch', DESC = 'Disable Rolewatch'},
    {NAME = 'rolewatchleave', DESC = 'Toggle if you should leave the game if someone from a watched group joins the server'},
    {NAME = 'staffwatch', DESC = 'Notify if a staff member of the game joins the server'},
    {NAME = 'unstaffwatch', DESC = 'Disable Staffwatch'},
    {NAME = 'attach [player] (TOOL)', DESC = 'Attaches you to a player (YOU NEED A TOOL)'},
    {NAME = 'kill [player] (TOOL)', DESC = 'Kills a player (YOU NEED A TOOL)'},
    {NAME = 'fastkill [player] (TOOL)', DESC = 'Kills a player (less reliable) (YOU NEED A TOOL)'},
    {NAME = 'handlekill / hkill [player] (TOOL)', DESC = 'Kills a player using tool damage (YOU NEED A TOOL)'},
    {NAME = 'bring [player] (TOOL)', DESC = 'Brings a player (YOU NEED A TOOL)'},
    {NAME = 'fastbring [player] (TOOL)', DESC = 'Brings a player (less reliable) (YOU NEED A TOOL)'},
    {NAME = 'teleport / tp [player] [player] (TOOL)', DESC = 'Teleports a player to another player (YOU NEED A TOOL)'},
    {NAME = 'fastteleport / fasttp [player] [player] (TOOL)', DESC = 'Teleports a player to another player (less reliable) (YOU NEED A TOOL)'},
    {NAME = 'fling', DESC = 'Flings anyone you touch'},
    {NAME = 'unfling', DESC = 'Disables the fling command'},
    {NAME = 'flyfling [speed]', DESC = 'Basically the invisfling command but not invisible'},
    {NAME = 'unflyfling', DESC = 'Disables the flyfling command'},
    {NAME = 'walkfling', DESC = 'Basically fling but no spinning'},
    {NAME = 'unwalkfling / nowalkfling', DESC = 'Disables walkfling'},
    {NAME = 'invisfling', DESC = 'Enables invisible fling'},
    {NAME = 'antifling', DESC = 'Disables player collisions to prevent you from being flung'},
    {NAME = 'unantifling', DESC = 'Disables antifling'},
    {NAME = 'loopoof', DESC = 'Loops everyones character sounds (everyone can hear)'},
    {NAME = 'unloopoof', DESC = 'Stops the oof chaos'},
    {NAME = 'muteboombox [player]', DESC = 'Mutes someones boombox'},
    {NAME = 'unmuteboombox [player]', DESC = 'Unmutes someones boombox'},
    {NAME = 'hitbox [player] [size] [transparency]', DESC = 'Expands the hitbox for players HumanoidRootPart (default is 1)'},
    {NAME = 'headsize [player] [size]', DESC = 'Expands the head size for players Head (default is 1)'},

    -- Character and Animation Commands
    {NAME = 'reset', DESC = 'Resets your character normally'},
    {NAME = 'respawn', DESC = 'Respawns you'},
    {NAME = 'refresh / re', DESC = 'Respawns and brings you back to the same position'},
    {NAME = 'god', DESC = 'Makes your character difficult to kill in most games'},
    {NAME = 'invisible / invis', DESC = 'Makes you invisible to other players'},
    {NAME = 'visible / vis', DESC = 'Makes you visible to other players'},
    {NAME = 'toolinvisible / toolinvis / tinvis', DESC = 'Makes you invisible to other players and able to use tools'},
    {NAME = 'speed / ws / walkspeed [num]', DESC = 'Change your walkspeed'},
    {NAME = 'spoofspeed / spoofws [num]', DESC = 'Spoofs your WalkSpeed on the Client'},
    {NAME = 'loopspeed / loopws [num]', DESC = 'Loops your walkspeed'},
    {NAME = 'unloopspeed / unloopws', DESC = 'Turns off loopspeed'},
    {NAME = 'hipheight / hheight [num]', DESC = 'Adjusts hip height'},
    {NAME = 'jumppower / jpower / jp [num]', DESC = 'Change a players jump height'},
    {NAME = 'spoofjumppower / spoofjp [num]', DESC = 'Spoofs your JumpPower on the Client'},
    {NAME = 'loopjumppower / loopjp [num]', DESC = 'Loops your jump height'},
    {NAME = 'unloopjumppower / unloopjp', DESC = 'Turns off loopjumppower'},
    {NAME = 'maxslopeangle / msa [num]', DESC = 'Adjusts MaxSlopeAngle'},
    {NAME = 'gravity / grav [num] (CLIENT)', DESC = 'Change your gravity'},
    {NAME = 'sit', DESC = 'Makes your character sit'},
    {NAME = 'lay / laydown', DESC = 'Makes your character lay down'},
    {NAME = 'sitwalk', DESC = 'Makes your character sit while still being able to walk'},
    {NAME = 'nosit', DESC = 'Prevents your character from sitting'},
    {NAME = 'unnosit', DESC = 'Disables nosit'},
    {NAME = 'jump', DESC = 'Makes your character jump'},
    {NAME = 'infinitejump / infjump', DESC = 'Allows you to jump before hitting the ground'},
    {NAME = 'uninfinitejump / uninfjump', DESC = 'Disables infjump'},
    {NAME = 'flyjump', DESC = 'Allows you to hold space to fly up'},
    {NAME = 'unflyjump', DESC = 'Disables flyjump'},
    {NAME = 'autojump / ajump', DESC = 'Automatically jumps when you run into an object'},
    {NAME = 'unautojump / unajump', DESC = 'Disables autojump'},
    {NAME = 'edgejump / ejump', DESC = 'Automatically jumps when you get to the edge of an object'},
    {NAME = 'unedgejump / unejump', DESC = 'Disables edgejump'},
    {NAME = 'platformstand / stun', DESC = 'Enables PlatformStand'},
    {NAME = 'unplatformstand / unstun', DESC = 'Disables PlatformStand'},
    {NAME = 'norotate / noautorotate', DESC = 'Disables AutoRotate'},
    {NAME = 'unnorotate / autorotate', DESC = 'Enables AutoRotate'},
    {NAME = 'enablestate [StateType]', DESC = 'Enables a humanoid state type'},
    {NAME = 'disablestate [StateType]', DESC = 'Disables a humanoid state type'},
    {NAME = 'team [team name] (CLIENT)', DESC = 'Changes your team. Sometimes fools localscripts.'},
    {NAME = 'nobillboardgui / nobgui / noname', DESC = 'Removes billboard and surface guis from your players (i.e. name guis at cafes)'},
    {NAME = 'loopnobgui / loopnoname', DESC = 'Loop removes billboard and surface guis from your players (i.e. name guis at cafes)'},
    {NAME = 'unloopnobgui / unloopnoname', DESC = 'Disables loopnobgui'},
    {NAME = 'noarms', DESC = 'Removes your arms'},
    {NAME = 'nolegs', DESC = 'Removes your legs'},
    {NAME = 'nolimbs', DESC = 'Removes your limbs'},
    {NAME = 'naked (CLIENT)', DESC = 'Removes your clothing'},
    {NAME = 'noface / removeface', DESC = 'Removes your face'},
    {NAME = 'blockhead', DESC = 'Turns your head into a block'},
    {NAME = 'blockhats', DESC = 'Turns your hats into blocks'},
    {NAME = 'blocktool', DESC = 'Turns the currently selected tool into a block'},
    {NAME = 'creeper', DESC = 'Makes you look like a creeper'},
    {NAME = 'drophats', DESC = 'Drops your hats'},
    {NAME = 'nohats / deletehats / rhats', DESC = 'Deletes your hats'},
    {NAME = 'hatspin / spinhats', DESC = 'Spins your characters accessories'},
    {NAME = 'unhatspin / unspinhats', DESC = 'Undoes spinhats'},
    {NAME = 'clearhats / cleanhats', DESC = 'Clears hats in the workspace'},
    {NAME = 'chardelete / cd [instance name]', DESC = 'Removes any part with a certain name from your character'},
    {NAME = 'chardeleteclass / cdc [class name]', DESC = 'Removes any part with a certain classname from your character'},
    {NAME = 'deletevelocity / dv / removeforces', DESC = 'Removes any velocity / force instances in your character'},
    {NAME = 'weaken [num]', DESC = 'Makes your character less dense'},
    {NAME = 'unweaken', DESC = 'Sets your characters CustomPhysicalProperties to default'},
    {NAME = 'strengthen [num]', DESC = 'Makes your character more dense (CustomPhysicalProperties)'},
    {NAME = 'unstrengthen', DESC = 'Sets your characters CustomPhysicalProperties to default'},
    {NAME = 'breakvelocity', DESC = 'Sets your characters velocity to 0'},
    {NAME = 'spin [speed]', DESC = 'Spins your character'},
    {NAME = 'unspin', DESC = 'Disables spin'},
    {NAME = 'split', DESC = 'Splits your character in half'},
    {NAME = 'nilchar', DESC = 'Sets your characters parent to nil'},
    {NAME = 'unnilchar / nonilchar', DESC = 'Sets your characters parent to workspace'},
    {NAME = 'noroot / removeroot / rroot', DESC = 'Removes your characters HumanoidRootPart'},
    {NAME = 'replaceroot', DESC = 'Replaces your characters HumanoidRootPart'},
    {NAME = 'clearcharappearance / clearchar / clrchar', DESC = 'Removes all accessory, shirt, pants, charactermesh, and bodycolors'},

    -- Animation Commands
    {NAME = 'animation / anim [ID] [speed]', DESC = 'Makes your character perform an animation (must be by Roblox to replicate)'},
    {NAME = 'dance', DESC = 'Makes you dance'},
    {NAME = 'undance', DESC = 'Stops dance animations'},
    {NAME = 'spasm', DESC = 'Makes you crazy'},
    {NAME = 'unspasm', DESC = 'Stops spasm'},
    {NAME = 'headthrow', DESC = 'Simply makes you throw your head'},
    {NAME = 'noanim', DESC = 'Disables your animations'},
    {NAME = 'reanim', DESC = 'Restores your animations'},
    {NAME = 'animspeed [num]', DESC = 'Changes the speed of your current animation'},
    {NAME = 'copyanimation / copyanim / copyemote [player]', DESC = 'Copies someone elses animation'},
    {NAME = 'copyanimationid / copyanimid / copyemoteid [player]', DESC = 'Copies your animation id or someone elses to your clipboard'},
    {NAME = 'loopanimation / loopanim', DESC = 'Loops your current animation'},
    {NAME = 'stopanimations / stopanims', DESC = 'Stops running animations'},
    {NAME = 'refreshanimations / refreshanims', DESC = 'Refreshes animations'},
    {NAME = 'allowcustomanim / allowcustomanimations', DESC = 'Lets you use custom animation packs instead'},
    {NAME = 'unallowcustomanim / unallowcustomanimations', DESC = 'Doesn\'t let you use custom animation packs instead'},

    -- Miscelaneous Commands
    {NAME = 'autoclick [click delay] [release delay]', DESC = 'Automatically clicks your mouse with a set delay'},
    {NAME = 'unautoclick / noautoclick', DESC = 'Turns off autoclick'},
    {NAME = 'autokeypress [key] [down delay] [up delay]', DESC = 'Automatically presses a key with a set delay'},
    {NAME = 'unautokeypress', DESC = 'Stops autokeypress'},
    {NAME = 'hovername', DESC = 'Shows a players username when your mouse is hovered over them'},
    {NAME = 'unhovername / nohovername', DESC = 'Turns off hovername'},
    {NAME = 'mousesensitivity / ms [0-10]', DESC = 'Sets your mouse sensitivity (affects first person and right click drag) (default is 1)'},
    {NAME = 'clickdelete', DESC = 'Go to settings>Keybinds>Add for clicktp'},
    {NAME = 'clickteleport', DESC = 'Go to settings>Keybinds>Add for click tp'},
    {NAME = 'mouseteleport / mousetp', DESC = 'Teleports your character to your mouse. This is recommended as a keybind'},

    -- Tool Commands
    {NAME = 'tools', DESC = 'Copies tools from ReplicatedStorage and Lighting'},
    {NAME = 'notools / removetools / deletetools', DESC = 'Removes tools from character and backpack'},
    {NAME = 'deleteselectedtool / dst', DESC = 'Removes any currently selected tools'},
    {NAME = 'grabtools', DESC = 'Automatically get tools that are dropped'},
    {NAME = 'ungrabtools / nograbtools', DESC = 'Disables grabtools'},
    {NAME = 'copytools [player] (CLIENT)', DESC = 'Copies a players tools'},
    {NAME = 'dupetools / clonetools [num]', DESC = 'Duplicates your inventory tools a set amount of times'},
    {NAME = 'givetool / givetools', DESC = 'Gives all the tools you\'re holding to [player] using the attach method.'},
    {NAME = 'droptools', DESC = 'Drops your tools'},
    {NAME = 'droppabletools', DESC = 'Makes your tools droppable'},
    {NAME = 'equiptools', DESC = 'Equips every tool in your inventory at once'},
    {NAME = 'unequiptools', DESC = 'Unequips every tool you are currently holding at once'},
    {NAME = 'removespecifictool [name]', DESC = 'Automatically remove a specific tool from your inventory'},
    {NAME = 'unremovespecifictool [name]', DESC = 'Stops removing a specific tool from your inventory'},
    {NAME = 'clearremovespecifictool', DESC = 'Stop removing all specific tools from your inventory'},
    {NAME = 'reach [num]', DESC = 'Increases the hitbox of your held tool'},
    {NAME = 'boxreach [num]', DESC = 'Increases the hitbox of your held tool in a box shape'},
    {NAME = 'unreach / noreach', DESC = 'Turns off reach'},
    {NAME = 'grippos [X Y Z]', DESC = 'Changes your current tools grip position'},
    {NAME = 'usetools [amount] [delay]', DESC = 'Activates all tools in your backpack at the same time'},

    -- Alias Commands
    {NAME = 'addalias [cmd] [alias]', DESC = 'Adds an alias to a command'},
    {NAME = 'removealias [alias]', DESC = 'Removes a custom alias'},
    {NAME = 'clraliases', DESC = 'Removes all custom aliases'},

    -- Plugin Commands
    {NAME = 'addplugin / plugin [name]', DESC = 'Add a plugin via command'},
    {NAME = 'removeplugin / deleteplugin [name]', DESC = 'Remove a plugin via command'},
    {NAME = 'reloadplugin [name]', DESC = 'Reloads a plugin'},
    {NAME = 'addallplugins / loadallplugins', DESC = 'Adds all available plugins from the workspace folder'},

    -- Miscellaneous Utility Commands
    {NAME = 'breakloops / break (cmd loops)', DESC = 'Stops any cmd loops (;100^1^cmd)'},
    {NAME = 'removecmd / deletecmd', DESC = 'Removes a command until the admin is reloaded'},
    {NAME = 'tpwalk / teleportwalk [num]', DESC = 'Teleports you to your move direction'},
    {NAME = 'untpwalk / unteleportwalk', DESC = 'Undoes tpwalk / teleportwalk'},
    {NAME = 'notifyping / ping', DESC = 'Notify yourself your ping'},
    {NAME = 'trip', DESC = 'Makes your character fall over'},
    {NAME = 'norender', DESC = 'Disable 3d Rendering to decrease the amount of CPU the client uses'},
    {NAME = 'render', DESC = 'Enable 3d Rendering'},
    {NAME = 'use2022materials / 2022materials', DESC = 'Enables 2022 material textures'},
    {NAME = 'unuse2022materials / un2022materials', DESC = 'Disables 2022 material textures'},
    {NAME = 'promptr6', DESC = 'Prompts the game to switch your rig type to R6'},
    {NAME = 'promptr15', DESC = 'Prompts the game to switch your rig type to R15'},
    {NAME = 'wallwalk / walkonwalls', DESC = 'Walk on walls'},
    {NAME = 'removeads / adblock', DESC = 'Automatically removes ad billboards'},
    {NAME = 'scare / spook [player]', DESC = 'Teleports in front of a player for half a second'},
    {NAME = 'alignmentkeys', DESC = 'Enables the left and right alignment keys (comma and period)'},
    {NAME = 'unalignmentkeys / noalignmentkeys', DESC = 'Disables the alignment keys'},
    {NAME = 'ctrllock', DESC = 'Binds Shiftlock to LeftControl'},
    {NAME = 'unctrllock', DESC = 'Re-binds Shiftlock to LeftShift'},
    {NAME = 'listento [player]', DESC = 'Listens to the area around a player. Can also eavesdrop with vc'},
    {NAME = 'unlistento', DESC = 'Disables listento'},
    {NAME = 'jerk', DESC = 'Makes you jork it'},
    {NAME = 'unsuspendvc', DESC = 'Unsuspends you from voice chat'},
}

for i = 1, #CMDs do
    local newcmd = Example:Clone() -- Clone the example button
    newcmd.Parent = CMDsF -- Set the parent to the command frame
    newcmd.Visible = false -- Hide the button initially
    newcmd.Text = CMDs[i].NAME -- Set the button text to the command name
    newcmd.Name = "CMD" -- Set the name of the button
    table.insert(text1, newcmd) -- Add the button to the text1 table

    -- If the command has a description, set up its attributes and click event
    if CMDs[i].DESC ~= "" then
        newcmd:SetAttribute("Title", CMDs[i].NAME) -- Set the title attribute
        newcmd:SetAttribute("Desc", CMDs[i].DESC) -- Set the description attribute

        -- Handle button click for auto-completion
        newcmd.MouseButton1Down:Connect(function()
            if not IsOnMobile and newcmd.Visible and newcmd.TextTransparency == 0 then
                local currentText = Cmdbar.Text
                Cmdbar:CaptureFocus() -- Focus the command bar
                autoComplete(newcmd.Text, currentText) -- Auto-complete the command
                maximizeHolder() -- Maximize the command holder
            end
        end)
    end
end

-- Initialize the command list with empty search
IndexContents("", true)

function checkTT()
    local t
    local guisAtPosition = COREGUI:GetGuiObjectsAtPosition(IYMouse.X, IYMouse.Y) -- Get GUI objects at mouse position

    -- Find the command button under the mouse
    for _, gui in pairs(guisAtPosition) do
        if gui.Parent == CMDsF then
            t = gui
        end
    end

    -- If a valid command button is found, display the tooltip
    if t ~= nil and t:GetAttribute("Title") ~= nil then
        local x = IYMouse.X
        local y = IYMouse.Y
        local xP, yP

        -- Adjust tooltip position based on mouse position
        if IYMouse.X > 200 then
            xP = x - 201
        else
            xP = x + 21
        end

        if IYMouse.Y > (IYMouse.ViewSizeY - 96) then
            yP = y - 97
        else
            yP = y
        end

        -- Update tooltip position and content
        Tooltip.Position = UDim2.new(0, xP, 0, yP)
        Description.Text = t:GetAttribute("Desc") -- Set description text
        Title_3.Text = t:GetAttribute("Title") or '' -- Set title text
        Tooltip.Visible = true -- Show the tooltip
    else
        Tooltip.Visible = false -- Hide the tooltip if no valid button is found
    end
end

-- Check if a value exists in a table
function FindInTable(tbl, val)
    if tbl == nil then return false end
    for _, v in pairs(tbl) do
        if v == val then return true end
    end
    return false
end

-- Get the index of a value in a table
function GetInTable(Table, Name)
    for i = 1, #Table do
        if Table[i] == Name then
            return i
        end
    end
    return false
end

-- Respawn the player's character
function respawn(plr)
    if invisRunning then TurnVisible() end -- Turn visible if invisible
    local char = plr.Character
    if char:FindFirstChildOfClass("Humanoid") then
        char:FindFirstChildOfClass("Humanoid"):ChangeState(15) -- Reset humanoid state
    end
    char:ClearAllChildren() -- Clear all children of the character
    local newChar = Instance.new("Model")
    newChar.Parent = workspace
    plr.Character = newChar -- Set the new character
    wait()
    plr.Character = char -- Restore the original character
    newChar:Destroy() -- Destroy the temporary character
end

-- Refresh the player's character while preserving position
local refreshCmd = false
function refresh(plr)
    refreshCmd = true
    local Human = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid", true)
    local pos = Human and Human.RootPart and Human.RootPart.CFrame
    local pos1 = workspace.CurrentCamera.CFrame
    respawn(plr) -- Respawn the player

    -- Restore the player's position after respawn
    task.spawn(function()
        plr.CharacterAdded:Wait():WaitForChild("Humanoid").RootPart.CFrame, workspace.CurrentCamera.CFrame = pos, wait() and pos1
        refreshCmd = false
    end)
end

-- Track the player's last death position
local lastDeath
function onDied()
    task.spawn(function()
        if pcall(function() Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') end) and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
            Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if getRoot(Players.LocalPlayer.Character) then
                    lastDeath = getRoot(Players.LocalPlayer.Character).CFrame -- Save the last death position
                end
            end)
        else
            wait(2)
            onDied() -- Retry if the humanoid is not found
        end
    end)
end

-- Handle character added events
Clip = true
spDelay = 0.1
Players.LocalPlayer.CharacterAdded:Connect(function()
    NOFLY() -- Disable fly
    Floating = false -- Disable floating

    if not Clip then
        execCmd('clip') -- Enable clipping if disabled
    end

    repeat wait() until getRoot(Players.LocalPlayer.Character) -- Wait for the character to load

    -- Restore spawn position if set
    pcall(function()
        if spawnpoint and not refreshCmd and spawnpos ~= nil then
            wait(spDelay)
            getRoot(Players.LocalPlayer.Character).CFrame = spawnpos
        end
    end)

    onDied() -- Track death events for the new character
end)

onDied() -- Initialize death tracking

-- Get a substring starting from a specific index
function getstring(begin)
    local start = begin - 1
    local AA = ''
    for i, v in pairs(cargs) do
        if i > start then
            if AA ~= '' then
                AA = AA .. ' ' .. v
            else
                AA = AA .. v
            end
        end
    end
    return AA
end

-- Find a command by name or alias
function findCmd(cmd_name)
    for i, v in pairs(cmds) do
        if v.NAME:lower() == cmd_name:lower() or FindInTable(v.ALIAS, cmd_name:lower()) then
            return v
        end
    end
    return customAlias[cmd_name:lower()] -- Check custom aliases
end

-- Split a string by a delimiter
function splitString(str, delim)
    local broken = {}
    if delim == nil then delim = "," end
    for w in string.gmatch(str, "[^" .. delim .. "]+") do
        table.insert(broken, w)
    end
    return broken
end


cmdHistory = {}
local lastCmds = {}
local historyCount = 0
local split = " "
local lastBreakTime = 0

function execCmd(cmdStr, speaker, store)
    cmdStr = cmdStr:gsub("%s+$", "") -- Trim trailing spaces
    task.spawn(function()
        local rawCmdStr = cmdStr
        cmdStr = string.gsub(cmdStr, "\\\\", "%%BackSlash%%") -- Escape backslashes
        local commandsToRun = splitString(cmdStr, "\\") -- Split commands by backslash

        for i, v in pairs(commandsToRun) do
            v = string.gsub(v, "%%BackSlash%%", "\\") -- Restore backslashes
            local x, y, num = v:find("^(%d+)%^") -- Check for repetition count
            local cmdDelay = 0
            local infTimes = false

            -- Handle repetition and delay
            if num then
                v = v:sub(y + 1)
                local x, y, del = v:find("^([%d%.]+)%^")
                if del then
                    v = v:sub(y + 1)
                    cmdDelay = tonumber(del) or 0
                end
            else
                local x, y = v:find("^inf%^")
                if x then
                    infTimes = true
                    v = v:sub(y + 1)
                    local x, y, del = v:find("^([%d%.]+)%^")
                    if del then
                        v = v:sub(y + 1)
                        del = tonumber(del) or 1
                        cmdDelay = (del > 0 and del or 1)
                    else
                        cmdDelay = 1
                    end
                end
            end
            num = tonumber(num or 1)

            -- Handle command shortcuts
            if v:sub(1, 1) == "!" then
                local chunks = splitString(v:sub(2), split)
                if chunks[1] and lastCmds[chunks[1]] then
                    v = lastCmds[chunks[1]]
                end
            end

            -- Split command into arguments
            local args = splitString(v, split)
            local cmdName = args[1]
            local cmd = findCmd(cmdName)

            if cmd then
                table.remove(args, 1) -- Remove the command name from arguments
                cargs = args

                if not speaker then
                    speaker = Players.LocalPlayer
                end

                if store then
                    if speaker == Players.LocalPlayer then
                        if cmdHistory[1] ~= rawCmdStr and rawCmdStr:sub(1, 11) ~= 'lastcommand' and rawCmdStr:sub(1, 7) ~= 'lastcmd' then
                            table.insert(cmdHistory, 1, rawCmdStr)
                        end
                    end
                    if #cmdHistory > 30 then
                        table.remove(cmdHistory)
                    end

                    lastCmds[cmdName] = v
                end

                local cmdStartTime = tick()
                if infTimes then
                    while lastBreakTime < cmdStartTime do
                        local success, err = pcall(cmd.FUNC, args, speaker)
                        if not success and _G.IY_DEBUG then
                            warn("Command Error:", cmdName, err)
                        end
                        wait(cmdDelay)
                    end
                else
                    for rep = 1, num do
                        if lastBreakTime > cmdStartTime then
                            break
                        end
                        local success, err = pcall(function()
                            cmd.FUNC(args, speaker)
                        end)
                        if not success and _G.IY_DEBUG then
                            warn("Command Error:", cmdName, err)
                        end
                        if cmdDelay ~= 0 then
                            wait(cmdDelay)
                        end
                    end
                end
            end
        end
    end)
end

function addcmd(name, alias, func, plgn)
    cmds[#cmds + 1] = {
        NAME = name,
        ALIAS = alias or {},
        FUNC = func,
        PLUGIN = plgn
    }
end

function removecmd(cmd)
    if cmd ~= " " then
        for i = #cmds, 1, -1 do
            if cmds[i].NAME == cmd or FindInTable(cmds[i].ALIAS, cmd) then
                table.remove(cmds, i)

                for _, c in pairs(CMDsF:GetChildren()) do
                    if string.find(c.Text, "^" .. cmd .. "$") or
                       string.find(c.Text, "^" .. cmd .. " ") or
                       string.find(c.Text, " " .. cmd .. "$") or
                       string.find(c.Text, " " .. cmd .. " ") then
                        c.TextTransparency = 0.7
                        c.MouseButton1Click:Connect(function()
                            notify(c.Text, "Command has been disabled by you or a plugin")
                        end)
                    end
                end
            end
        end
    end
end

function overridecmd(name, func)
    local cmd = findCmd(name)
    if cmd and cmd.FUNC then
        cmd.FUNC = func
    end
end

function addbind(cmd, key, iskeyup, toggle)
    local newBind = {
        COMMAND = cmd,
        KEY = key,
        ISKEYUP = iskeyup
    }

    -- Add toggle functionality if specified
    if toggle then
        newBind.TOGGLE = toggle
    end

    table.insert(binds, newBind) -- Add the keybind to the list
end

function addcmdtext(text, name, desc)
    local newcmd = Example:Clone()
    newcmd.Parent = CMDsF
    newcmd.Visible = false
    newcmd.Text = text
    newcmd.Name = 'PLUGIN_' .. name
    table.insert(text1, newcmd)

    if desc and desc ~= '' then
        newcmd:SetAttribute("Title", text)
        newcmd:SetAttribute("Desc", desc)

        newcmd.MouseButton1Down:Connect(function()
            if newcmd.Visible and newcmd.TextTransparency == 0 then
                Cmdbar:CaptureFocus()
                autoComplete(newcmd.Text)
                maximizeHolder()
            end
        end)
    end
end

local WorldToScreen = function(Object)
    local ObjectVector = workspace.CurrentCamera:WorldToScreenPoint(Object.Position)
    return Vector2.new(ObjectVector.X, ObjectVector.Y)
end

local MousePositionToVector2 = function()
    return Vector2.new(IYMouse.X, IYMouse.Y)
end

local GetClosestPlayerFromCursor = function()
    local found = nil
    local ClosestDistance = math.huge

    for _, v in pairs(Players:GetPlayers()) do
        if v ~= Players.LocalPlayer and v.Character and v.Character:FindFirstChildOfClass("Humanoid") then
            for _, x in pairs(v.Character:GetChildren()) do
                if string.find(x.Name, "Torso") then
                    local Distance = (WorldToScreen(x) - MousePositionToVector2()).Magnitude
                    if Distance < ClosestDistance then
                        ClosestDistance = Distance
                        found = v
                    end
                end
            end
        end
    end

    return found
end

--[[
    Player Filtering and Command Execution Script
    This script handles player filtering based on various criteria and executes commands.
    It includes functions for ESP (Extra Sensory Perception) and CHMS (Character Highlighting and Monitoring System).
]]

-- SpecialPlayerCases: A table of functions that filter players based on specific criteria.
SpecialPlayerCases = {
    ["all"] = function(speaker) return Players:GetPlayers() end,
    ["others"] = function(speaker)
        local plrs = {}
        for _, v in pairs(Players:GetPlayers()) do
            if v ~= speaker then
                table.insert(plrs, v)
            end
        end
        return plrs
    end,
    ["me"] = function(speaker) return {speaker} end,
    ["#(%d+)"] = function(speaker, args, currentList)
        local returns = {}
        local randAmount = tonumber(args[1])
        local players = {unpack(currentList)}
        for i = 1, randAmount do
            if #players == 0 then break end
            local randIndex = math.random(1, #players)
            table.insert(returns, players[randIndex])
            table.remove(players, randIndex)
        end
        return returns
    end,
    ["random"] = function(speaker, args, currentList)
        local players = Players:GetPlayers()
        local localplayer = Players.LocalPlayer
        table.remove(players, table.find(players, localplayer))
        return {players[math.random(1, #players)]}
    end,
    ["%%(.+)"] = function(speaker, args)
        local returns = {}
        local team = args[1]
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Team and string.sub(string.lower(plr.Team.Name), 1, #team) == string.lower(team) then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["allies"] = function(speaker)
        local returns = {}
        local team = speaker.Team
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Team == team then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["enemies"] = function(speaker)
        local returns = {}
        local team = speaker.Team
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Team ~= team then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["team"] = function(speaker)
        local returns = {}
        local team = speaker.Team
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Team == team then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["nonteam"] = function(speaker)
        local returns = {}
        local team = speaker.Team
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Team ~= team then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["friends"] = function(speaker, args)
        local returns = {}
        for _, plr in pairs(Players:GetPlayers()) do
            if plr:IsFriendsWith(speaker.UserId) and plr ~= speaker then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["nonfriends"] = function(speaker, args)
        local returns = {}
        for _, plr in pairs(Players:GetPlayers()) do
            if not plr:IsFriendsWith(speaker.UserId) and plr ~= speaker then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["guests"] = function(speaker, args)
        local returns = {}
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Guest then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["bacons"] = function(speaker, args)
        local returns = {}
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Character:FindFirstChild('Pal Hair') or plr.Character:FindFirstChild('Kate Hair') then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["age(%d+)"] = function(speaker, args)
        local returns = {}
        local age = tonumber(args[1])
        if not age then return end
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.AccountAge <= age then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["nearest"] = function(speaker, args, currentList)
        local speakerChar = speaker.Character
        if not speakerChar or not getRoot(speakerChar) then return end
        local lowest = math.huge
        local NearestPlayer = nil
        for _, plr in pairs(currentList) do
            if plr ~= speaker and plr.Character then
                local distance = plr:DistanceFromCharacter(getRoot(speakerChar).Position)
                if distance < lowest then
                    lowest = distance
                    NearestPlayer = {plr}
                end
            end
        end
        return NearestPlayer
    end,
    ["farthest"] = function(speaker, args, currentList)
        local speakerChar = speaker.Character
        if not speakerChar or not getRoot(speakerChar) then return end
        local highest = 0
        local Farthest = nil
        for _, plr in pairs(currentList) do
            if plr ~= speaker and plr.Character then
                local distance = plr:DistanceFromCharacter(getRoot(speakerChar).Position)
                if distance > highest then
                    highest = distance
                    Farthest = {plr}
                end
            end
        end
        return Farthest
    end,
    ["group(%d+)"] = function(speaker, args)
        local returns = {}
        local groupID = tonumber(args[1])
        for _, plr in pairs(Players:GetPlayers()) do
            if plr:IsInGroup(groupID) then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["alive"] = function(speaker, args)
        local returns = {}
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["dead"] = function(speaker, args)
        local returns = {}
        for _, plr in pairs(Players:GetPlayers()) do
            if (not plr.Character or not plr.Character:FindFirstChildOfClass("Humanoid")) or plr.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
                table.insert(returns, plr)
            end
        end
        return returns
    end,
    ["rad(%d+)"] = function(speaker, args)
        local returns = {}
        local radius = tonumber(args[1])
        local speakerChar = speaker.Character
        if not speakerChar or not getRoot(speakerChar) then return end
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Character and getRoot(plr.Character) then
                local magnitude = (getRoot(plr.Character).Position - getRoot(speakerChar).Position).magnitude
                if magnitude <= radius then table.insert(returns, plr) end
            end
        end
        return returns
    end,
    ["cursor"] = function(speaker)
        local plrs = {}
        local v = GetClosestPlayerFromCursor()
        if v ~= nil then table.insert(plrs, v) end
        return plrs
    end,
    ["npcs"] = function(speaker, args)
        local returns = {}
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Model") and getRoot(v) and v:FindFirstChildWhichIsA("Humanoid") and Players:GetPlayerFromCharacter(v) == nil then
                local clone = Instance.new("Player")
                clone.Name = v.Name .. " - " .. v:FindFirstChildWhichIsA("Humanoid").DisplayName
                clone.Character = v
                table.insert(returns, clone)
            end
        end
        return returns
    end,
}

-- toTokens: Converts a string into tokens based on operators (+/-).
function toTokens(str)
    local tokens = {}
    for op, name in string.gmatch(str, "([+-])([^+-]+)") do
        table.insert(tokens, {Operator = op, Name = name})
    end
    return tokens
end

-- onlyIncludeInTable: Filters a table to include only specified matches.
function onlyIncludeInTable(tab, matches)
    local matchTable = {}
    local resultTable = {}
    for _, v in pairs(matches) do matchTable[v.Name] = true end
    for _, v in pairs(tab) do if matchTable[v.Name] then table.insert(resultTable, v) end end
    return resultTable
end

-- removeTableMatches: Filters a table to exclude specified matches.
function removeTableMatches(tab, matches)
    local matchTable = {}
    local resultTable = {}
    for _, v in pairs(matches) do matchTable[v.Name] = true end
    for _, v in pairs(tab) do if not matchTable[v.Name] then table.insert(resultTable, v) end end
    return resultTable
end

-- getPlayersByName: Retrieves players by name or display name.
function getPlayersByName(Name)
    local Name, Len, Found = string.lower(Name), #Name, {}
    for _, v in pairs(Players:GetPlayers()) do
        if Name:sub(0, 1) == '@' then
            if string.sub(string.lower(v.Name), 1, Len - 1) == Name:sub(2) then
                table.insert(Found, v)
            end
        else
            if string.sub(string.lower(v.Name), 1, Len) == Name or string.sub(string.lower(v.DisplayName), 1, Len) == Name then
                table.insert(Found, v)
            end
        end
    end
    return Found
end

-- getPlayer: Retrieves a list of players based on a filter string.
function getPlayer(list, speaker)
    if list == nil then return {speaker.Name} end
    local nameList = splitString(list, ",")

    local foundList = {}

    for _, name in pairs(nameList) do
        if string.sub(name, 1, 1) ~= "+" and string.sub(name, 1, 1) ~= "-" then name = "+" .. name end
        local tokens = toTokens(name)
        local initialPlayers = Players:GetPlayers()

        for _, v in pairs(tokens) do
            if v.Operator == "+" then
                local tokenContent = v.Name
                local foundCase = false
                for regex, case in pairs(SpecialPlayerCases) do
                    local matches = {string.match(tokenContent, "^" .. regex .. "$")}
                    if #matches > 0 then
                        foundCase = true
                        initialPlayers = onlyIncludeInTable(initialPlayers, case(speaker, matches, initialPlayers))
                    end
                end
                if not foundCase then
                    initialPlayers = onlyIncludeInTable(initialPlayers, getPlayersByName(tokenContent))
                end
            else
                local tokenContent = v.Name
                local foundCase = false
                for regex, case in pairs(SpecialPlayerCases) do
                    local matches = {string.match(tokenContent, "^" .. regex .. "$")}
                    if #matches > 0 then
                        foundCase = true
                        initialPlayers = removeTableMatches(initialPlayers, case(speaker, matches, initialPlayers))
                    end
                end
                if not foundCase then
                    initialPlayers = removeTableMatches(initialPlayers, getPlayersByName(tokenContent))
                end
            end
        end

        for _, v in pairs(initialPlayers) do table.insert(foundList, v) end
    end

    local foundNames = {}
    for _, v in pairs(foundList) do table.insert(foundNames, v.Name) end

    return foundNames
end

formatUsername = function(player)
    if player.DisplayName ~= player.Name then
        return string.format("%s (%s)", player.Name, player.DisplayName)
    end
    return player.Name
end

getprfx = function(strn)
    if strn:sub(1, string.len(prefix)) == prefix then return {'cmd', string.len(prefix) + 1} end
    return
end

function do_exec(str, plr)
    str = str:gsub('/e ', '')
    local t = getprfx(str)
    if not t then return end
    str = str:sub(t[2])
    if t[1] == 'cmd' then
        execCmd(str, plr, true)
        IndexContents('', true, false, true)
        CMDsF.CanvasPosition = canvasPos
    end
end

lastTextBoxString, lastTextBoxCon, lastEnteredString = nil, nil, nil

UserInputService.TextBoxFocused:Connect(function(obj)
    if lastTextBoxCon then lastTextBoxCon:Disconnect() end
    if obj == Cmdbar then lastTextBoxString = nil return end
    lastTextBoxString = obj.Text
    lastTextBoxCon = obj:GetPropertyChangedSignal("Text"):Connect(function()
        if not (UserInputService:IsKeyDown(Enum.KeyCode.Return) or UserInputService:IsKeyDown(Enum.KeyCode.KeypadEnter)) then
            lastTextBoxString = obj.Text
        end
    end)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then
        if Cmdbar and Cmdbar:IsFocused() then
            if input.KeyCode == Enum.KeyCode.Up then
                historyCount = historyCount + 1
                if historyCount > #cmdHistory then historyCount = #cmdHistory end
                Cmdbar.Text = cmdHistory[historyCount] or ""
                Cmdbar.CursorPosition = 1020
            elseif input.KeyCode == Enum.KeyCode.Down then
                historyCount = historyCount - 1
                if historyCount < 0 then historyCount = 0 end
                Cmdbar.Text = cmdHistory[historyCount] or ""
                Cmdbar.CursorPosition = 1020
            end
        elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.KeypadEnter then
            lastEnteredString = lastTextBoxString
        end
    end
end)

Players.LocalPlayer.Chatted:Connect(function()
    wait()
    if lastEnteredString then
        local message = lastEnteredString
        lastEnteredString = nil
        do_exec(message, Players.LocalPlayer)
    end
end)

Cmdbar.PlaceholderText = "Command Bar (" .. prefix .. ")"
Cmdbar:GetPropertyChangedSignal("Text"):Connect(function()
    if Cmdbar:IsFocused() then
        IndexContents(Cmdbar.Text, true, true)
    end
end)

local tabComplete = nil
tabAllowed = true
Cmdbar.FocusLost:Connect(function(enterpressed)
    if enterpressed then
        local cmdbarText = Cmdbar.Text:gsub("^" .. prefix, "")
        execCmd(cmdbarText, Players.LocalPlayer, true)
    end
    if tabComplete then tabComplete:Disconnect() end
    wait()
    if not Cmdbar:IsFocused() then
        Cmdbar.Text = ""
        IndexContents('', true, false, true)
        if SettingsOpen == true then
            wait(0.2)
            Settings:TweenPosition(UDim2.new(0, 0, 0, 45), "InOut", "Quart", 0.2, true, nil)
            CMDsF.Visible = false
        end
    end
    CMDsF.CanvasPosition = canvasPos
end)

Cmdbar.Focused:Connect(function()
    historyCount = 0
    canvasPos = CMDsF.CanvasPosition
    if SettingsOpen == true then
        wait(0.2)
        CMDsF.Visible = true
        Settings:TweenPosition(UDim2.new(0, 0, 0, 220), "InOut", "Quart", 0.2, true, nil)
    end
    tabComplete = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if Cmdbar:IsFocused() then
            if tabAllowed == true and input.KeyCode == Enum.KeyCode.Tab and topCommand ~= nil then
                autoComplete(topCommand)
            end
        else
            tabComplete:Disconnect()
        end
    end)
end)

ESPenabled = false
CHMSenabled = false

function round(num, numDecimalPlaces)
    local mult = 10 ^ (numDecimalPlaces or 0)
    return math.floor(num * mult + 0.5) / mult
end

function ESP(plr)
    task.spawn(function()
        for _, v in pairs(COREGUI:GetChildren()) do
            if v.Name == plr.Name .. '_ESP' then
                v:Destroy()
            end
        end
        wait()
        if plr.Character and plr.Name ~= Players.LocalPlayer.Name and not COREGUI:FindFirstChild(plr.Name .. '_ESP') then
            local ESPholder = Instance.new("Folder")
            ESPholder.Name = plr.Name .. '_ESP'
            ESPholder.Parent = COREGUI
            repeat wait(1) until plr.Character and getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
            for _, n in pairs(plr.Character:GetChildren()) do
                if (n:IsA("BasePart")) then
                    local a = Instance.new("BoxHandleAdornment")
                    a.Name = plr.Name
                    a.Parent = ESPholder
                    a.Adornee = n
                    a.AlwaysOnTop = true
                    a.ZIndex = 10
                    a.Size = n.Size
                    a.Transparency = espTransparency
                    a.Color = plr.TeamColor
                end
            end
            if plr.Character and plr.Character:FindFirstChild('Head') then
                local BillboardGui = Instance.new("BillboardGui")
                local TextLabel = Instance.new("TextLabel")
                BillboardGui.Adornee = plr.Character.Head
                BillboardGui.Name = plr.Name
                BillboardGui.Parent = ESPholder
                BillboardGui.Size = UDim2.new(0, 100, 0, 150)
                BillboardGui.StudsOffset = Vector3.new(0, 1, 0)
                BillboardGui.AlwaysOnTop = true
                TextLabel.Parent = BillboardGui
                TextLabel.BackgroundTransparency = 1
                TextLabel.Position = UDim2.new(0, 0, 0, -50)
                TextLabel.Size = UDim2.new(0, 100, 0, 100)
                TextLabel.Font = Enum.Font.SourceSansSemibold
                TextLabel.TextSize = 20
                TextLabel.TextColor3 = Color3.new(1, 1, 1)
                TextLabel.TextStrokeTransparency = 0
                TextLabel.TextYAlignment = Enum.TextYAlignment.Bottom
                TextLabel.Text = 'Name: ' .. plr.Name
                TextLabel.ZIndex = 10
                local espLoopFunc
                local teamChange
                local addedFunc
                addedFunc = plr.CharacterAdded:Connect(function()
                    if ESPenabled then
                        espLoopFunc:Disconnect()
                        teamChange:Disconnect()
                        ESPholder:Destroy()
                        repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
                        ESP(plr)
                        addedFunc:Disconnect()
                    else
                        teamChange:Disconnect()
                        addedFunc:Disconnect()
                    end
                end)
                teamChange = plr:GetPropertyChangedSignal("TeamColor"):Connect(function()
                    if ESPenabled then
                        espLoopFunc:Disconnect()
                        addedFunc:Disconnect()
                        ESPholder:Destroy()
                        repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
                        ESP(plr)
                        teamChange:Disconnect()
                    else
                        teamChange:Disconnect()
                    end
                end)
                local function espLoop()
                    if COREGUI:FindFirstChild(plr.Name .. '_ESP') then
                        if plr.Character and getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid") and Players.LocalPlayer.Character and getRoot(Players.LocalPlayer.Character) and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
                            local pos = math.floor((getRoot(Players.LocalPlayer.Character).Position - getRoot(plr.Character).Position).magnitude)
                            TextLabel.Text = 'Name: ' .. plr.Name .. ' | Health: ' .. round(plr.Character:FindFirstChildOfClass('Humanoid').Health, 1) .. ' | Studs: ' .. pos
                        end
                    else
                        teamChange:Disconnect()
                        addedFunc:Disconnect()
                        espLoopFunc:Disconnect()
                    end
                end
                espLoopFunc = RunService.RenderStepped:Connect(espLoop)
            end
        end
    end)
end

function CHMS(plr)
    task.spawn(function()
        for _, v in pairs(COREGUI:GetChildren()) do
            if v.Name == plr.Name .. '_CHMS' then
                v:Destroy()
            end
        end
        wait()
        if plr.Character and plr.Name ~= Players.LocalPlayer.Name and not COREGUI:FindFirstChild(plr.Name .. '_CHMS') then
            local ESPholder = Instance.new("Folder")
            ESPholder.Name = plr.Name .. '_CHMS'
            ESPholder.Parent = COREGUI
            repeat wait(1) until plr.Character and getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
            for _, n in pairs(plr.Character:GetChildren()) do
                if (n:IsA("BasePart")) then
                    local a = Instance.new("BoxHandleAdornment")
                    a.Name = plr.Name
                    a.Parent = ESPholder
                    a.Adornee = n
                    a.AlwaysOnTop = true
                    a.ZIndex = 10
                    a.Size = n.Size
                    a.Transparency = espTransparency
                    a.Color = plr.TeamColor
                end
            end
            local addedFunc
            local teamChange
            local CHMSremoved
            addedFunc = plr.CharacterAdded:Connect(function()
                if CHMSenabled then
                    ESPholder:Destroy()
                    teamChange:Disconnect()
                    repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
                    CHMS(plr)
                    addedFunc:Disconnect()
                else
                    teamChange:Disconnect()
                    addedFunc:Disconnect()
                end
            end)
            teamChange = plr:GetPropertyChangedSignal("TeamColor"):Connect(function()
                if CHMSenabled then
                    ESPholder:Destroy()
                    addedFunc:Disconnect()
                    repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
                    CHMS(plr)
                    teamChange:Disconnect()
                else
                    teamChange:Disconnect()
                end
            end)
            CHMSremoved = ESPholder.AncestryChanged:Connect(function()
                teamChange:Disconnect()
                addedFunc:Disconnect()
                CHMSremoved:Disconnect()
            end)
        end
    end)
end

function Locate(plr)
    task.spawn(function()
        for _, v in pairs(COREGUI:GetChildren()) do
            if v.Name == plr.Name .. '_LC' then
                v:Destroy()
            end
        end
        wait()

        if plr.Character and plr.Name ~= Players.LocalPlayer.Name and not COREGUI:FindFirstChild(plr.Name .. '_LC') then
            local ESPholder = Instance.new("Folder")
            ESPholder.Name = plr.Name .. '_LC'
            ESPholder.Parent = COREGUI

            repeat wait(1) until plr.Character and getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")

            for _, n in pairs(plr.Character:GetChildren()) do
                if n:IsA("BasePart") then
                    local a = Instance.new("BoxHandleAdornment")
                    a.Name = plr.Name
                    a.Parent = ESPholder
                    a.Adornee = n
                    a.AlwaysOnTop = true
                    a.ZIndex = 10
                    a.Size = n.Size
                    a.Transparency = espTransparency
                    a.Color = plr.TeamColor
                end
            end

            if plr.Character and plr.Character:FindFirstChild('Head') then
                local BillboardGui = Instance.new("BillboardGui")
                local TextLabel = Instance.new("TextLabel")
                BillboardGui.Adornee = plr.Character.Head
                BillboardGui.Name = plr.Name
                BillboardGui.Parent = ESPholder
                BillboardGui.Size = UDim2.new(0, 100, 0, 150)
                BillboardGui.StudsOffset = Vector3.new(0, 1, 0)
                BillboardGui.AlwaysOnTop = true

                TextLabel.Parent = BillboardGui
                TextLabel.BackgroundTransparency = 1
                TextLabel.Position = UDim2.new(0, 0, 0, -50)
                TextLabel.Size = UDim2.new(0, 100, 0, 100)
                TextLabel.Font = Enum.Font.SourceSansSemibold
                TextLabel.TextSize = 20
                TextLabel.TextColor3 = Color3.new(1, 1, 1)
                TextLabel.TextStrokeTransparency = 0
                TextLabel.TextYAlignment = Enum.TextYAlignment.Bottom
                TextLabel.Text = 'Name: ' .. plr.Name
                TextLabel.ZIndex = 10

                local lcLoopFunc
                local addedFunc
                local teamChange

                addedFunc = plr.CharacterAdded:Connect(function()
                    if ESPholder and ESPholder.Parent then
                        lcLoopFunc:Disconnect()
                        teamChange:Disconnect()
                        ESPholder:Destroy()
                        repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
                        Locate(plr)
                        addedFunc:Disconnect()
                    else
                        teamChange:Disconnect()
                        addedFunc:Disconnect()
                    end
                end)

                teamChange = plr:GetPropertyChangedSignal("TeamColor"):Connect(function()
                    if ESPholder and ESPholder.Parent then
                        lcLoopFunc:Disconnect()
                        addedFunc:Disconnect()
                        ESPholder:Destroy()
                        repeat wait(1) until getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid")
                        Locate(plr)
                        teamChange:Disconnect()
                    else
                        teamChange:Disconnect()
                    end
                end)

                local function lcLoop()
                    if COREGUI:FindFirstChild(plr.Name .. '_LC') then
                        if plr.Character and getRoot(plr.Character) and plr.Character:FindFirstChildOfClass("Humanoid") and Players.LocalPlayer.Character and getRoot(Players.LocalPlayer.Character) and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
                            local pos = math.floor((getRoot(Players.LocalPlayer.Character).Position - getRoot(plr.Character).Position).magnitude)
                            TextLabel.Text = 'Name: ' .. plr.Name .. ' | Health: ' .. round(plr.Character:FindFirstChildOfClass('Humanoid').Health, 1) .. ' | Studs: ' .. pos
                        end
                    else
                        teamChange:Disconnect()
                        addedFunc:Disconnect()
                        lcLoopFunc:Disconnect()
                    end
                end
                lcLoopFunc = RunService.RenderStepped:Connect(lcLoop)
            end
        end
    end)
end

local bindsGUI = KeybindEditor
local awaitingInput = false
local keySelected = false

function refreshbinds()
    if Holder_2 then
        Holder_2:ClearAllChildren()
        Holder_2.CanvasSize = UDim2.new(0, 0, 0, 10)
        for i = 1, #binds do
            local YSize = 25
            local Position = ((i * YSize) - YSize)
            local newbind = Example_2:Clone()
            newbind.Parent = Holder_2
            newbind.Visible = true
            newbind.Position = UDim2.new(0, 0, 0, Position + 5)
            table.insert(shade2, newbind)
            table.insert(shade2, newbind.Text)
            table.insert(text1, newbind.Text)
            table.insert(shade3, newbind.Text.Delete)
            table.insert(text2, newbind.Text.Delete)

            local input = tostring(binds[i].KEY)
            local key
            if input == 'RightClick' or input == 'LeftClick' then
                key = input
            else
                key = input:sub(14)
            end

            if binds[i].TOGGLE then
                newbind.Text.Text = key .. " > " .. binds[i].COMMAND .. " / " .. binds[i].TOGGLE
            else
                newbind.Text.Text = key .. " > " .. binds[i].COMMAND .. "  " .. (binds[i].ISKEYUP and "(keyup)" or "(keydown)")
            end

            Holder_2.CanvasSize = UDim2.new(0, 0, 0, Position + 30)
            newbind.Text.Delete.MouseButton1Click:Connect(function()
                unkeybind(binds[i].COMMAND, binds[i].KEY)
            end)
        end
    end
end

refreshbinds()

toggleOn = {}

function unkeybind(cmd, key)
    for i = #binds, 1, -1 do
        if binds[i].COMMAND == cmd and binds[i].KEY == key then
            toggleOn[binds[i]] = nil
            table.remove(binds, i)
        end
    end
    refreshbinds()
    updatesaves()
    if key == 'RightClick' or key == 'LeftClick' then
        notify('Keybinds Updated', 'Unbinded ' .. key .. ' from ' .. cmd)
    else
        notify('Keybinds Updated', 'Unbinded ' .. key:sub(14) .. ' from ' .. cmd)
    end
end

PositionsFrame.Delete.MouseButton1Click:Connect(function()
    execCmd('cpos')
end)

function refreshwaypoints()
    if #WayPoints > 0 or #pWayPoints > 0 then
        PositionsHint:Destroy()
    end
    if Holder_4 then
        Holder_4:ClearAllChildren()
        Holder_4.CanvasSize = UDim2.new(0, 0, 0, 10)
        local YSize = 25
        local num = 1
        for i = 1, #WayPoints do
            local Position = ((num * YSize) - YSize)
            local newpoint = Example_4:Clone()
            newpoint.Parent = Holder_4
            newpoint.Visible = true
            newpoint.Position = UDim2.new(0, 0, 0, Position + 5)
            newpoint.Text.Text = WayPoints[i].NAME
            table.insert(shade2, newpoint)
            table.insert(shade2, newpoint.Text)
            table.insert(text1, newpoint.Text)
            table.insert(shade3, newpoint.Text.Delete)
            table.insert(text2, newpoint.Text.Delete)
            table.insert(shade3, newpoint.Text.TP)
            table.insert(text2, newpoint.Text.TP)
            Holder_4.CanvasSize = UDim2.new(0, 0, 0, Position + 30)
            newpoint.Text.Delete.MouseButton1Click:Connect(function()
                execCmd('dpos ' .. WayPoints[i].NAME)
            end)
            newpoint.Text.TP.MouseButton1Click:Connect(function()
                execCmd("loadpos " .. WayPoints[i].NAME)
            end)
            num = num + 1
        end
        for i = 1, #pWayPoints do
            local Position = ((num * YSize) - YSize)
            local newpoint = Example_4:Clone()
            newpoint.Parent = Holder_4
            newpoint.Visible = true
            newpoint.Position = UDim2.new(0, 0, 0, Position + 5)
            newpoint.Text.Text = pWayPoints[i].NAME
            table.insert(shade2, newpoint)
            table.insert(shade2, newpoint.Text)
            table.insert(text1, newpoint.Text)
            table.insert(shade3, newpoint.Text.Delete)
            table.insert(text2, newpoint.Text.Delete)
            table.insert(shade3, newpoint.Text.TP)
            table.insert(text2, newpoint.Text.TP)
            Holder_4.CanvasSize = UDim2.new(0, 0, 0, Position + 30)
            newpoint.Text.Delete.MouseButton1Click:Connect(function()
                execCmd('dpos ' .. pWayPoints[i].NAME)
            end)
            newpoint.Text.TP.MouseButton1Click:Connect(function()
                execCmd("loadpos " .. pWayPoints[i].NAME)
            end)
            num = num + 1
        end
    end
end

refreshwaypoints()

function refreshaliases()
    if #aliases > 0 then
        AliasHint:Destroy()
    end
    if Holder_3 then
        Holder_3:ClearAllChildren()
        Holder_3.CanvasSize = UDim2.new(0, 0, 0, 10)
        for i = 1, #aliases do
            local YSize = 25
            local Position = ((i * YSize) - YSize)
            local newalias = Example_3:Clone()
            newalias.Parent = Holder_3
            newalias.Visible = true
            newalias.Position = UDim2.new(0, 0, 0, Position + 5)
            newalias.Text.Text = aliases[i].CMD .. " > " .. aliases[i].ALIAS
            table.insert(shade2, newalias)
            table.insert(shade2, newalias.Text)
            table.insert(text1, newalias.Text)
            table.insert(shade3, newalias.Text.Delete)
            table.insert(text2, newalias.Text.Delete)
            Holder_3.CanvasSize = UDim2.new(0, 0, 0, Position + 30)
            newalias.Text.Delete.MouseButton1Click:Connect(function()
                execCmd('removealias ' .. aliases[i].ALIAS)
            end)
        end
    end
end

local bindChosenKeyUp = false

BindTo.MouseButton1Click:Connect(function()
    awaitingInput = true
    BindTo.Text = 'Press something'
end)

BindTriggerSelect.MouseButton1Click:Connect(function()
    bindChosenKeyUp = not bindChosenKeyUp
    BindTriggerSelect.Text = bindChosenKeyUp and "KeyUp" or "KeyDown"
end)

newToggle = false
Cmdbar_3.Parent.Visible = false
On_2.MouseButton1Click:Connect(function()
    newToggle = not newToggle
    On_2.BackgroundTransparency = newToggle and 0 or 1
    Cmdbar_3.Parent.Visible = newToggle
    BindTriggerSelect.Visible = not newToggle
end)

Add_2.MouseButton1Click:Connect(function()
    if keySelected then
        if string.find(Cmdbar_2.Text, "\\\\") or string.find(Cmdbar_3.Text, "\\\\") then
            notify('Keybind Error', 'Only use one backslash to keybind multiple commands into one keybind or command')
        else
            if newToggle and Cmdbar_3.Text ~= '' and Cmdbar_2.Text ~= '' then
                addbind(Cmdbar_2.Text, keyPressed, false, Cmdbar_3.Text)
            elseif not newToggle and Cmdbar_2.Text ~= '' then
                addbind(Cmdbar_2.Text, keyPressed, bindChosenKeyUp)
            else
                return
            end
            refreshbinds()
            updatesaves()
            if keyPressed == 'RightClick' or keyPressed == 'LeftClick' then
                notify('Keybinds Updated', 'Binded ' .. keyPressed .. ' to ' .. Cmdbar_2.Text .. (newToggle and " / " .. Cmdbar_3.Text or ""))
            else
                notify('Keybinds Updated', 'Binded ' .. keyPressed:sub(14) .. ' to ' .. Cmdbar_2.Text .. (newToggle and " / " .. Cmdbar_3.Text or ""))
            end
        end
    end
end)

Exit_2.MouseButton1Click:Connect(function()
    Cmdbar_2.Text = 'Command'
    Cmdbar_3.Text = 'Command 2'
    BindTo.Text = 'Click to bind'
    bindChosenKeyUp = false
    BindTriggerSelect.Text = "KeyDown"
    keySelected = false
    KeybindEditor:TweenPosition(UDim2.new(0.5, -180, 0, -500), "InOut", "Quart", 0.5, true, nil)
end)

function onInputBegan(input, gameProcessed)
    if awaitingInput then
        if input.UserInputType == Enum.UserInputType.Keyboard then
            keyPressed = tostring(input.KeyCode)
            BindTo.Text = keyPressed:sub(14)
        elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
            keyPressed = 'LeftClick'
            BindTo.Text = 'LeftClick'
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            keyPressed = 'RightClick'
            BindTo.Text = 'RightClick'
        end
        awaitingInput = false
        keySelected = true
    end

    if not gameProcessed and #binds > 0 then
        for _, v in pairs(binds) do
            if not v.ISKEYUP then
                if (input.UserInputType == Enum.UserInputType.Keyboard and v.KEY:lower() == tostring(input.KeyCode):lower()) or
                   (input.UserInputType == Enum.UserInputType.MouseButton1 and v.KEY:lower() == 'leftclick') or
                   (input.UserInputType == Enum.UserInputType.MouseButton2 and v.KEY:lower() == 'rightclick') then
                    if v.TOGGLE then
                        local isOn = toggleOn[v] == true
                        toggleOn[v] = not isOn
                        execCmd(isOn and v.TOGGLE or v.COMMAND, Players.LocalPlayer)
                    else
                        execCmd(v.COMMAND, Players.LocalPlayer)
                    end
                end
            end
        end
    end
end

function onInputEnded(input, gameProcessed)
    if not gameProcessed and #binds > 0 then
        for _, v in pairs(binds) do
            if v.ISKEYUP then
                if (input.UserInputType == Enum.UserInputType.Keyboard and v.KEY:lower() == tostring(input.KeyCode):lower()) or
                   (input.UserInputType == Enum.UserInputType.MouseButton1 and v.KEY:lower() == 'leftclick') or
                   (input.UserInputType == Enum.UserInputType.MouseButton2 and v.KEY:lower() == 'rightclick') then
                    execCmd(v.COMMAND, Players.LocalPlayer)
                end
            end
        end
    end
end

UserInputService.InputBegan:Connect(onInputBegan)
UserInputService.InputEnded:Connect(onInputEnded)

ClickTP.Select.MouseButton1Click:Connect(function()
    if keySelected then
        addbind('clicktp', keyPressed, bindChosenKeyUp)
        refreshbinds()
        updatesaves()
        notify('Keybinds Updated', 'Binded ' .. (keyPressed == 'RightClick' or keyPressed == 'LeftClick' and keyPressed or keyPressed:sub(14)) .. ' to click tp')
    end
end)

ClickDelete.Select.MouseButton1Click:Connect(function()
    if keySelected then
        addbind('clickdel', keyPressed, bindChosenKeyUp)
        refreshbinds()
        updatesaves()
        notify('Keybinds Updated', 'Binded ' .. (keyPressed == 'RightClick' or keyPressed == 'LeftClick' and keyPressed or keyPressed:sub(14)) .. ' to click delete')
    end
end)


local function clicktpFunc()
    pcall(function()
        local character = Players.LocalPlayer.Character
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.SeatPart then
            humanoid.Sit = false
            wait(0.1)
        end

        local hipHeight = humanoid and humanoid.HipHeight > 0 and (humanoid.HipHeight + 1)
        local rootPart = getRoot(character)
        local rootPartPosition = rootPart.Position
        local hitPosition = IYMouse.Hit.Position
        local newCFrame = CFrame.new(hitPosition, Vector3.new(rootPartPosition.X, hitPosition.Y, rootPartPosition.Z)) * CFrame.Angles(0, math.pi, 0)

        rootPart.CFrame = newCFrame + Vector3.new(0, hipHeight or 4, 0)
    end)
end

IYMouse.Button1Down:Connect(function()
    for _, v in pairs(binds) do
        if v.COMMAND == 'clicktp' then
            local input = v.KEY
            if (input == 'RightClick' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)) or
               (input == 'LeftClick' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) or
               UserInputService:IsKeyDown(Enum.KeyCode[input:sub(14)]) then
                clicktpFunc()
            end
        elseif v.COMMAND == 'clickdel' then
            local input = v.KEY
            if (input == 'RightClick' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)) or
               (input == 'LeftClick' and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)) or
               UserInputService:IsKeyDown(Enum.KeyCode[input:sub(14)]) then
                pcall(function() IYMouse.Target:Destroy() end)
            end
        end
    end
end)

PluginsGUI = PluginEditor.background

function addPlugin(name)
    if name:lower() == 'plugin file name' or name:lower() == 'iy_fe.iy' or name == 'iy_fe' then
        notify('Plugin Error', 'Please enter a valid plugin')
    else
        local file
        local fileName = name:sub(-3) == '.iy' and name or name .. '.iy'
        pcall(function() file = readfile(fileName) end)

        if file then
            if not FindInTable(PluginsTable, fileName) then
                table.insert(PluginsTable, fileName)
                LoadPlugin(fileName)
                refreshplugins()
                pcall(eventEditor.Refresh)
            else
                notify('Plugin Error', 'This plugin is already added')
            end
        else
            notify('Plugin Error', 'Cannot locate file "' .. fileName .. '". Is the file in the correct folder?')
        end
    end
end

function deletePlugin(name)
    local pName = name:sub(-3) == '.iy' and name or name .. '.iy'
    for i = #cmds, 1, -1 do
        if cmds[i].PLUGIN == pName then
            table.remove(cmds, i)
        end
    end
    for _, v in pairs(CMDsF:GetChildren()) do
        if v.Name == 'PLUGIN_' .. pName then
            v:Destroy()
        end
    end
    for i, v in pairs(PluginsTable) do
        if v == pName then
            table.remove(PluginsTable, i)
            notify('Removed Plugin', pName .. ' was removed')
        end
    end
    IndexContents('', true)
    refreshplugins()
end

function refreshplugins(dontSave)
    if #PluginsTable > 0 then
        PluginsHint:Destroy()
    end
    if Holder_5 then
        Holder_5:ClearAllChildren()
        Holder_5.CanvasSize = UDim2.new(0, 0, 0, 10)
        for i, v in pairs(PluginsTable) do
            local YSize = 25
            local Position = ((i * YSize) - YSize)
            local newplugin = Example_5:Clone()
            newplugin.Parent = Holder_5
            newplugin.Visible = true
            newplugin.Position = UDim2.new(0, 0, 0, Position + 5)
            newplugin.Text.Text = v
            table.insert(shade2, newplugin)
            table.insert(shade2, newplugin.Text)
            table.insert(text1, newplugin.Text)
            table.insert(shade3, newplugin.Text.Delete)
            table.insert(text2, newplugin.Text.Delete)
            Holder_5.CanvasSize = UDim2.new(0, 0, 0, Position + 30)
            newplugin.Text.Delete.MouseButton1Click:Connect(function()
                deletePlugin(v)
            end)
        end
        if not dontSave then
            updatesaves()
        end
    end
end

function LoadPlugin(val, startup)
    local plugin

    function CatchedPluginLoad()
        plugin = loadfile(val)()
    end

    function handlePluginError(plerror)
        notify('Plugin Error', 'An error occurred with the plugin, "' .. val .. '" and it could not be loaded')
        if FindInTable(PluginsTable, val) then
            for i, v in pairs(PluginsTable) do
                if v == val then
                    table.remove(PluginsTable, i)
                end
            end
        end
        updatesaves()
        print("Original Error: " .. tostring(plerror))
        print("Plugin Error, stack traceback: " .. tostring(debug.traceback()))
        plugin = nil
        return false
    end

    xpcall(CatchedPluginLoad, handlePluginError)

    if plugin ~= nil then
        if not startup then
            notify('Loaded Plugin', "Name: " .. plugin["PluginName"] .. "\n" .. "Description: " .. plugin["PluginDescription"])
        end
        addcmdtext('', val)
        addcmdtext(string.upper('--' .. plugin["PluginName"]), val, plugin["PluginDescription"])
        if plugin["Commands"] then
            for i, v in pairs(plugin["Commands"]) do
                local cmdExt = ''
                local cmdName = i
                local function handleNames()
                    cmdName = i
                    if findCmd(cmdName .. cmdExt) then
                        if isNumber(cmdExt) then
                            cmdExt = cmdExt + 1
                        else
                            cmdExt = 1
                        end
                        handleNames()
                    else
                        cmdName = cmdName .. cmdExt
                    end
                end
                handleNames()
                addcmd(cmdName, v["Aliases"], v["Function"], val)
                if v["ListName"] then
                    local newName = v.ListName
                    local cmdNames = {i, unpack(v.Aliases)}
                    for _, alias in pairs(cmdNames) do
                        newName = newName:gsub(alias, alias .. cmdExt)
                    end
                    addcmdtext(newName, val, v["Description"])
                else
                    addcmdtext(cmdName, val, v["Description"])
                end
            end
        end
        IndexContents('', true)
    end
end

function FindPlugins()
    if PluginsTable ~= nil and type(PluginsTable) == "table" then
        for _, v in pairs(PluginsTable) do
            LoadPlugin(v, true)
        end
        refreshplugins(true)
    end
end

AddPlugin.MouseButton1Click:Connect(function()
    addPlugin(PluginsGUI.FileName.Text)
end)

Exit_3.MouseButton1Click:Connect(function()
    PluginEditor:TweenPosition(UDim2.new(0.5, -180, 0, -500), "InOut", "Quart", 0.5, true, nil)
    FileName.Text = 'Plugin File Name'
end)

Add_3.MouseButton1Click:Connect(function()
    PluginEditor:TweenPosition(UDim2.new(0.5, -180, 0, 310), "InOut", "Quart", 0.5, true, nil)
end)

Plugins.MouseButton1Click:Connect(function()
    if writefileExploit() then
        PluginsFrame:TweenPosition(UDim2.new(0, 0, 0, 0), "InOut", "Quart", 0.5, true, nil)
        wait(0.5)
        SettingsHolder.Visible = false
    else
        notify('Incompatible Exploit', 'Your exploit is unable to use plugins (missing read/writefile)')
    end
end)

Close_4.MouseButton1Click:Connect(function()
    SettingsHolder.Visible = true
    PluginsFrame:TweenPosition(UDim2.new(0, 0, 0, 175), "InOut", "Quart", 0.5, true, nil)
end)

local TeleportCheck = false
Players.LocalPlayer.OnTeleport:Connect(function(State)
    if KeepInfYield and (not TeleportCheck) and queueteleport then
        TeleportCheck = true
        queueteleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()")
    end
end)

addcmd('addalias', {}, function(args, speaker)
    if #args < 2 then return end
    local cmd = string.lower(args[1])
    local alias = string.lower(args[2])
    for _, v in pairs(cmds) do
        if v.NAME:lower() == cmd or FindInTable(v.ALIAS, cmd) then
            customAlias[alias] = v
            aliases[#aliases + 1] = {CMD = cmd, ALIAS = alias}
            notify('Aliases Modified', "Added " .. alias .. " as an alias to " .. cmd)
            updatesaves()
            refreshaliases()
            break
        end
    end
end)

addcmd('removealias', {}, function(args, speaker)
    if #args < 1 then return end
    local alias = string.lower(args[1])
    if customAlias[alias] then
        local cmd = customAlias[alias].NAME
        customAlias[alias] = nil
        for i = #aliases, 1, -1 do
            if aliases[i].ALIAS == tostring(alias) then
                table.remove(aliases, i)
            end
        end
        notify('Aliases Modified', "Removed the alias " .. alias .. " from " .. cmd)
        updatesaves()
        refreshaliases()
    end
end)

addcmd('clraliases', {}, function(args, speaker)
    customAlias = {}
    aliases = {}
    notify('Aliases Modified', 'Removed all aliases')
    updatesaves()
    refreshaliases()
end)

addcmd('discord', {'support', 'help'}, function(args, speaker)
    if everyClipboard then
        toClipboard('https://discord.com/invite/dYHag43eeU')
        notify('Discord Invite', 'Copied to clipboard!\ndiscord.gg/dYHag43eeU')
    else
        notify('Discord Invite', 'discord.gg/dYHag43eeU')
    end
    if httprequest then
        httprequest({
            Url = 'http://127.0.0.1:6463/rpc?v=1',
            Method = 'POST',
            Headers = {
                ['Content-Type'] = 'application/json',
                Origin = 'https://discord.com'
            },
            Body = HttpService:JSONEncode({
                cmd = 'INVITE_BROWSER',
                nonce = HttpService:GenerateGUID(false),
                args = {code = 'dYHag43eeU'}
            })
        })
    end
end)

addcmd('keepiy', {}, function(args, speaker)
    if queueteleport then
        KeepInfYield = true
        updatesaves()
    else
        notify('Incompatible Exploit', 'Your exploit does not support this command (missing queue_on_teleport)')
    end
end)

addcmd('unkeepiy', {}, function(args, speaker)
    if queueteleport then
        KeepInfYield = false
        updatesaves()
    else
        notify('Incompatible Exploit', 'Your exploit does not support this command (missing queue_on_teleport)')
    end
end)

addcmd('togglekeepiy', {}, function(args, speaker)
    if queueteleport then
        KeepInfYield = not KeepInfYield
        updatesaves()
    else
        notify('Incompatible Exploit', 'Your exploit does not support this command (missing queue_on_teleport)')
    end
end)

local canOpenServerinfo = true
addcmd('serverinfo', {'info', 'sinfo'}, function(args, speaker)
    if not canOpenServerinfo then return end
    canOpenServerinfo = false
    task.spawn(function()

        local FRAME = Instance.new("Frame")
        local shadow = Instance.new("Frame")
        local PopupText = Instance.new("TextLabel")
        local Exit = Instance.new("TextButton")
        local ExitImage = Instance.new("ImageLabel")
        local background = Instance.new("Frame")
        local TextLabel = Instance.new("TextLabel")
        local TextLabel2 = Instance.new("TextLabel")
        local TextLabel3 = Instance.new("TextLabel")
        local Time = Instance.new("TextLabel")
        local appearance = Instance.new("TextLabel")
        local maxplayers = Instance.new("TextLabel")
        local name = Instance.new("TextLabel")
        local placeid = Instance.new("TextLabel")
        local playerid = Instance.new("TextLabel")
        local players = Instance.new("TextLabel")
        local CopyApp = Instance.new("TextButton")
        local CopyPlrID = Instance.new("TextButton")
        local CopyPlcID = Instance.new("TextButton")
        local CopyPlcName = Instance.new("TextButton")

        FRAME.Name = randomString()
        FRAME.Parent = ScaledHolder
        FRAME.Active = true
        FRAME.BackgroundTransparency = 1
        FRAME.Position = UDim2.new(0.5, -130, 0, -500)
        FRAME.Size = UDim2.new(0, 250, 0, 20)
        FRAME.ZIndex = 10
        dragGUI(FRAME)

        shadow.Name = "shadow"
        shadow.Parent = FRAME
        shadow.BackgroundColor3 = currentShade2
        shadow.BorderSizePixel = 0
        shadow.Size = UDim2.new(0, 250, 0, 20)
        shadow.ZIndex = 10
        table.insert(shade2, shadow)

        PopupText.Name = "PopupText"
        PopupText.Parent = shadow
        PopupText.BackgroundTransparency = 1
        PopupText.Size = UDim2.new(1, 0, 0.95, 0)
        PopupText.ZIndex = 10
        PopupText.Font = Enum.Font.SourceSans
        PopupText.TextSize = 14
        PopupText.Text = "Server"
        PopupText.TextColor3 = currentText1
        PopupText.TextWrapped = true
        table.insert(text1, PopupText)

        Exit.Name = "Exit"
        Exit.Parent = shadow
        Exit.BackgroundTransparency = 1
        Exit.Position = UDim2.new(1, -20, 0, 0)
        Exit.Size = UDim2.new(0, 20, 0, 20)
        Exit.Text = ""
        Exit.ZIndex = 10

        ExitImage.Parent = Exit
        ExitImage.BackgroundColor3 = Color3.new(1, 1, 1)
        ExitImage.BackgroundTransparency = 1
        ExitImage.Position = UDim2.new(0, 5, 0, 5)
        ExitImage.Size = UDim2.new(0, 10, 0, 10)
        ExitImage.Image = "rbxassetid://5054663650"
        ExitImage.ZIndex = 10

        background.Name = "background"
        background.Parent = FRAME
        background.Active = true
        background.BackgroundColor3 = currentShade1
        background.BorderSizePixel = 0
        background.Position = UDim2.new(0, 0, 1, 0)
        background.Size = UDim2.new(0, 250, 0, 250)
        background.ZIndex = 10
        table.insert(shade1, background)

        TextLabel.Name = "Text Label"
        TextLabel.Parent = background
        TextLabel.BackgroundTransparency = 1
        TextLabel.BorderSizePixel = 0
        TextLabel.Position = UDim2.new(0, 5, 0, 80)
        TextLabel.Size = UDim2.new(0, 100, 0, 20)
        TextLabel.ZIndex = 10
        TextLabel.Font = Enum.Font.SourceSansLight
        TextLabel.TextSize = 20
        TextLabel.Text = "Run Time:"
        TextLabel.TextColor3 = currentText1
        TextLabel.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, TextLabel)

        TextLabel2.Name = "Text Label2"
        TextLabel2.Parent = background
        TextLabel2.BackgroundTransparency = 1
        TextLabel2.BorderSizePixel = 0
        TextLabel2.Position = UDim2.new(0, 5, 0, 130)
        TextLabel2.Size = UDim2.new(0, 100, 0, 20)
        TextLabel2.ZIndex = 10
        TextLabel2.Font = Enum.Font.SourceSansLight
        TextLabel2.TextSize = 20
        TextLabel2.Text = "Statistics:"
        TextLabel2.TextColor3 = currentText1
        TextLabel2.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, TextLabel2)

        TextLabel3.Name = "Text Label3"
        TextLabel3.Parent = background
        TextLabel3.BackgroundTransparency = 1
        TextLabel3.BorderSizePixel = 0
        TextLabel3.Position = UDim2.new(0, 5, 0, 10)
        TextLabel3.Size = UDim2.new(0, 100, 0, 20)
        TextLabel3.ZIndex = 10
        TextLabel3.Font = Enum.Font.SourceSansLight
        TextLabel3.TextSize = 20
        TextLabel3.Text = "Local Player:"
        TextLabel3.TextColor3 = currentText1
        TextLabel3.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, TextLabel3)

        Time.Name = "Time"
        Time.Parent = background
        Time.BackgroundTransparency = 1
        Time.BorderSizePixel = 0
        Time.Position = UDim2.new(0, 5, 0, 105)
        Time.Size = UDim2.new(0, 100, 0, 20)
        Time.ZIndex = 10
        Time.Font = Enum.Font.SourceSans
        Time.FontSize = Enum.FontSize.Size14
        Time.Text = "LOADING"
        Time.TextColor3 = currentText1
        Time.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, Time)

        appearance.Name = "appearance"
        appearance.Parent = background
        appearance.BackgroundTransparency = 1
        appearance.BorderSizePixel = 0
        appearance.Position = UDim2.new(0, 5, 0, 55)
        appearance.Size = UDim2.new(0, 100, 0, 20)
        appearance.ZIndex = 10
        appearance.Font = Enum.Font.SourceSans
        appearance.FontSize = Enum.FontSize.Size14
        appearance.Text = "Appearance: LOADING"
        appearance.TextColor3 = currentText1
        appearance.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, appearance)

        maxplayers.Name = "maxplayers"
        maxplayers.Parent = background
        maxplayers.BackgroundTransparency = 1
        maxplayers.BorderSizePixel = 0
        maxplayers.Position = UDim2.new(0, 5, 0, 175)
        maxplayers.Size = UDim2.new(0, 100, 0, 20)
        maxplayers.ZIndex = 10
        maxplayers.Font = Enum.Font.SourceSans
        maxplayers.FontSize = Enum.FontSize.Size14
        maxplayers.Text = "LOADING"
        maxplayers.TextColor3 = currentText1
        maxplayers.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, maxplayers)

        name.Name = "name"
        name.Parent = background
        name.BackgroundTransparency = 1
        name.BorderSizePixel = 0
        name.Position = UDim2.new(0, 5, 0, 215)
        name.Size = UDim2.new(0, 240, 0, 30)
        name.ZIndex = 10
        name.Font = Enum.Font.SourceSans
        name.FontSize = Enum.FontSize.Size14
        name.Text = "Place Name: LOADING"
        name.TextColor3 = currentText1
        name.TextWrapped = true
        name.TextXAlignment = Enum.TextXAlignment.Left
        name.TextYAlignment = Enum.TextYAlignment.Top
        table.insert(text1, name)

        placeid.Name = "placeid"
        placeid.Parent = background
        placeid.BackgroundTransparency = 1
        placeid.BorderSizePixel = 0
        placeid.Position = UDim2.new(0, 5, 0, 195)
        placeid.Size = UDim2.new(0, 100, 0, 20)
        placeid.ZIndex = 10
        placeid.Font = Enum.Font.SourceSans
        placeid.FontSize = Enum.FontSize.Size14
        placeid.Text = "Place ID: LOADING"
        placeid.TextColor3 = currentText1
        placeid.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, placeid)

        playerid.Name = "playerid"
        playerid.Parent = background
        playerid.BackgroundTransparency = 1
        playerid.BorderSizePixel = 0
        playerid.Position = UDim2.new(0, 5, 0, 35)
        playerid.Size = UDim2.new(0, 100, 0, 20)
        playerid.ZIndex = 10
        playerid.Font = Enum.Font.SourceSans
        playerid.FontSize = Enum.FontSize.Size14
        playerid.Text = "Player ID: LOADING"
        playerid.TextColor3 = currentText1
        playerid.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, playerid)

        players.Name = "players"
        players.Parent = background
        players.BackgroundTransparency = 1
        players.BorderSizePixel = 0
        players.Position = UDim2.new(0, 5, 0, 155)
        players.Size = UDim2.new(0, 100, 0, 20)
        players.ZIndex = 10
        players.Font = Enum.Font.SourceSans
        players.FontSize = Enum.FontSize.Size14
        players.Text = "LOADING"
        players.TextColor3 = currentText1
        players.TextXAlignment = Enum.TextXAlignment.Left
        table.insert(text1, players)

        CopyApp.Name = "CopyApp"
        CopyApp.Parent = background
        CopyApp.BackgroundColor3 = currentShade2
        CopyApp.BorderSizePixel = 0
        CopyApp.Position = UDim2.new(0, 210, 0, 55)
        CopyApp.Size = UDim2.new(0, 35, 0, 20)
        CopyApp.Font = Enum.Font.SourceSans
        CopyApp.TextSize = 14
        CopyApp.Text = "Copy"
        CopyApp.TextColor3 = currentText1
        CopyApp.ZIndex = 10
        table.insert(shade2, CopyApp)
        table.insert(text1, CopyApp)

        CopyPlrID.Name = "CopyPlrID"
        CopyPlrID.Parent = background
        CopyPlrID.BackgroundColor3 = currentShade2
        CopyPlrID.BorderSizePixel = 0
        CopyPlrID.Position = UDim2.new(0, 210, 0, 35)
        CopyPlrID.Size = UDim2.new(0, 35, 0, 20)
        CopyPlrID.Font = Enum.Font.SourceSans
        CopyPlrID.TextSize = 14
        CopyPlrID.Text = "Copy"
        CopyPlrID.TextColor3 = currentText1
        CopyPlrID.ZIndex = 10
        table.insert(shade2, CopyPlrID)
        table.insert(text1, CopyPlrID)

        CopyPlcID.Name = "CopyPlcID"
        CopyPlcID.Parent = background
        CopyPlcID.BackgroundColor3 = currentShade2
        CopyPlcID.BorderSizePixel = 0
        CopyPlcID.Position = UDim2.new(0, 210, 0, 195)
        CopyPlcID.Size = UDim2.new(0, 35, 0, 20)
        CopyPlcID.Font = Enum.Font.SourceSans
        CopyPlcID.TextSize = 14
        CopyPlcID.Text = "Copy"
        CopyPlcID.TextColor3 = currentText1
        CopyPlcID.ZIndex = 10
        table.insert(shade2, CopyPlcID)
        table.insert(text1, CopyPlcID)

        CopyPlcName.Name = "CopyPlcName"
        CopyPlcName.Parent = background
        CopyPlcName.BackgroundColor3 = currentShade2
        CopyPlcName.BorderSizePixel = 0
        CopyPlcName.Position = UDim2.new(0, 210, 0, 215)
        CopyPlcName.Size = UDim2.new(0, 35, 0, 20)
        CopyPlcName.Font = Enum.Font.SourceSans
        CopyPlcName.TextSize = 14
        CopyPlcName.Text = "Copy"
        CopyPlcName.TextColor3 = currentText1
        CopyPlcName.ZIndex = 10
        table.insert(shade2, CopyPlcName)
        table.insert(text1, CopyPlcName)

        local SINFOGUI = background
        FRAME:TweenPosition(UDim2.new(0.5, -130, 0, 100), "InOut", "Quart", 0.5, true, nil)
        wait(0.5)

        Exit.MouseButton1Click:Connect(function()
            FRAME:TweenPosition(UDim2.new(0.5, -130, 0, -500), "InOut", "Quart", 0.5, true, nil)
            wait(0.6)
            FRAME:Destroy()
            canOpenServerinfo = true
        end)

        local Asset = MarketplaceService:GetProductInfo(PlaceId)
        SINFOGUI.name.Text = "Place Name: " .. Asset.Name
        SINFOGUI.playerid.Text = "Player ID: " .. speaker.UserId
        SINFOGUI.maxplayers.Text = Players.MaxPlayers .. " Players Max"
        SINFOGUI.placeid.Text = "Place ID: " .. PlaceId

        CopyApp.MouseButton1Click:Connect(function()
            toClipboard(speaker.CharacterAppearanceId)
        end)
        CopyPlrID.MouseButton1Click:Connect(function()
            toClipboard(speaker.UserId)
        end)
        CopyPlcID.MouseButton1Click:Connect(function()
            toClipboard(PlaceId)
        end)
        CopyPlcName.MouseButton1Click:Connect(function()
            toClipboard(Asset.Name)
        end)

        repeat
            local players = Players:GetPlayers()
            SINFOGUI.players.Text = #players .. " Player(s)"
            SINFOGUI.appearance.Text = "Appearance: " .. speaker.CharacterAppearanceId
            local seconds = math.floor(workspace.DistributedGameTime)
            local minutes = math.floor(workspace.DistributedGameTime / 60)
            local hours = math.floor(workspace.DistributedGameTime / 60 / 60)
            seconds = seconds - (minutes * 60)
            minutes = minutes - (hours * 60)
            if hours < 1 then
                if minutes < 1 then
                    SINFOGUI.Time.Text = seconds .. " Second(s)"
                else
                    SINFOGUI.Time.Text = minutes .. " Minute(s), " .. seconds .. " Second(s)"
                end
            else
                SINFOGUI.Time.Text = hours .. " Hour(s), " .. minutes .. " Minute(s), " .. seconds .. " Second(s)"
            end
            wait(1)
        until SINFOGUI.Parent == nil
    end)
end)

addcmd('jobid', {}, function(args, speaker)
    local jobId = 'Roblox.GameLauncher.joinGameInstance(' .. PlaceId .. ', "' .. JobId .. '")'
    toClipboard(jobId)
end)

addcmd('notifyjobid', {}, function(args, speaker)
    notify('JobId / PlaceId', JobId .. ' / ' .. PlaceId)
end)

addcmd('breakloops', {'break'}, function(args, speaker)
    lastBreakTime = tick()
end)

addcmd('gametp', {'gameteleport'}, function(args, speaker)
    TeleportService:Teleport(args[1])
end)

addcmd("rejoin", {"rj"}, function(args, speaker)
    if #Players:GetPlayers() <= 1 then
        Players.LocalPlayer:Kick("\nRejoining...")
        wait()
        TeleportService:Teleport(PlaceId, Players.LocalPlayer)
    else
        TeleportService:TeleportToPlaceInstance(PlaceId, JobId, Players.LocalPlayer)
    end
end)

addcmd("autorejoin", {"autorj"}, function(args, speaker)
    GuiService.ErrorMessageChanged:Connect(function()
        execCmd("rejoin")
    end)
    notify("Auto Rejoin", "Auto rejoin enabled")
end)

addcmd("serverhop", {"shop"}, function(args, speaker)
    if httprequest then
        local servers = {}
        local req = httprequest({Url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100&excludeFullGames=true", PlaceId)})
        local body = HttpService:JSONDecode(req.Body)

        if body and body.data then
            for i, v in next, body.data do
                if type(v) == "table" and tonumber(v.playing) and tonumber(v.maxPlayers) and v.playing < v.maxPlayers and v.id ~= JobId then
                    table.insert(servers, 1, v.id)
                end
            end
        end

        if #servers > 0 then
            TeleportService:TeleportToPlaceInstance(PlaceId, servers[math.random(1, #servers)], Players.LocalPlayer)
        else
            notify("Serverhop", "Couldn't find a server.")
        end
    else
        notify("Incompatible Exploit", "Your exploit does not support this command (missing request)")
    end
end)

addcmd("exit", {}, function(args, speaker)
    game:Shutdown()
end)

local Noclipping = nil
addcmd('noclip', {}, function(args, speaker)
    Clip = false
    wait(0.1)
    local function NoclipLoop()
        if Clip == false and speaker.Character ~= nil then
            for _, child in pairs(speaker.Character:GetDescendants()) do
                if child:IsA("BasePart") and child.CanCollide == true and child.Name ~= floatName then
                    child.CanCollide = false
                end
            end
        end
    end
    Noclipping = RunService.Stepped:Connect(NoclipLoop)
    if args[1] and args[1] == 'nonotify' then return end
    notify('Noclip', 'Noclip Enabled')
end)

addcmd('clip', {'unnoclip'}, function(args, speaker)
    if Noclipping then
        Noclipping:Disconnect()
    end
    Clip = true
    if args[1] and args[1] == 'nonotify' then return end
    notify('Noclip', 'Noclip Disabled')
end)

addcmd('togglenoclip', {}, function(args, speaker)
    if Clip then
        execCmd('noclip')
    else
        execCmd('clip')
    end
end)

FLYING = false
QEfly = true
iyflyspeed = 1
vehicleflyspeed = 1
function sFLY(vfly)
    repeat wait() until Players.LocalPlayer and Players.LocalPlayer.Character and getRoot(Players.LocalPlayer.Character) and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    repeat wait() until IYMouse
    if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

    local T = getRoot(Players.LocalPlayer.Character)
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0

    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro')
        local BV = Instance.new('BodyVelocity')
        BG.P = 9e4
        BG.Parent = T
        BV.Parent = T
        BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.cframe = T.CFrame
        BV.velocity = Vector3.new(0, 0, 0)
        BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
        task.spawn(function()
            repeat wait()
                if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                    Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.velocity = Vector3.new(0, 0, 0)
                end
                BG.cframe = workspace.CurrentCamera.CoordinateFrame
            until not FLYING
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:Destroy()
            BV:Destroy()
            if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
                Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
            end
        end)
    end
    flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 's' then
            CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'a' then
            CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
        elseif KEY:lower() == 'd' then
            CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
        elseif QEfly and KEY:lower() == 'e' then
            CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed) * 2
        elseif QEfly and KEY:lower() == 'q' then
            CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed) * 2
        end
        pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
    end)
    flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'e' then
            CONTROL.Q = 0
        elseif KEY:lower() == 'q' then
            CONTROL.E = 0
        end
    end)
    FLY()
end

function NOFLY()
    FLYING = false
    if flyKeyDown or flyKeyUp then
        flyKeyDown:Disconnect()
        flyKeyUp:Disconnect()
    end
    if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
        Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
    end
    pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

local velocityHandlerName = randomString()
local gyroHandlerName = randomString()
local mfly1, mfly2

local unmobilefly = function(speaker)
    pcall(function()
        FLYING = false
        local root = getRoot(speaker.Character)
        root:FindFirstChild(velocityHandlerName):Destroy()
        root:FindFirstChild(gyroHandlerName):Destroy()
        speaker.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
        if mfly1 then mfly1:Disconnect() end
        if mfly2 then mfly2:Disconnect() end
    end)
end

local mobilefly = function(speaker, vfly)
    unmobilefly(speaker)
    FLYING = true

    local root = getRoot(speaker.Character)
    local camera = workspace.CurrentCamera
    local v3none = Vector3.new()
    local v3zero = Vector3.new(0, 0, 0)
    local v3inf = Vector3.new(9e9, 9e9, 9e9)

    local controlModule = require(speaker.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
    local bv = Instance.new("BodyVelocity")
    bv.Name = velocityHandlerName
    bv.Parent = root
    bv.MaxForce = v3zero
    bv.Velocity = v3zero

    local bg = Instance.new("BodyGyro")
    bg.Name = gyroHandlerName
    bg.Parent = root
    bg.MaxTorque = v3inf
    bg.P = 1000
    bg.D = 50

    mfly1 = speaker.CharacterAdded:Connect(function()
        local bv = Instance.new("BodyVelocity")
        bv.Name = velocityHandlerName
        bv.Parent = root
        bv.MaxForce = v3zero
        bv.Velocity = v3zero

        local bg = Instance.new("BodyGyro")
        bg.Name = gyroHandlerName
        bg.Parent = root
        bg.MaxTorque = v3inf
        bg.P = 1000
        bg.D = 50
    end)

    mfly2 = RunService.RenderStepped:Connect(function()
        root = getRoot(speaker.Character)
        camera = workspace.CurrentCamera
        if speaker.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
            local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
            local VelocityHandler = root:FindFirstChild(velocityHandlerName)
            local GyroHandler = root:FindFirstChild(gyroHandlerName)

            VelocityHandler.MaxForce = v3inf
            GyroHandler.MaxTorque = v3inf
            if not vfly then humanoid.PlatformStand = true end
            GyroHandler.CFrame = camera.CoordinateFrame
            VelocityHandler.Velocity = v3none

            local direction = controlModule:GetMoveVector()
            if direction.X > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
            end
            if direction.X < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
            end
            if direction.Z > 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
            end
            if direction.Z < 0 then
                VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
            end
        end
    end)
end

addcmd('fly', {}, function(args, speaker)
    if not IsOnMobile then
        NOFLY()
        wait()
        sFLY()
    else
        mobilefly(speaker)
    end
    if args[1] and isNumber(args[1]) then
        iyflyspeed = args[1]
    end
end)

addcmd('flyspeed', {'flysp'}, function(args, speaker)
    local speed = args[1] or 1
    if isNumber(speed) then
        iyflyspeed = speed
    end
end)

addcmd('unfly', {'nofly', 'novfly', 'unvehiclefly', 'novehiclefly', 'unvfly'}, function(args, speaker)
    if not IsOnMobile then NOFLY() else unmobilefly(speaker) end
end)

addcmd('vfly', {'vehiclefly'}, function(args, speaker)
    if not IsOnMobile then
        NOFLY()
        wait()
        sFLY(true)
    else
        mobilefly(speaker, true)
    end
    if args[1] and isNumber(args[1]) then
        vehicleflyspeed = args[1]
    end
end)

addcmd('togglevfly', {}, function(args, speaker)
    if FLYING then
        if not IsOnMobile then NOFLY() else unmobilefly(speaker) end
    else
        if not IsOnMobile then sFLY(true) else mobilefly(speaker, true) end
    end
end)

addcmd('vflyspeed', {'vflysp', 'vehicleflyspeed', 'vehicleflysp'}, function(args, speaker)
    local speed = args[1] or 1
    if isNumber(speed) then
        vehicleflyspeed = speed
    end
end)

addcmd('qefly', {'flyqe'}, function(args, speaker)
    QEfly = args[1] ~= 'false'
end)

addcmd('togglefly', {}, function(args, speaker)
    if FLYING then
        if not IsOnMobile then NOFLY() else unmobilefly(speaker) end
    else
        if not IsOnMobile then sFLY() else mobilefly(speaker) end
    end
end)

CFspeed = 50
addcmd('cframefly', {'cfly'}, function(args, speaker)
    -- Full credit to peyton#9148 (apeyton)
    speaker.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
    local Head = speaker.Character:WaitForChild("Head")
    Head.Anchored = true
    if CFloop then CFloop:Disconnect() end
    CFloop = RunService.Heartbeat:Connect(function(deltaTime)
        local moveDirection = speaker.Character:FindFirstChildOfClass('Humanoid').MoveDirection * (CFspeed * deltaTime)
        local headCFrame = Head.CFrame
        local cameraCFrame = workspace.CurrentCamera.CFrame
        local cameraOffset = headCFrame:ToObjectSpace(cameraCFrame).Position
        cameraCFrame = cameraCFrame * CFrame.new(-cameraOffset.X, -cameraOffset.Y, -cameraOffset.Z + 1)
        local cameraPosition = cameraCFrame.Position
        local headPosition = headCFrame.Position

        local objectSpaceVelocity = CFrame.new(cameraPosition, Vector3.new(headPosition.X, cameraPosition.Y, headPosition.Z)):VectorToObjectSpace(moveDirection)
        Head.CFrame = CFrame.new(headPosition) * (cameraCFrame - cameraPosition) * CFrame.new(objectSpaceVelocity)
    end)
end)

addcmd('uncframefly', {'uncfly'}, function(args, speaker)
    if CFloop then
        CFloop:Disconnect()
        speaker.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
        local Head = speaker.Character:WaitForChild("Head")
        Head.Anchored = false
    end
end)

addcmd('cframeflyspeed', {'cflyspeed'}, function(args, speaker)
    if isNumber(args[1]) then
        CFspeed = args[1]
    end
end)

Floating = false
floatName = randomString()
addcmd('float', {'platform'}, function(args, speaker)
    Floating = true
    local pchar = speaker.Character
    if pchar and not pchar:FindFirstChild(floatName) then
        task.spawn(function()
            local Float = Instance.new('Part')
            Float.Name = floatName
            Float.Parent = pchar
            Float.Transparency = 1
            Float.Size = Vector3.new(2, 0.2, 1.5)
            Float.Anchored = true
            local FloatValue = -3.1
            Float.CFrame = getRoot(pchar).CFrame * CFrame.new(0, FloatValue, 0)
            notify('Float', 'Float Enabled (Q = down & E = up)')

            local function handleKey(KEY, delta)
                if KEY == 'q' then
                    FloatValue = FloatValue + delta
                elseif KEY == 'e' then
                    FloatValue = FloatValue - delta
                end
            end

            qUp = IYMouse.KeyUp:Connect(function(KEY) handleKey(KEY, 0.5) end)
            eUp = IYMouse.KeyUp:Connect(function(KEY) handleKey(KEY, -1.5) end)
            qDown = IYMouse.KeyDown:Connect(function(KEY) handleKey(KEY, -0.5) end)
            eDown = IYMouse.KeyDown:Connect(function(KEY) handleKey(KEY, 1.5) end)

            floatDied = speaker.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                Floating = false
                Float:Destroy()
                qUp:Disconnect()
                eUp:Disconnect()
                qDown:Disconnect()
                eDown:Disconnect()
                floatDied:Disconnect()
            end)

            local function FloatPadLoop()
                if pchar:FindFirstChild(floatName) and getRoot(pchar) then
                    Float.CFrame = getRoot(pchar).CFrame * CFrame.new(0, FloatValue, 0)
                else
                    Floating = false
                    Float:Destroy()
                    qUp:Disconnect()
                    eUp:Disconnect()
                    qDown:Disconnect()
                    eDown:Disconnect()
                    floatDied:Disconnect()
                end
            end

            FloatingFunc = RunService.Heartbeat:Connect(FloatPadLoop)
        end)
    end
end)

addcmd('unfloat', {'nofloat', 'unplatform', 'noplatform'}, function(args, speaker)
    Floating = false
    local pchar = speaker.Character
    notify('Float', 'Float Disabled')
    if pchar:FindFirstChild(floatName) then
        pchar:FindFirstChild(floatName):Destroy()
    end
    if floatDied then
        FloatingFunc:Disconnect()
        qUp:Disconnect()
        eUp:Disconnect()
        qDown:Disconnect()
        eDown:Disconnect()
        floatDied:Disconnect()
    end
end)

addcmd('togglefloat', {}, function(args, speaker)
    if Floating then
        execCmd('unfloat')
    else
        execCmd('float')
    end
end)

swimming = false
local oldgrav = workspace.Gravity
local swimbeat = nil
addcmd('swim', {}, function(args, speaker)
    if not swimming and speaker and speaker.Character and speaker.Character:FindFirstChildWhichIsA("Humanoid") then
        oldgrav = workspace.Gravity
        workspace.Gravity = 0
        local swimDied = function()
            workspace.Gravity = oldgrav
            swimming = false
        end
        local Humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
        gravReset = Humanoid.Died:Connect(swimDied)
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for _, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, false)
        end
        Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
        swimbeat = RunService.Heartbeat:Connect(function()
            pcall(function()
                speaker.Character.HumanoidRootPart.Velocity = ((Humanoid.MoveDirection ~= Vector3.new() or UserInputService:IsKeyDown(Enum.KeyCode.Space)) and speaker.Character.HumanoidRootPart.Velocity or Vector3.new())
            end)
        end)
        swimming = true
    end
end)

addcmd('unswim', {'noswim'}, function(args, speaker)
    if speaker and speaker.Character and speaker.Character:FindFirstChildWhichIsA("Humanoid") then
        workspace.Gravity = oldgrav
        swimming = false
        if gravReset then gravReset:Disconnect() end
        if swimbeat then swimbeat:Disconnect() end
        local Humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for _, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, true)
        end
    end
end)

addcmd('toggleswim', {}, function(args, speaker)
    if swimming then
        execCmd('unswim')
    else
        execCmd('swim')
    end
end)

addcmd('setwaypoint', {'swp', 'setwp', 'spos', 'saveposition', 'savepos'}, function(args, speaker)
    local WPName = tostring(getstring(1))
    if getRoot(speaker.Character) then
        notify('Modified Waypoints', "Created waypoint: " .. getstring(1))
        local torso = getRoot(speaker.Character)
        WayPoints[#WayPoints + 1] = {NAME = WPName, COORD = {math.floor(torso.Position.X), math.floor(torso.Position.Y), math.floor(torso.Position.Z)}, GAME = PlaceId}
        if AllWaypoints ~= nil then
            AllWaypoints[#AllWaypoints + 1] = {NAME = WPName, COORD = {math.floor(torso.Position.X), math.floor(torso.Position.Y), math.floor(torso.Position.Z)}, GAME = PlaceId}
        end
    end
    refreshwaypoints()
    updatesaves()
end)

addcmd('waypointpos', {'wpp', 'setwaypointposition', 'setpos', 'setwaypoint', 'setwaypointpos'}, function(args, speaker)
    local WPName = tostring(getstring(1))
    if getRoot(speaker.Character) then
        notify('Modified Waypoints', "Created waypoint: " .. getstring(1))
        WayPoints[#WayPoints + 1] = {NAME = WPName, COORD = {args[2], args[3], args[4]}, GAME = PlaceId}
        if AllWaypoints ~= nil then
            AllWaypoints[#AllWaypoints + 1] = {NAME = WPName, COORD = {args[2], args[3], args[4]}, GAME = PlaceId}
        end
    end
    refreshwaypoints()
    updatesaves()
end)

addcmd('waypoints', {'positions'}, function(args, speaker)
    if not SettingsOpen then
        SettingsOpen = true
        Settings:TweenPosition(UDim2.new(0, 0, 0, 45), "InOut", "Quart", 0.5, true, nil)
        CMDsF.Visible = false
    end
    KeybindsFrame:TweenPosition(UDim2.new(0, 0, 0, 175), "InOut", "Quart", 0.5, true, nil)
    AliasesFrame:TweenPosition(UDim2.new(0, 0, 0, 175), "InOut", "Quart", 0.5, true, nil)
    PluginsFrame:TweenPosition(UDim2.new(0, 0, 0, 175), "InOut", "Quart", 0.5, true, nil)
    PositionsFrame:TweenPosition(UDim2.new(0, 0, 0, 0), "InOut", "Quart", 0.5, true, nil)
    wait(0.5)
    SettingsHolder.Visible = false
    maximizeHolder()
end)

waypointParts = {}
addcmd('showwaypoints', {'showwp', 'showwps'}, function(args, speaker)
    execCmd('hidewaypoints')
    wait()
    for _, wp in pairs(WayPoints) do
        local x, y, z = wp.COORD[1], wp.COORD[2], wp.COORD[3]
        local part = Instance.new("Part")
        part.Size = Vector3.new(5, 5, 5)
        part.CFrame = CFrame.new(x, y, z)
        part.Parent = workspace
        part.Anchored = true
        part.CanCollide = false
        table.insert(waypointParts, part)
        local view = Instance.new("BoxHandleAdornment")
        view.Adornee = part
        view.AlwaysOnTop = true
        view.ZIndex = 10
        view.Size = part.Size
        view.Parent = part
    end
    for _, wp in pairs(pWayPoints) do
        local view = Instance.new("BoxHandleAdornment")
        view.Adornee = wp.COORD[1]
        view.AlwaysOnTop = true
        view.ZIndex = 10
        view.Size = wp.COORD[1].Size
        view.Parent = wp.COORD[1]
        table.insert(waypointParts, view)
    end
end)

addcmd('hidewaypoints', {'hidewp', 'hidewps'}, function(args, speaker)
    for i, v in pairs(waypointParts) do
        v:Destroy()
    end
    waypointParts = {}
end)

addcmd('waypoint', {'wp', 'lpos', 'loadposition', 'loadpos'}, function(args, speaker)
    local WPName = tostring(getstring(1))
    if speaker.Character then
        for i, _ in pairs(WayPoints) do
            if tostring(WayPoints[i].NAME):lower() == WPName:lower() then
                local x, y, z = WayPoints[i].COORD[1], WayPoints[i].COORD[2], WayPoints[i].COORD[3]
                getRoot(speaker.Character).CFrame = CFrame.new(x, y, z)
            end
        end
        for i, _ in pairs(pWayPoints) do
            if tostring(pWayPoints[i].NAME):lower() == WPName:lower() then
                getRoot(speaker.Character).CFrame = CFrame.new(pWayPoints[i].COORD[1].Position)
            end
        end
    end
end)

addcmd('tweenspeed', {'tspeed'}, function(args, speaker)
    local newSpeed = args[1] or 1
    if tonumber(newSpeed) then
        tweenSpeed = tonumber(newSpeed)
    end
end)

addcmd('tweenwaypoint', {'twp'}, function(args, speaker)
    local WPName = tostring(getstring(1))
    if speaker.Character then
        for i, _ in pairs(WayPoints) do
            if tostring(WayPoints[i].NAME):lower() == WPName:lower() then
                local x, y, z = WayPoints[i].COORD[1], WayPoints[i].COORD[2], WayPoints[i].COORD[3]
                TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = CFrame.new(x, y, z)}):Play()
            end
        end
        for i, _ in pairs(pWayPoints) do
            if tostring(pWayPoints[i].NAME):lower() == WPName:lower() then
                TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = CFrame.new(pWayPoints[i].COORD[1].Position)}):Play()
            end
        end
    end
end)

addcmd('walktowaypoint', {'wtwp'}, function(args, speaker)
    local WPName = tostring(getstring(1))
    if speaker.Character then
        for i, _ in pairs(WayPoints) do
            if tostring(WayPoints[i].NAME):lower() == WPName:lower() then
                local x, y, z = WayPoints[i].COORD[1], WayPoints[i].COORD[2], WayPoints[i].COORD[3]
                if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                    speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                    wait(.1)
                end
                speaker.Character:FindFirstChildOfClass('Humanoid').WalkToPoint = Vector3.new(x, y, z)
            end
        end
        for i, _ in pairs(pWayPoints) do
            if tostring(pWayPoints[i].NAME):lower() == WPName:lower() then
                if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                    speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                    wait(.1)
                end
                speaker.Character:FindFirstChildOfClass('Humanoid').WalkToPoint = Vector3.new(pWayPoints[i].COORD[1].Position)
            end
        end
    end
end)

addcmd('deletewaypoint', {'dwp', 'dpos', 'deleteposition', 'deletepos'}, function(args, speaker)
    local WPName = tostring(getstring(1)):lower()
    for i, v in pairs(WayPoints) do
        if v.NAME:lower() == WPName then
            notify('Modified Waypoints', "Deleted waypoint: " .. v.NAME)
            table.remove(WayPoints, i)
        end
    end
    if AllWaypoints ~= nil and #AllWaypoints > 0 then
        for i, v in pairs(AllWaypoints) do
            if v.NAME:lower() == WPName then
                if not v.GAME or v.GAME == PlaceId then
                    table.remove(AllWaypoints, i)
                end
            end
        end
    end
    for i, v in pairs(pWayPoints) do
        if v.NAME:lower() == WPName then
            notify('Modified Waypoints', "Deleted waypoint: " .. v.NAME)
            table.remove(pWayPoints, i)
        end
    end
    refreshwaypoints()
    updatesaves()
end)

addcmd('clearwaypoints', {'cwp', 'clearpositions', 'cpos', 'clearpos'}, function(args, speaker)
    WayPoints = {}
    pWayPoints = {}
    refreshwaypoints()
    updatesaves()
    AllWaypoints = {}
    notify('Modified Waypoints', 'Removed all waypoints')
end)

addcmd('cleargamewaypoints', {'cgamewp'}, function(args, speaker)
    for i, v in pairs(WayPoints) do
        if v.GAME == PlaceId then
            table.remove(WayPoints, i)
        end
    end
    if AllWaypoints ~= nil and #AllWaypoints > 0 then
        for i, v in pairs(AllWaypoints) do
            if v.GAME == PlaceId then
                table.remove(AllWaypoints, i)
            end
        end
    end
    for i, v in pairs(pWayPoints) do
        if v.GAME == PlaceId then
            table.remove(pWayPoints, i)
        end
    end
    refreshwaypoints()
    updatesaves()
    notify('Modified Waypoints', 'Deleted game waypoints')
end)

addcmd('enable', {}, function(args, speaker)
    local input = args[1] and args[1]:lower()
    if input then
        if input == "reset" then
            StarterGui:SetCore("ResetButtonCallback", true)
        else
            local coreGuiType = coreGuiTypeNames[input]
            if coreGuiType then
                StarterGui:SetCoreGuiEnabled(coreGuiType, true)
            end
        end
    end
end)

addcmd('disable', {}, function(args, speaker)
    local input = args[1] and args[1]:lower()
    if input then
        if input == "reset" then
            StarterGui:SetCore("ResetButtonCallback", false)
        else
            local coreGuiType = coreGuiTypeNames[input]
            if coreGuiType then
                StarterGui:SetCoreGuiEnabled(coreGuiType, false)
            end
        end
    end
end)

addcmd('antilag', {'boostfps', 'lowgraphics'}, function(args, speaker)
    local Terrain = workspace:FindFirstChildOfClass('Terrain')
    Terrain.WaterWaveSize = 0
    Terrain.WaterWaveSpeed = 0
    Terrain.WaterReflectance = 0
    Terrain.WaterTransparency = 0
    Lighting.GlobalShadows = false
    Lighting.FogEnd = 9e9
    settings().Rendering.QualityLevel = 1
    for _, v in pairs(game:GetDescendants()) do
        if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("MeshPart") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
            v.Material = "Plastic"
            v.Reflectance = 0
        elseif v:IsA("Decal") then
            v.Transparency = 1
        elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
            v.Lifetime = NumberRange.new(0)
        elseif v:IsA("Explosion") then
            v.BlastPressure = 1
            v.BlastRadius = 1
        end
    end
    for _, v in pairs(Lighting:GetDescendants()) do
        if v:IsA("BlurEffect") or v:IsA("SunRaysEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("BloomEffect") or v:IsA("DepthOfFieldEffect") then
            v.Enabled = false
        end
    end
    workspace.DescendantAdded:Connect(function(child)
        task.spawn(function()
            if child:IsA('ForceField') or child:IsA('Sparkles') or child:IsA('Smoke') or child:IsA('Fire') then
                RunService.Heartbeat:Wait()
                child:Destroy()
            end
        end)
    end)
end)

addcmd("setfpscap", {"fpscap", "maxfps"}, function(args, speaker)
    if fpscaploop then
        task.cancel(fpscaploop)
        fpscaploop = nil
    end

    local fpsCap = 60
    local num = tonumber(args[1]) or 1e6
    if num == "none" then
        return
    elseif num > 0 then
        fpsCap = num
    else
        return notify("Invalid argument", "Please provide a number above 0 or 'none'.")
    end

    if setfpscap and type(setfpscap) == "function" then
        setfpscap(fpsCap)
    else
        fpscaploop = task.spawn(function()
            local timer = os.clock()
            while true do
                if os.clock() >= timer + 1 / fpsCap then
                    timer = os.clock()
                    task.wait()
                end
            end
        end)
    end
end)

addcmd('notify', {}, function(args, speaker)
    notify(getstring(1))
end)

addcmd('lastcommand', {'lastcmd'}, function(args, speaker)
    if cmdHistory[1]:sub(1, 11) ~= 'lastcommand' and cmdHistory[1]:sub(1, 7) ~= 'lastcmd' then
        execCmd(cmdHistory[1])
    end
end)

addcmd('goto', {'to'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        if Players[v].Character ~= nil then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            getRoot(speaker.Character).CFrame = getRoot(Players[v].Character).CFrame + Vector3.new(3, 1, 0)
        end
    end
    execCmd('breakvelocity')
end)

addcmd('tweengoto', {'tgoto', 'tto', 'tweento'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        if Players[v].Character ~= nil then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = getRoot(Players[v].Character).CFrame + Vector3.new(3, 1, 0)}):Play()
        end
    end
    execCmd('breakvelocity')
end)

addcmd('vehiclegoto', {'vgoto', 'vtp', 'vehicletp'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        if Players[v].Character ~= nil then
            local seat = speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart
            local vehicleModel = seat:FindFirstAncestorWhichIsA("Model")
            vehicleModel:MoveTo(getRoot(Players[v].Character).Position)
        end
    end
end)

addcmd('vehiclenoclip', {'vnoclip'}, function(args, speaker)
    vnoclipParts = {}
    local seat = speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart
    local vehicleModel = seat.Parent
    repeat
        if vehicleModel.ClassName ~= "Model" then
            vehicleModel = vehicleModel.Parent
        end
    until vehicleModel.ClassName == "Model"
    wait(0.1)
    execCmd('noclip')
    for _, v in pairs(vehicleModel:GetDescendants()) do
        if v:IsA("BasePart") and v.CanCollide then
            table.insert(vnoclipParts, v)
            v.CanCollide = false
        end
    end
end)

addcmd("vehicleclip", {"vclip", "unvnoclip", "unvehiclenoclip"}, function(args, speaker)
    execCmd("clip")
    for _, v in pairs(vnoclipParts) do
        v.CanCollide = true
    end
    vnoclipParts = {}
end)

addcmd("togglevnoclip", {}, function(args, speaker)
    execCmd(Clip and "vnoclip" or "vclip")
end)

addcmd('age', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    local ages = {}
    for _, v in pairs(players) do
        local p = Players[v]
        table.insert(ages, p.Name .. "'s age is: " .. p.AccountAge)
    end
    notify('Account Age', table.concat(ages, ',\n'))
end)

addcmd('chatage', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    local ages = {}
    for _, v in pairs(players) do
        local p = Players[v]
        table.insert(ages, p.Name .. "'s age is: " .. p.AccountAge)
    end
    local chatString = table.concat(ages, ', ')
    chatMessage(chatString)
end)

addcmd('joindate', {'jd'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    local dates = {}
    notify("Loading", 'Hold on a sec')
    for _, v in pairs(players) do
        local user = game:HttpGet("https://users.roblox.com/v1/users/" .. Players[v].UserId)
        local json = HttpService:JSONDecode(user)
        local date = json["created"]:sub(1, 10)
        local splitDates = string.split(date, "-")
        table.insert(dates, Players[v].Name .. " joined: " .. splitDates[2] .. "/" .. splitDates[3] .. "/" .. splitDates[1])
    end
    notify('Join Date (Month/Day/Year)', table.concat(dates, ',\n'))
end)

addcmd('chatjoindate', {'cjd'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    local dates = {}
    notify("Loading", 'Hold on a sec')
    for _, v in pairs(players) do
        local user = game:HttpGet("https://users.roblox.com/v1/users/" .. Players[v].UserId)
        local json = HttpService:JSONDecode(user)
        local date = json["created"]:sub(1, 10)
        local splitDates = string.split(date, "-")
        table.insert(dates, Players[v].Name .. " joined: " .. splitDates[2] .. "/" .. splitDates[3] .. "/" .. splitDates[1])
    end
    local chatString = table.concat(dates, ', ')
    chatMessage(chatString)
end)

addcmd('copyname', {'copyuser'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        local name = tostring(Players[v].Name)
        toClipboard(name)
    end
end)

addcmd('userid', {'id'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        local id = tostring(Players[v].UserId)
        notify('User ID', id)
    end
end)

addcmd('copyid', {'copyuserid'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        local id = tostring(Players[v].UserId)
        toClipboard(id)
    end
end)

addcmd('creatorid', {'creator'}, function(args, speaker)
    if game.CreatorType == Enum.CreatorType.User then
        notify('Creator ID', game.CreatorId)
    elseif game.CreatorType == Enum.CreatorType.Group then
        local OwnerID = GroupService:GetGroupInfoAsync(game.CreatorId).Owner.Id
        speaker.UserId = OwnerID
        notify('Creator ID', OwnerID)
    end
end)

addcmd('copycreatorid', {'copycreator'}, function(args, speaker)
    if game.CreatorType == Enum.CreatorType.User then
        toClipboard(game.CreatorId)
        notify('Copied ID', 'Copied creator ID to clipboard')
    elseif game.CreatorType == Enum.CreatorType.Group then
        local OwnerID = GroupService:GetGroupInfoAsync(game.CreatorId).Owner.Id
        toClipboard(OwnerID)
        notify('Copied ID', 'Copied creator ID to clipboard')
    end
end)

addcmd('setcreatorid', {'setcreator'}, function(args, speaker)
    if game.CreatorType == Enum.CreatorType.User then
        speaker.UserId = game.CreatorId
        notify('Set ID', 'Set UserId to ' .. game.CreatorId)
    elseif game.CreatorType == Enum.CreatorType.Group then
        local OwnerID = GroupService:GetGroupInfoAsync(game.CreatorId).Owner.Id
        speaker.UserId = OwnerID
        notify('Set ID', 'Set UserId to ' .. OwnerID)
    end
end)

addcmd('appearanceid', {'aid'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        local aid = tostring(Players[v].CharacterAppearanceId)
        notify('Appearance ID', aid)
    end
end)

addcmd('copyappearanceid', {'caid'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        local aid = tostring(Players[v].CharacterAppearanceId)
        toClipboard(aid)
    end
end)

addcmd('norender', {}, function(args, speaker)
    RunService:Set3dRenderingEnabled(false)
end)
addcmd('render', {}, function(args, speaker)
    RunService:Set3dRenderingEnabled(true)
end)

addcmd('2022materials', {'use2022materials'}, function(args, speaker)
    if sethidden then
        sethidden(MaterialService, "Use2022Materials", true)
    else
        notify('Incompatible Exploit', 'Your exploit does not support this command (missing sethiddenproperty)')
    end
end)

addcmd('un2022materials', {'unuse2022materials'}, function(args, speaker)
    if sethidden then
        sethidden(MaterialService, "Use2022Materials", false)
    else
        notify('Incompatible Exploit', 'Your exploit does not support this command (missing sethiddenproperty)')
    end
end)

addcmd('antiafk', {'antiidle'}, function(args, speaker)
    local GC = getconnections or get_signal_cons
    if GC then
        for _, v in pairs(GC(Players.LocalPlayer.Idled)) do
            if v["Disable"] then
                v["Disable"](v)
            elseif v["Disconnect"] then
                v["Disconnect"](v)
            end
        end
    else
        local VirtualUser = cloneref(game:GetService("VirtualUser"))
        Players.LocalPlayer.Idled:Connect(function()
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
    if not (args[1] and tostring(args[1]) == 'nonotify') then notify('Anti Idle', 'Anti idle is enabled') end
end)

addcmd("datalimit", {}, function(args, speaker)
    if tonumber(args[1]) then
        NetworkClient:SetOutgoingKBPSLimit(args[1])
    end
end)

addcmd("replicationlag", {"backtrack"}, function(args, speaker)
    if tonumber(args[1]) then
        settings():GetService("NetworkSettings").IncomingReplicationLag = args[1]
    end
end)

addcmd("noprompts", {"nopurchaseprompts"}, function(args, speaker)
    COREGUI.PurchasePrompt.Enabled = false
end)

addcmd("showprompts", {"showpurchaseprompts"}, function(args, speaker)
    COREGUI.PurchasePrompt.Enabled = true
end)

addcmd("promptr6", {}, function(args, speaker)
    promptNewRig(speaker, "R6")
end)

addcmd("promptr15", {}, function(args, speaker)
    promptNewRig(speaker, "R15")
end)

addcmd("wallwalk", {"walkonwalls"}, function(args, speaker)
    loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/wallwalker.lua"))()
end)

local bringT = {}

addcmd('loopbring', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        task.spawn(function()
            if Players[v].Name ~= speaker.Name and not FindInTable(bringT, Players[v].Name) then
                table.insert(bringT, Players[v].Name)
                local plrName = Players[v].Name
                local pchar = Players[v].Character
                local distance = args[2] and tonumber(args[2]) or 3
                local lDelay = args[3] and tonumber(args[3]) or 0
                repeat
                    if Players:FindFirstChild(v) then
                        pchar = Players[v].Character
                        if pchar and getRoot(pchar) and speaker.Character and getRoot(speaker.Character) then
                            getRoot(pchar).CFrame = getRoot(speaker.Character).CFrame + Vector3.new(distance, 1, 0)
                        end
                        wait(lDelay)
                    else
                        for a, b in pairs(bringT) do
                            if b == plrName then
                                table.remove(bringT, a)
                            end
                        end
                    end
                until not FindInTable(bringT, plrName)
            end
        end)
    end
end)

addcmd('unloopbring', {'noloopbring'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        task.spawn(function()
            for a, b in pairs(bringT) do
                if b == Players[v].Name then
                    table.remove(bringT, a)
                end
            end
        end)
    end
end)

local walkto = false
local waypointwalkto = false

addcmd('walkto', {'follow'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        if Players[v].Character then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            walkto = true
            repeat
                wait()
                speaker.Character:FindFirstChildOfClass('Humanoid'):MoveTo(getRoot(Players[v].Character).Position)
            until not Players[v].Character or not getRoot(Players[v].Character) or not walkto
        end
    end
end)

addcmd('pathfindwalkto', {'pathfindfollow'}, function(args, speaker)
    walkto = false
    wait()
    local players = getPlayer(args[1], speaker)
    local hum = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    local path = PathService:CreatePath()
    for _, v in pairs(players) do
        if Players[v].Character then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            walkto = true
            repeat
                wait()
                local success, response = pcall(function()
                    path:ComputeAsync(getRoot(speaker.Character).Position, getRoot(Players[v].Character).Position)
                    local waypoints = path:GetWaypoints()
                    local distance
                    for _, waypoint in pairs(waypoints) do
                        local waypointPosition = waypoint.Position
                        hum:MoveTo(waypointPosition)
                        repeat
                            distance = (waypointPosition - hum.Parent.PrimaryPart.Position).magnitude
                            wait()
                        until distance <= 5
                    end
                end)
                if not success then
                    speaker.Character:FindFirstChildOfClass('Humanoid'):MoveTo(getRoot(Players[v].Character).Position)
                end
            until not Players[v].Character or not getRoot(Players[v].Character) or not walkto
        end
    end
end)

addcmd('pathfindwalktowaypoint', {'pathfindwalktowp'}, function(args, speaker)
    waypointwalkto = false
    wait()
    local WPName = tostring(getstring(1))
    local hum = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    local path = PathService:CreatePath()
    if speaker.Character then
        for _, waypoint in pairs(WayPoints) do
            if tostring(waypoint.NAME):lower() == WPName:lower() then
                if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                    speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                    wait(.1)
                end
                local TrueCoords = Vector3.new(waypoint.COORD[1], waypoint.COORD[2], waypoint.COORD[3])
                waypointwalkto = true
                repeat
                    wait()
                    local success, response = pcall(function()
                        path:ComputeAsync(getRoot(speaker.Character).Position, TrueCoords)
                        local waypoints = path:GetWaypoints()
                        local distance
                        for _, waypoint in pairs(waypoints) do
                            local waypointPosition = waypoint.Position
                            hum:MoveTo(waypointPosition)
                            repeat
                                distance = (waypointPosition - hum.Parent.PrimaryPart.Position).magnitude
                                wait()
                            until distance <= 5
                        end
                    end)
                    if not success then
                        speaker.Character:FindFirstChildOfClass('Humanoid'):MoveTo(TrueCoords)
                    end
                until not speaker.Character or not waypointwalkto
            end
        end
        for _, waypoint in pairs(pWayPoints) do
            if tostring(waypoint.NAME):lower() == WPName:lower() then
                if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                    speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                    wait(.1)
                end
                local TrueCoords = waypoint.COORD[1].Position
                waypointwalkto = true
                repeat
                    wait()
                    local success, response = pcall(function()
                        path:ComputeAsync(getRoot(speaker.Character).Position, TrueCoords)
                        local waypoints = path:GetWaypoints()
                        local distance
                        for _, waypoint in pairs(waypoints) do
                            local waypointPosition = waypoint.Position
                            hum:MoveTo(waypointPosition)
                            repeat
                                distance = (waypointPosition - hum.Parent.PrimaryPart.Position).magnitude
                                wait()
                            until distance <= 5
                        end
                    end)
                    if not success then
                        speaker.Character:FindFirstChildOfClass('Humanoid'):MoveTo(TrueCoords)
                    end
                until not speaker.Character or not waypointwalkto
            end
        end
    end
end)

addcmd('unwalkto', {'nowalkto', 'unfollow', 'nofollow'}, function(args, speaker)
    walkto = false
    waypointwalkto = false
end)

addcmd("orbit", {}, function(args, speaker)
    execCmd("unorbit nonotify")
    local target = Players:FindFirstChild(getPlayer(args[1], speaker)[1])
    local root = getRoot(speaker.Character)
    local humanoid = speaker.Character:FindFirstChildOfClass("Humanoid")
    if target and target.Character and getRoot(target.Character) and root and humanoid then
        local rotation = 0
        local speed = tonumber(args[2]) or 0.2
        local distance = tonumber(args[3]) or 6
        orbit1 = RunService.Heartbeat:Connect(function()
            pcall(function()
                rotation = rotation + speed
                root.CFrame = CFrame.new(getRoot(target.Character).Position) * CFrame.Angles(0, math.rad(rotation), 0) * CFrame.new(distance, 0, 0)
            end)
        end)
        orbit2 = RunService.RenderStepped:Connect(function()
            pcall(function()
                root.CFrame = CFrame.new(root.Position, getRoot(target.Character).Position)
            end)
        end)
        orbit3 = humanoid.Died:Connect(function() execCmd("unorbit") end)
        orbit4 = humanoid.Seated:Connect(function(value) if value then execCmd("unorbit") end end)
        notify("Orbit", "Started orbiting " .. formatUsername(target))
    end
end)

addcmd("unorbit", {}, function(args, speaker)
    if orbit1 then orbit1:Disconnect() end
    if orbit2 then orbit2:Disconnect() end
    if orbit3 then orbit3:Disconnect() end
    if orbit4 then orbit4:Disconnect() end
    if args[1] ~= "nonotify" then notify("Orbit", "Stopped orbiting player") end
end)

addcmd('freeze', {'fr'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    if players then
        for _, v in pairs(players) do
            task.spawn(function()
                for _, x in pairs(Players[v].Character:GetDescendants()) do
                    if x:IsA("BasePart") and not x.Anchored then
                        x.Anchored = true
                    end
                end
            end)
        end
    end
end)

addcmd('thaw', {'unfreeze', 'unfr'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    if players then
        for _, v in pairs(players) do
            task.spawn(function()
                for _, x in pairs(Players[v].Character:GetDescendants()) do
                    if x.Name ~= floatName and x:IsA("BasePart") and x.Anchored then
                        x.Anchored = false
                    end
                end
            end)
        end
    end
end)

local oofing = false

addcmd('loopoof', {}, function(args, speaker)
    oofing = true
    repeat
        wait(0.1)
        for _, v in pairs(Players:GetPlayers()) do
            if v.Character and v.Character:FindFirstChild('Head') then
                for _, x in pairs(v.Character.Head:GetChildren()) do
                    if x:IsA('Sound') then
                        x.Playing = true
                    end
                end
            end
        end
    until not oofing
end)

addcmd('unloopoof', {}, function(args, speaker)
    oofing = false
end)

local notifiedRespectFiltering = false

addcmd('muteboombox', {}, function(args, speaker)
    if not notifiedRespectFiltering and SoundService.RespectFilteringEnabled then
        notifiedRespectFiltering = true
        notify('RespectFilteringEnabled', 'RespectFilteringEnabled is set to true (the command will still work but may only be clientsided)')
    end
    local players = getPlayer(args[1], speaker)
    if players then
        for _, v in pairs(players) do
            task.spawn(function()
                for _, x in pairs(Players[v].Character:GetDescendants()) do
                    if x:IsA("Sound") and x.Playing then
                        x.Playing = false
                    end
                end
                for _, x in pairs(Players[v]:FindFirstChildOfClass("Backpack"):GetDescendants()) do
                    if x:IsA("Sound") and x.Playing then
                        x.Playing = false
                    end
                end
            end)
        end
    end
end)

addcmd('unmuteboombox', {}, function(args, speaker)
    if not notifiedRespectFiltering and SoundService.RespectFilteringEnabled then
        notifiedRespectFiltering = true
        notify('RespectFilteringEnabled', 'RespectFilteringEnabled is set to true (the command will still work but may only be clientsided)')
    end
    local players = getPlayer(args[1], speaker)
    if players then
        for _, v in pairs(players) do
            task.spawn(function()
                for _, x in pairs(Players[v].Character:GetDescendants()) do
                    if x:IsA("Sound") and not x.Playing then
                        x.Playing = true
                    end
                end
            end)
        end
    end
end)

addcmd('reset', {}, function(args, speaker)
    speaker.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Dead)
end)

addcmd('freezeanims', {}, function(args, speaker)
    local Humanoid = speaker.Character:FindFirstChildOfClass("Humanoid") or speaker.Character:FindFirstChildOfClass("AnimationController")
    local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
    for _, v in pairs(ActiveTracks) do
        v:AdjustSpeed(0)
    end
end)

addcmd('unfreezeanims', {}, function(args, speaker)
    local Humanoid = speaker.Character:FindFirstChildOfClass("Humanoid") or speaker.Character:FindFirstChildOfClass("AnimationController")
    local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
    for _, v in pairs(ActiveTracks) do
        v:AdjustSpeed(1)
    end
end)

addcmd('respawn', {}, function(args, speaker)
    respawn(speaker)
end)

addcmd('refresh', {'re'}, function(args, speaker)
    refresh(speaker)
end)

addcmd('god', {}, function(args, speaker)
    local Cam = workspace.CurrentCamera
    local Pos, Char = Cam.CFrame, speaker.Character
    local Human = Char and Char:FindFirstChildOfClass("Humanoid")
    local nHuman = Human:Clone()
    nHuman.Parent, speaker.Character = Char, nil
    nHuman:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
    nHuman:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
    nHuman:SetStateEnabled(Enum.HumanoidStateType.Physics, false)
    nHuman.BreakJointsOnDeath, Human = true, Human:Destroy()
    speaker.Character, Cam.CameraSubject, Cam.CFrame = Char, nHuman, wait() and Pos
    nHuman.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
    local Script = Char:FindFirstChild("Animate")
    if Script then
        Script.Disabled = true
        wait()
        Script.Disabled = false
    end
    nHuman.Health = nHuman.MaxHealth
end)

addcmd('nobgui', {'unbgui', 'nobillboardgui', 'unbillboardgui', 'noname', 'rohg'}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
            v:Destroy()
        end
    end
end)

addcmd('loopnobgui', {'loopunbgui', 'loopnobillboardgui', 'loopunbillboardgui', 'loopnoname', 'looprohg'}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
            v:Destroy()
        end
    end
    local function charPartAdded(part)
        if part:IsA("BillboardGui") or part:IsA("SurfaceGui") then
            wait()
            part:Destroy()
        end
    end
    charPartTrigger = speaker.Character.DescendantAdded:Connect(charPartAdded)
end)

addcmd('unloopnobgui', {'unloopunbgui', 'unloopnobillboardgui', 'unloopunbillboardgui', 'unloopnoname', 'unlooprohg'}, function(args, speaker)
    if charPartTrigger then
        charPartTrigger:Disconnect()
    end
end)

addcmd('spasm', {}, function(args, speaker)
    if not r15(speaker) then
        local pchar = speaker.Character
        local AnimationId = "33796059"
        SpasmAnim = Instance.new("Animation")
        SpasmAnim.AnimationId = "rbxassetid://" .. AnimationId
        Spasm = pchar:FindFirstChildOfClass('Humanoid'):LoadAnimation(SpasmAnim)
        Spasm:Play()
        Spasm:AdjustSpeed(99)
    else
        notify('R6 Required', 'This command requires the r6 rig type')
    end
end)

addcmd('unspasm', {'nospasm'}, function(args, speaker)
    Spasm:Stop()
    SpasmAnim:Destroy()
end)

addcmd('headthrow', {}, function(args, speaker)
    if not r15(speaker) then
        local AnimationId = "35154961"
        local Anim = Instance.new("Animation")
        Anim.AnimationId = "rbxassetid://" .. AnimationId
        local k = speaker.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(Anim)
        k:Play(0)
        k:AdjustSpeed(1)
    else
        notify('R6 Required', 'This command requires the r6 rig type')
    end
end)

addcmd('animation', {'anim'}, function(args, speaker)
    if not r15(speaker) then
        local pchar = speaker.Character
        local AnimationId = tostring(args[1])
        local Anim = Instance.new("Animation")
        Anim.AnimationId = "rbxassetid://" .. AnimationId
        local k = pchar:FindFirstChildOfClass('Humanoid'):LoadAnimation(Anim)
        k:Play()
        if args[2] then
            k:AdjustSpeed(tostring(args[2]))
        end
    else
        notify('R6 Required', 'This command requires the r6 rig type')
    end
end)

addcmd('noanim', {}, function(args, speaker)
    speaker.Character.Animate.Disabled = true
end)

addcmd('reanim', {}, function(args, speaker)
    speaker.Character.Animate.Disabled = false
end)

addcmd('animspeed', {}, function(args, speaker)
    local Char = speaker.Character
    local Hum = Char:FindFirstChildOfClass("Humanoid") or Char:FindFirstChildOfClass("AnimationController")
    for _, v in pairs(Hum:GetPlayingAnimationTracks()) do
        v:AdjustSpeed(tonumber(args[1] or 1))
    end
end)

addcmd('copyanimation', {'copyanim', 'copyemote'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in ipairs(players) do
        local char = Players[v].Character
        for _, v1 in pairs(speaker.Character:FindFirstChildOfClass('Humanoid'):GetPlayingAnimationTracks()) do
            v1:Stop()
        end
        for _, v1 in pairs(Players[v].Character:FindFirstChildOfClass('Humanoid'):GetPlayingAnimationTracks()) do
            if not string.find(v1.Animation.AnimationId, "507768375") then
                local ANIM = speaker.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(v1.Animation)
                ANIM:Play(.1, 1, v1.Speed)
                ANIM.TimePosition = v1.TimePosition
                task.spawn(function()
                    v1.Stopped:Wait()
                    ANIM:Stop()
                    ANIM:Destroy()
                end)
            end
        end
    end
end)

addcmd("copyanimationid", {"copyanimid", "copyemoteid"}, function(args, speaker)
    local copyAnimId = function(player)
        local found = "Animations Copied"
        for _, v in pairs(player.Character:FindFirstChildWhichIsA("Humanoid"):GetPlayingAnimationTracks()) do
            local animationId = v.Animation.AnimationId
            local assetId = animationId:find("rbxassetid://") and animationId:match("%d+")
            if not string.find(animationId, "507768375") and not string.find(animationId, "180435571") then
                if assetId then
                    local success, result = pcall(function()
                        return MarketplaceService:GetProductInfo(tonumber(assetId)).Name
                    end)
                    local name = success and result or "Failed to get name"
                    found = found .. "\n\nName: " .. name .. "\nAnimation Id: " .. animationId
                else
                    found = found .. "\n\nAnimation Id: " .. animationId
                end
            end
        end
        if found ~= "Animations Copied" then
            toClipboard(found)
        else
            notify("Animations", "No animations to copy")
        end
    end
    if args[1] then
        copyAnimId(Players[getPlayer(args[1], speaker)[1]])
    else
        copyAnimId(speaker)
    end
end)

addcmd('stopanimations', {'stopanims', 'stopanim'}, function(args, speaker)
    local Char = speaker.Character
    local Hum = Char:FindFirstChildOfClass("Humanoid") or Char:FindFirstChildOfClass("AnimationController")
    for _, v in pairs(Hum:GetPlayingAnimationTracks()) do
        v:Stop()
    end
end)

addcmd('refreshanimations', {'refreshanimation', 'refreshanims', 'refreshanim'}, function(args, speaker)
    local Char = speaker.Character or speaker.CharacterAdded:Wait()
    local Human = Char and Char:WaitForChild('Humanoid', 15)
    local Animate = Char and Char:WaitForChild('Animate', 15)
    if not Human or not Animate then
        return notify('Refresh Animations', 'Failed to get Animate/Humanoid')
    end
    Animate.Disabled = true
    for _, v in ipairs(Human:GetPlayingAnimationTracks()) do
        v:Stop()
    end
    Animate.Disabled = false
end)

addcmd('allowcustomanim', {'allowcustomanimations'}, function(args, speaker)
    StarterPlayer.AllowCustomAnimations = true
    execCmd('refreshanimations')
end)

addcmd('unallowcustomanim', {'unallowcustomanimations'}, function(args, speaker)
    StarterPlayer.AllowCustomAnimations = false
    execCmd('refreshanimations')
end)

addcmd('loopanimation', {'loopanim'}, function(args, speaker)
    local Char = speaker.Character
    local Human = Char and Char:FindFirstChildOfClass("Humanoid")
    for _, v in ipairs(Human:GetPlayingAnimationTracks()) do
        v.Looped = true
    end
end)

addcmd('tpposition', {'tppos'}, function(args, speaker)
    if #args < 3 then return end
    local tpX, tpY, tpZ = tonumber((args[1]:gsub(",", ""))), tonumber((args[2]:gsub(",", ""))), tonumber((args[3]:gsub(",", "")))
    local char = speaker.Character
    if char and getRoot(char) then
        getRoot(char).CFrame = CFrame.new(tpX, tpY, tpZ)
    end
end)

addcmd('tweentpposition', {'ttppos'}, function(args, speaker)
    if #args < 3 then return end
    local tpX, tpY, tpZ = tonumber((args[1]:gsub(",", ""))), tonumber((args[2]:gsub(",", ""))), tonumber((args[3]:gsub(",", "")))
    local char = speaker.Character
    if char and getRoot(char) then
        TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = CFrame.new(tpX, tpY, tpZ)}):Play()
    end
end)

addcmd('offset', {}, function(args, speaker)
    if #args < 3 then return end
    if speaker.Character then
        speaker.Character:TranslateBy(Vector3.new(tonumber(args[1]) or 0, tonumber(args[2]) or 0, tonumber(args[3]) or 0))
    end
end)

addcmd('tweenoffset', {'toffset'}, function(args, speaker)
    if #args < 3 then return end
    local tpX, tpY, tpZ = tonumber(args[1]), tonumber(args[2]), tonumber(args[3])
    local char = speaker.Character
    if char and getRoot(char) then
        TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = CFrame.new(tpX, tpY, tpZ)}):Play()
    end
end)

addcmd('clickteleport', {}, function(args, speaker)
    if speaker == Players.LocalPlayer then
        notify('Click TP', 'Go to Settings>Keybinds>Add to set up click tp')
    end
end)

addcmd("mouseteleport", {"mousetp"}, function(args, speaker)
    local root = getRoot(speaker.Character)
    local pos = IYMouse.Hit
    if root and pos then
        root.CFrame = CFrame.new(pos.X, pos.Y + 3, pos.Z, select(4, root.CFrame:components()))
    end
end)

addcmd('tptool', {'teleporttool'}, function(args, speaker)
    local TpTool = Instance.new("Tool")
    TpTool.Name = "Teleport Tool"
    TpTool.RequiresHandle = false
    TpTool.Parent = speaker.Backpack
    TpTool.Activated:Connect(function()
        local Char = speaker.Character or workspace:FindFirstChild(speaker.Name)
        local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
        if not Char or not HRP then
            return warn("Failed to find HumanoidRootPart")
        end
        HRP.CFrame = CFrame.new(IYMouse.Hit.X, IYMouse.Hit.Y + 3, IYMouse.Hit.Z, select(4, HRP.CFrame:components()))
    end)
end)

addcmd('clickdelete', {}, function(args, speaker)
    if speaker == Players.LocalPlayer then
        notify('Click Delete', 'Go to Settings>Keybinds>Add to set up click delete')
    end
end)

addcmd('getposition', {'getpos', 'notifypos', 'notifyposition'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        local char = Players[v].Character
        local pos = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
        pos = pos and pos.Position
        if not pos then
            return notify('Getposition Error', 'Missing character')
        end
        local roundedPos = math.round(pos.X) .. ", " .. math.round(pos.Y) .. ", " .. math.round(pos.Z)
        notify('Current Position', roundedPos)
    end
end)

addcmd('copyposition', {'copypos'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        local char = Players[v].Character
        local pos = char and (getRoot(char) or char:FindFirstChildWhichIsA("BasePart"))
        pos = pos and pos.Position
        if not pos then
            return notify('Getposition Error', 'Missing character')
        end
        local roundedPos = math.round(pos.X) .. ", " .. math.round(pos.Y) .. ", " .. math.round(pos.Z)
        toClipboard(roundedPos)
    end
end)

addcmd('walktopos', {'walktoposition'}, function(args, speaker)
    if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
        speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
        wait(.1)
    end
    speaker.Character:FindFirstChildOfClass('Humanoid').WalkToPoint = Vector3.new(args[1], args[2], args[3])
end)

addcmd('speed', {'ws', 'walkspeed'}, function(args, speaker)
    local speed = args[1] or 16
    if isNumber(speed) then
        speaker.Character:FindFirstChildOfClass('Humanoid').WalkSpeed = speed
    end
end)


addcmd('spoofspeed', {'spoofws', 'spoofwalkspeed'}, function(args, speaker)
    if args[1] and isNumber(args[1]) then
        if hookmetamethod then
            local char = speaker.Character
            local setspeed
            local index = hookmetamethod(game, "__index", function(self, key)
                local keyclean = key:gsub("\0", "")
                if (keyclean == "WalkSpeed" or keyclean == "walkSpeed") and self:IsA("Humanoid") and self:IsDescendantOf(char) and not checkcaller() then
                    return setspeed or args[1]
                end
                return index(self, key)
            end)
            local newindex = hookmetamethod(game, "__newindex", function(self, key, value)
                local keyclean = string.gsub(key, "\0", "")
                if (keyclean == "WalkSpeed" or keyclean == "walkSpeed") and self:IsA("Humanoid") and self:IsDescendantOf(char) and not checkcaller() then
                    setspeed = tonumber(value)
                    return setspeed
                end
                return newindex(self, key, value)
            end)
        else
            notify('Incompatible Exploit', 'Your exploit does not support this command (missing hookmetamethod)')
        end
    end
end)

addcmd('loopspeed', {'loopws'}, function(args, speaker)
    local speed = args[1] or 16
    if isNumber(speed) then
        local Char = speaker.Character or workspace:FindFirstChild(speaker.Name)
        local Human = Char and Char:FindFirstChildWhichIsA("Humanoid")
        local function WalkSpeedChange()
            if Char and Human then
                Human.WalkSpeed = speed
            end
        end
        WalkSpeedChange()
        HumanModCons.wsLoop = (HumanModCons.wsLoop and HumanModCons.wsLoop:Disconnect() and false) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
        HumanModCons.wsCA = (HumanModCons.wsCA and HumanModCons.wsCA:Disconnect() and false) or speaker.CharacterAdded:Connect(function(nChar)
            Char, Human = nChar, nChar:WaitForChild("Humanoid")
            WalkSpeedChange()
            HumanModCons.wsLoop = (HumanModCons.wsLoop and HumanModCons.wsLoop:Disconnect() and false) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
        end)
    end
end)

addcmd('unloopspeed', {'unloopws'}, function(args, speaker)
    HumanModCons.wsLoop = (HumanModCons.wsLoop and HumanModCons.wsLoop:Disconnect() and false) or nil
    HumanModCons.wsCA = (HumanModCons.wsCA and HumanModCons.wsCA:Disconnect() and false) or nil
end)

addcmd('spoofjumppower', {'spoofjp'}, function(args, speaker)
    if args[1] and isNumber(args[1]) then
        if hookmetamethod then
            local char = speaker.Character
            local setpower
            local index = hookmetamethod(game, "__index", function(self, key)
                local keyclean = key:gsub("\0", "")
                if (keyclean == "JumpPower" or keyclean == "jumpPower") and self:IsA("Humanoid") and self:IsDescendantOf(char) and not checkcaller() then
                    return setpower or args[1]
                end
                return index(self, key)
            end)
            local newindex = hookmetamethod(game, "__newindex", function(self, key, value)
                local keyclean = string.gsub(key, "\0", "")
                if (keyclean == "JumpPower" or keyclean == "jumpPower") and self:IsA("Humanoid") and self:IsDescendantOf(char) and not checkcaller() then
                    setpower = tonumber(value)
                    return setpower
                end
                return newindex(self, key, value)
            end)
        else
            notify('Incompatible Exploit', 'Your exploit does not support this command (missing hookmetamethod)')
        end
    end
end)

addcmd('loopjumppower', {'loopjp', 'loopjpower'}, function(args, speaker)
    local jpower = args[1] or 50
    if isNumber(jpower) then
        local Char = speaker.Character or workspace:FindFirstChild(speaker.Name)
        local Human = Char and Char:FindFirstChildWhichIsA("Humanoid")
        local function JumpPowerChange()
            if Char and Human then
                if speaker.Character:FindFirstChildOfClass('Humanoid').UseJumpPower then
                    speaker.Character:FindFirstChildOfClass('Humanoid').JumpPower = jpower
                else
                    speaker.Character:FindFirstChildOfClass('Humanoid').JumpHeight = jpower
                end
            end
        end
        JumpPowerChange()
        HumanModCons.jpLoop = (HumanModCons.jpLoop and HumanModCons.jpLoop:Disconnect() and false) or Human:GetPropertyChangedSignal("JumpPower"):Connect(JumpPowerChange)
        HumanModCons.jpCA = (HumanModCons.jpCA and HumanModCons.jpCA:Disconnect() and false) or speaker.CharacterAdded:Connect(function(nChar)
            Char, Human = nChar, nChar:WaitForChild("Humanoid")
            JumpPowerChange()
            HumanModCons.jpLoop = (HumanModCons.jpLoop and HumanModCons.jpLoop:Disconnect() and false) or Human:GetPropertyChangedSignal("JumpPower"):Connect(JumpPowerChange)
        end)
    end
end)

addcmd('unloopjumppower', {'unloopjp', 'unloopjpower'}, function(args, speaker)
    HumanModCons.jpLoop = (HumanModCons.jpLoop and HumanModCons.jpLoop:Disconnect() and false) or nil
    HumanModCons.jpCA = (HumanModCons.jpCA and HumanModCons.jpCA:Disconnect() and false) or nil
    if speaker.Character:FindFirstChildOfClass('Humanoid').UseJumpPower then
        speaker.Character:FindFirstChildOfClass('Humanoid').JumpPower = 50
    else
        speaker.Character:FindFirstChildOfClass('Humanoid').JumpHeight = 50
    end
end)

addcmd('tools', {'gears'}, function(args, speaker)
    local function copy(instance)
        for _, c in pairs(instance:GetChildren()) do
            if c:IsA('Tool') or c:IsA('HopperBin') then
                c:Clone().Parent = speaker:FindFirstChildOfClass("Backpack")
            end
            copy(c)
        end
    end
    copy(Lighting)
    copy(ReplicatedStorage)
    notify('Tools', 'Copied tools from ReplicatedStorage and Lighting')
end)

addcmd('notools', {'rtools', 'clrtools', 'removetools', 'deletetools', 'dtools'}, function(args, speaker)
    for _, v in pairs(speaker:FindFirstChildOfClass("Backpack"):GetDescendants()) do
        if v:IsA('Tool') or v:IsA('HopperBin') then
            v:Destroy()
        end
    end
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA('Tool') or v:IsA('HopperBin') then
            v:Destroy()
        end
    end
end)

addcmd('deleteselectedtool', {'dst'}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA('Tool') or v:IsA('HopperBin') then
            v:Destroy()
        end
    end
end)

addcmd("console", {}, function(args, speaker)
    StarterGui:SetCore("DevConsoleVisible", true)
end)

addcmd('oldconsole', {}, function(args, speaker)
    notify("Loading", 'Hold on a sec')
    local _, str = pcall(function()
        return game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/console.lua", true)
    end)
    local s, e = loadstring(str)
    if typeof(s) ~= "function" then
        return
    end
    local success, message = pcall(s)
    if not success then
        if printconsole then
            printconsole(message)
        elseif printoutput then
            printoutput(message)
        end
    end
    wait(1)
    notify('Console', 'Press F9 to open the console')
end)

addcmd('explorer', {'dex'}, function(args, speaker)
    notify('Loading', 'Hold on a sec')
    loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua"))()
end)

addcmd('olddex', {'odex'}, function(args, speaker)
    notify('Loading old explorer', 'Hold on a sec')

    local getobjects = function(a)
        local Objects = {}
        if a then
            local b = InsertService:LoadLocalAsset(a)
            if b then 
                table.insert(Objects, b) 
            end
        end
        return Objects
    end

    local Dex = getobjects("rbxassetid://10055842438")[1]
    Dex.Parent = PARENT

    local function Load(Obj, Url)
        local function GiveOwnGlobals(Func, Script)
            local Fenv, RealFenv, FenvMt = {}, {
                script = Script,
                getupvalue = function(a, b)
                    return nil
                end,
                getreg = function()
                    return {}
                end,
                getprops = getprops or function(inst)
                    if getproperties then
                        local props = getproperties(inst)
                        if props[1] and gethiddenproperty then
                            local results = {}
                            for _, name in pairs(props) do
                                local success, res = pcall(gethiddenproperty, inst, name)
                                if success then
                                    results[name] = res
                                end
                            end
                            return results
                        end
                        return props
                    end
                    return {}
                end
            }, {}
            FenvMt.__index = function(a, b)
                return RealFenv[b] == nil and getgenv()[b] or RealFenv[b]
            end
            FenvMt.__newindex = function(a, b, c)
                if RealFenv[b] == nil then 
                    getgenv()[b] = c 
                else 
                    RealFenv[b] = c 
                end
            end
            setmetatable(Fenv, FenvMt)
            pcall(setfenv, Func, Fenv)
            return Func
        end

        local function LoadScripts(_, Script)
            if Script:IsA("LocalScript") then
                task.spawn(function()
                    GiveOwnGlobals(loadstring(Script.Source, "=" .. Script:GetFullName()), Script)()
                end)
            end
            table.foreach(Script:GetChildren(), LoadScripts)
        end

        LoadScripts(nil, Obj)
    end

    Load(Dex)
end)

addcmd('remotespy', {'rspy'}, function(args, speaker)
    notify("Loading", 'Hold on a sec')
    loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/SimpleSpyV3/main.lua"))()
end)

addcmd('audiologger', {'alogger'}, function(args, speaker)
    notify("Loading", 'Hold on a sec')
    loadstring(game:HttpGet(('https://raw.githubusercontent.com/infyiff/backup/main/audiologger.lua'), true))()
end)

local loopgoto = nil

addcmd('loopgoto', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        loopgoto = nil
        if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
            speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
            wait(.1)
        end
        loopgoto = Players[v]
        local distance = args[2] and tonumber(args[2]) or 3
        local lDelay = args[3] and tonumber(args[3]) or 0
        repeat
            if Players:FindFirstChild(v) then
                if Players[v].Character ~= nil then
                    getRoot(speaker.Character).CFrame = getRoot(Players[v].Character).CFrame + Vector3.new(distance, 1, 0)
                end
                wait(lDelay)
            else
                loopgoto = nil
            end
        until loopgoto ~= Players[v]
    end
end)

addcmd('unloopgoto', {'noloopgoto'}, function(args, speaker)
    loopgoto = nil
end)

addcmd('headsit', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    if headSit then headSit:Disconnect() end
    for _, v in pairs(players) do
        speaker.Character:FindFirstChildOfClass('Humanoid').Sit = true
        headSit = RunService.Heartbeat:Connect(function()
            if Players:FindFirstChild(Players[v].Name) and Players[v].Character ~= nil and getRoot(Players[v].Character) and getRoot(speaker.Character) and speaker.Character:FindFirstChildOfClass('Humanoid').Sit == true then
                getRoot(speaker.Character).CFrame = getRoot(Players[v].Character).CFrame * CFrame.Angles(0, math.rad(0), 0) * CFrame.new(0, 1.6, 0.4)
            else
                headSit:Disconnect()
            end
        end)
    end
end)

addcmd('chat', {'say'}, function(args, speaker)
    local cString = getstring(1)
    chatMessage(cString)
end)

local spamming = false
local spamspeed = 1

addcmd('spam', {}, function(args, speaker)
    spamming = true
    local spamstring = getstring(1)
    repeat
        wait(spamspeed)
        chatMessage(spamstring)
    until not spamming
end)

addcmd('nospam', {'unspam'}, function(args, speaker)
    spamming = false
end)

addcmd('whisper', {'pm'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        task.spawn(function()
            local plrName = Players[v].Name
            local pmstring = getstring(2)
            chatMessage("/w " .. plrName .. " " .. pmstring)
        end)
    end
end)

local pmspamming = {}

addcmd('pmspam', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        task.spawn(function()
            local plrName = Players[v].Name
            if FindInTable(pmspamming, plrName) then return end
            table.insert(pmspamming, plrName)
            local pmspamstring = getstring(2)
            repeat
                if Players:FindFirstChild(v) then
                    wait(spamspeed)
                    chatMessage("/w " .. plrName .. " " .. pmspamstring)
                else
                    for a, b in pairs(pmspamming) do
                        if b == plrName then
                            table.remove(pmspamming, a)
                        end
                    end
                end
            until not FindInTable(pmspamming, plrName)
        end)
    end
end)

addcmd('nopmspam', {'unpmspam'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        task.spawn(function()
            for a, b in pairs(pmspamming) do
                if b == Players[v].Name then
                    table.remove(pmspamming, a)
                end
            end
        end)
    end
end)

addcmd('spamspeed', {}, function(args, speaker)
    local speed = args[1] or 1
    if isNumber(speed) then
        spamspeed = speed
    end
end)

addcmd('bubblechat', {}, function(args, speaker)
    if isLegacyChat then
        ChatService.BubbleChatEnabled = true
    else
        TextChatService.BubbleChatConfiguration.Enabled = true
    end
end)

addcmd('unbubblechat', {'nobubblechat'}, function(args, speaker)
    if isLegacyChat then
        ChatService.BubbleChatEnabled = false
    else
        TextChatService.BubbleChatConfiguration.Enabled = false
    end
end)

addcmd('blockhead', {}, function(args, speaker)
    speaker.Character.Head:FindFirstChildOfClass("SpecialMesh"):Destroy()
end)

addcmd('blockhats', {}, function(args, speaker)
    for _, v in pairs(speaker.Character:FindFirstChildOfClass('Humanoid'):GetAccessories()) do
        for _, c in pairs(v:GetDescendants()) do
            if c:IsA("SpecialMesh") then
                c:Destroy()
            end
        end
    end
end)

addcmd('blocktool', {}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetChildren()) do
        if v:IsA("Tool") or v:IsA("HopperBin") then
            for _, c in pairs(v:GetDescendants()) do
                if c:IsA("SpecialMesh") then
                    c:Destroy()
                end
            end
        end
    end
end)

addcmd('creeper', {}, function(args, speaker)
    if r15(speaker) then
        speaker.Character.Head:FindFirstChildOfClass("SpecialMesh"):Destroy()
        speaker.Character.LeftUpperArm:Destroy()
        speaker.Character.RightUpperArm:Destroy()
        speaker.Character:FindFirstChildOfClass("Humanoid"):RemoveAccessories()
    else
        speaker.Character.Head:FindFirstChildOfClass("SpecialMesh"):Destroy()
        speaker.Character["Left Arm"]:Destroy()
        speaker.Character["Right Arm"]:Destroy()
        speaker.Character:FindFirstChildOfClass("Humanoid"):RemoveAccessories()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local bangAnim, bang, bangDied, bangLoop = nil, nil, nil, nil
local carpetAnim, carpet, carpetDied, carpetLoop = nil, nil, nil, nil

local function getTorso(x)
    x = x or Players.LocalPlayer.Character
    return x:FindFirstChild("Torso") or x:FindFirstChild("UpperTorso") or x:FindFirstChild("LowerTorso") or x:FindFirstChild("HumanoidRootPart")
end

addcmd("bang", {"rape"}, function(args, speaker)
    execCmd("unbang")
    wait()
    local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
    bangAnim = Instance.new("Animation")
    bangAnim.AnimationId = not r15(speaker) and "rbxassetid://148840371" or "rbxassetid://5918726674"
    bang = humanoid:LoadAnimation(bangAnim)
    bang:Play(0.1, 1, 1)
    bang:AdjustSpeed(args[2] or 3)
    bangDied = humanoid.Died:Connect(function()
        bang:Stop()
        bangAnim:Destroy()
        bangDied:Disconnect()
        bangLoop:Disconnect()
    end)
    if args[1] then
        local players = getPlayer(args[1], speaker)
        for _, v in pairs(players) do
            local bangplr = Players[v].Name
            local bangOffet = CFrame.new(0, 0, 1.1)
            bangLoop = RunService.Stepped:Connect(function()
                pcall(function()
                    local otherRoot = getTorso(Players[bangplr].Character)
                    getRoot(speaker.Character).CFrame = otherRoot.CFrame * bangOffet
                end)
            end)
        end
    end
end)

addcmd("unbang", {"unrape"}, function(args, speaker)
    if bangDied then
        bangDied:Disconnect()
        bang:Stop()
        bangAnim:Destroy()
        bangLoop:Disconnect()
    end
end)

addcmd('carpet', {}, function(args, speaker)
    if not r15(speaker) then
        execCmd('uncarpet')
        wait()
        local players = getPlayer(args[1], speaker)
        for i, v in pairs(players) do
            carpetAnim = Instance.new("Animation")
            carpetAnim.AnimationId = "rbxassetid://282574440"
            carpet = speaker.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(carpetAnim)
            carpet:Play(.1, 1, 1)
            local carpetplr = Players[v].Name
            carpetDied = speaker.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                carpetLoop:Disconnect()
                carpet:Stop()
                carpetAnim:Destroy()
                carpetDied:Disconnect()
            end)
            carpetLoop = RunService.Heartbeat:Connect(function()
                pcall(function()
                    getRoot(Players.LocalPlayer.Character).CFrame = getRoot(Players[carpetplr].Character).CFrame
                end)
            end)
        end
    else
        notify('R6 Required', 'This command requires the r6 rig type')
    end
end)

addcmd('uncarpet', {'nocarpet'}, function(args, speaker)
    if carpetLoop then
        carpetLoop:Disconnect()
        carpetDied:Disconnect()
        carpet:Stop()
        carpetAnim:Destroy()
    end
end)

addcmd('friend', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for i, v in pairs(players) do
        speaker:RequestFriendship(v)
    end
end)

addcmd('unfriend', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for i, v in pairs(players) do
        speaker:RevokeFriendship(v)
    end
end)

addcmd('bringpart', {}, function(args, speaker)
    for i, v in pairs(workspace:GetDescendants()) do
        if v.Name:lower() == getstring(1):lower() and v:IsA("BasePart") then
            v.CFrame = getRoot(speaker.Character).CFrame
        end
    end
end)

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local gotopartDelay = 0.1

addcmd('bringpartclass', {'bpc'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.ClassName:lower() == getstring(1):lower() and v:IsA("BasePart") then
            v.CFrame = getRoot(speaker.Character).CFrame
        end
    end
end)

addcmd('gotopart', {'topart'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name:lower() == getstring(1):lower() and v:IsA("BasePart") then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            wait(gotopartDelay)
            getRoot(speaker.Character).CFrame = v.CFrame
        end
    end
end)

addcmd('tweengotopart', {'tgotopart', 'ttopart'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name:lower() == getstring(1):lower() and v:IsA("BasePart") then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            wait(gotopartDelay)
            TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = v.CFrame}):Play()
        end
    end
end)

addcmd('gotopartclass', {'gpc'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.ClassName:lower() == getstring(1):lower() and v:IsA("BasePart") then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            wait(gotopartDelay)
            getRoot(speaker.Character).CFrame = v.CFrame
        end
    end
end)

addcmd('tweengotopartclass', {'tgpc'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.ClassName:lower() == getstring(1):lower() and v:IsA("BasePart") then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            wait(gotopartDelay)
            TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = v.CFrame}):Play()
        end
    end
end)

addcmd('gotomodel', {'tomodel'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name:lower() == getstring(1):lower() and v:IsA("Model") then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            wait(gotopartDelay)
            getRoot(speaker.Character).CFrame = v:GetModelCFrame()
        end
    end
end)

addcmd('tweengotomodel', {'tgotomodel', 'ttomodel'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name:lower() == getstring(1):lower() and v:IsA("Model") then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            wait(gotopartDelay)
            TweenService:Create(getRoot(speaker.Character), TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear), {CFrame = v:GetModelCFrame()}):Play()
        end
    end
end)

addcmd('gotopartdelay', {}, function(args, speaker)
    local gtpDelay = args[1] or 0.1
    if isNumber(gtpDelay) then
        gotopartDelay = gtpDelay
    end
end)

addcmd('noclickdetectorlimits', {'nocdlimits', 'removecdlimits'}, function(args, speaker)
    for _, v in ipairs(workspace:GetDescendants()) do
        if v:IsA("ClickDetector") then
            v.MaxActivationDistance = math.huge
        end
    end
end)

addcmd('fireclickdetectors', {'firecd', 'firecds'}, function(args, speaker)
    if fireclickdetector then
        if args[1] then
            local name = getstring(1)
            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("ClickDetector") and (descendant.Name == name or descendant.Parent.Name == name) then
                    fireclickdetector(descendant)
                end
            end
        else
            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("ClickDetector") then
                    fireclickdetector(descendant)
                end
            end
        end
    else
        notify("Incompatible Exploit", "Your exploit does not support this command (missing fireclickdetector)")
    end
end)

addcmd('noproximitypromptlimits', {'nopplimits', 'removepplimits'}, function(args, speaker)
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("ProximityPrompt") then
            v.MaxActivationDistance = math.huge
        end
    end
end)

addcmd('fireproximityprompts', {'firepp'}, function(args, speaker)
    if fireproximityprompt then
        if args[1] then
            local name = getstring(1)
            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("ProximityPrompt") and (descendant.Name == name or descendant.Parent.Name == name) then
                    fireproximityprompt(descendant)
                end
            end
        else
            for _, descendant in ipairs(workspace:GetDescendants()) do
                if descendant:IsA("ProximityPrompt") then
                    fireproximityprompt(descendant)
                end
            end
        end
    else
        notify("Incompatible Exploit", "Your exploit does not support this command (missing fireproximityprompt)")
    end
end)

local RunService = game:GetService("RunService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local Players = game:GetService("Players")

local PromptButtonHoldBegan = nil
local grabtoolsFunc = nil
local specifictoolremoval = {}
local spawnpos = nil
local spawnpoint = false
local spDelay = 0.1
local lastDeath = nil
local spinhats = nil

addcmd('instantproximityprompts', {'instantpp'}, function(args, speaker)
    if fireproximityprompt then
        execCmd("uninstantproximityprompts")
        wait(0.1)
        PromptButtonHoldBegan = ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
            fireproximityprompt(prompt)
        end)
    else
        notify('Incompatible Exploit', 'Your exploit does not support this command (missing fireproximityprompt)')
    end
end)

addcmd('uninstantproximityprompts', {'uninstantpp'}, function(args, speaker)
    if PromptButtonHoldBegan ~= nil then
        PromptButtonHoldBegan:Disconnect()
        PromptButtonHoldBegan = nil
    end
end)

addcmd('notifyping', {'ping'}, function(args, speaker)
    notify("Ping", math.round(speaker:GetNetworkPing() * 1000) .. "ms")
end)

addcmd('grabtools', {}, function(args, speaker)
    local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
    for _, child in ipairs(workspace:GetChildren()) do
        if speaker.Character and child:IsA("BackpackItem") and child:FindFirstChild("Handle") then
            humanoid:EquipTool(child)
        end
    end

    if grabtoolsFunc then
        grabtoolsFunc:Disconnect()
    end

    grabtoolsFunc = workspace.ChildAdded:Connect(function(child)
        if speaker.Character and child:IsA("BackpackItem") and child:FindFirstChild("Handle") then
            humanoid:EquipTool(child)
        end
    end)

    notify("Grabtools", "Picking up any dropped tools")
end)

addcmd('nograbtools', {'ungrabtools'}, function(args, speaker)
    if grabtoolsFunc then
        grabtoolsFunc:Disconnect()
    end
    notify("Grabtools", "Grabtools has been disabled")
end)

addcmd('removespecifictool', {}, function(args, speaker)
    if args[1] and speaker:FindFirstChildOfClass("Backpack") then
        local tool = string.lower(getstring(1))
        local RST = RunService.RenderStepped:Connect(function()
            if speaker:FindFirstChildOfClass("Backpack") then
                for _, v in pairs(speaker:FindFirstChildOfClass("Backpack"):GetChildren()) do
                    if v.Name:lower() == tool then
                        v:Remove()
                    end
                end
            end
        end)
        specifictoolremoval[tool] = RST
    end
end)

addcmd('unremovespecifictool', {}, function(args, speaker)
    if args[1] then
        local tool = string.lower(getstring(1))
        if specifictoolremoval[tool] ~= nil then
            specifictoolremoval[tool]:Disconnect()
            specifictoolremoval[tool] = nil
        end
    end
end)

addcmd('clearremovespecifictool', {}, function(args, speaker)
    for obj in pairs(specifictoolremoval) do
        specifictoolremoval[obj]:Disconnect()
        specifictoolremoval[obj] = nil
    end
end)

addcmd('light', {}, function(args, speaker)
    local light = Instance.new("PointLight")
    light.Parent = getRoot(speaker.Character)
    light.Range = 30
    if args[1] then
        light.Brightness = args[2]
        light.Range = args[1]
    else
        light.Brightness = 5
    end
end)

addcmd('unlight', {'nolight'}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v.ClassName == "PointLight" then
            v:Destroy()
        end
    end
end)

addcmd('copytools', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        task.spawn(function()
            for _, tool in pairs(Players[v]:FindFirstChildOfClass("Backpack"):GetChildren()) do
                if tool:IsA('Tool') or tool:IsA('HopperBin') then
                    tool:Clone().Parent = speaker:FindFirstChildOfClass("Backpack")
                end
            end
        end)
    end
end)

addcmd('naked', {}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("Clothing") or v:IsA("ShirtGraphic") then
            v:Destroy()
        end
    end
end)

addcmd('noface', {'removeface'}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("Decal") and v.Name == 'face' then
            v:Destroy()
        end
    end
end)

addcmd('spawnpoint', {'spawn'}, function(args, speaker)
    spawnpos = getRoot(speaker.Character).CFrame
    spawnpoint = true
    spDelay = tonumber(args[1]) or 0.1
    notify('Spawn Point', 'Spawn point created at ' .. tostring(spawnpos))
end)

addcmd('nospawnpoint', {'nospawn', 'removespawnpoint'}, function(args, speaker)
    spawnpoint = false
    notify('Spawn Point', 'Removed spawn point')
end)

addcmd('flashback', {'diedtp'}, function(args, speaker)
    if lastDeath ~= nil then
        if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
            speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
            wait(.1)
        end
        getRoot(speaker.Character).CFrame = lastDeath
    end
end)

addcmd('hatspin', {'spinhats'}, function(args, speaker)
    execCmd('unhatspin')
    wait(.5)
    for _, v in pairs(speaker.Character:FindFirstChildOfClass('Humanoid'):GetAccessories()) do
        local keep = Instance.new("BodyPosition")
        keep.Name = randomString()
        keep.Parent = v.Handle
        local spin = Instance.new("BodyAngularVelocity")
        spin.Name = randomString()
        spin.Parent = v.Handle
        v.Handle:FindFirstChildOfClass("Weld"):Destroy()
        if args[1] then
            spin.AngularVelocity = Vector3.new(0, args[1], 0)
            spin.MaxTorque = Vector3.new(0, args[1] * 2, 0)
        else
            spin.AngularVelocity = Vector3.new(0, 100, 0)
            spin.MaxTorque = Vector3.new(0, 200, 0)
        end
        keep.P = 30000
        keep.D = 50
        spinhats = RunService.Stepped:Connect(function()
            pcall(function()
                keep.Position = Players.LocalPlayer.Character.Head.Position
            end)
        end)
    end
end)

addcmd('unhatspin', {'unspinhats'}, function(args, speaker)
    if spinhats then
        spinhats:Disconnect()
    end
    for _, v in pairs(speaker.Character:FindFirstChildOfClass('Humanoid'):GetAccessories()) do
        v.Parent = workspace
        for _, c in pairs(v.Handle:GetChildren()) do
            if c:IsA("BodyPosition") or c:IsA("BodyAngularVelocity") then
                c:Destroy()
            end
        end
        wait()
        v.Parent = speaker.Character
    end
end)

addcmd('clearhats', {'cleanhats'}, function(args, speaker)
    if firetouchinterest then
        local Player = Players.LocalPlayer
        local Character = Player.Character
        local Old = Character:FindFirstChild("HumanoidRootPart").CFrame
        local Hats = {}

        for _, child in ipairs(workspace:GetChildren()) do
            if child:IsA("Accessory") then
                table.insert(Hats, child)
            end
        end

        for _, accessory in ipairs(Character:FindFirstChildOfClass("Humanoid"):GetAccessories()) do
            accessory:Destroy()
        end

        for i = 1, #Hats do
            repeat RunService.Heartbeat:wait() until Hats[i]
            firetouchinterest(Hats[i].Handle, Character:FindFirstChild("HumanoidRootPart"), 0)
            repeat RunService.Heartbeat:wait() until Character:FindFirstChildOfClass("Accessory")
            Character:FindFirstChildOfClass("Accessory"):Destroy()
            repeat RunService.Heartbeat:wait() until not Character:FindFirstChildOfClass("Accessory")
        end

        execCmd("reset")

        Player.CharacterAdded:Wait()

        for i = 1, 20 do
            RunService.Heartbeat:Wait()
            if Player.Character:FindFirstChild("HumanoidRootPart") then
                Player.Character:FindFirstChild("HumanoidRootPart").CFrame = Old
            end
        end
    else
        notify("Incompatible Exploit", "Your exploit does not support this command (missing firetouchinterest)")
    end
end)

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")

local flinging = false
local flingDied = nil
local brightLoop = nil
local currentToolSize = ""
local currentGripPos = ""

addcmd('split', {}, function(args, speaker)
    if r15(speaker) then
        speaker.Character.UpperTorso.Waist:Destroy()
    else
        notify('R15 Required', 'This command requires the r15 rig type')
    end
end)

addcmd('nilchar', {}, function(args, speaker)
    if speaker.Character ~= nil then
        speaker.Character.Parent = nil
    end
end)

addcmd('unnilchar', {'nonilchar'}, function(args, speaker)
    if speaker.Character ~= nil then
        speaker.Character.Parent = workspace
    end
end)

addcmd('noroot', {'removeroot', 'rroot'}, function(args, speaker)
    if speaker.Character ~= nil then
        local char = Players.LocalPlayer.Character
        char.Parent = nil
        char.HumanoidRootPart:Destroy()
        char.Parent = workspace
    end
end)

addcmd('replaceroot', {'replacerootpart'}, function(args, speaker)
    if speaker.Character ~= nil and speaker.Character:FindFirstChild("HumanoidRootPart") then
        local Char = speaker.Character
        local OldParent = Char.Parent
        local HRP = Char and Char:FindFirstChild("HumanoidRootPart")
        local OldPos = HRP.CFrame
        Char.Parent = game
        local HRP1 = HRP:Clone()
        HRP1.Parent = Char
        HRP = HRP:Destroy()
        HRP1.CFrame = OldPos
        Char.Parent = OldParent
    end
end)

addcmd('clearcharappearance', {'clearchar', 'clrchar'}, function(args, speaker)
    speaker:ClearCharacterAppearance()
end)

addcmd('equiptools', {}, function(args, speaker)
    for _, v in pairs(speaker:FindFirstChildOfClass("Backpack"):GetChildren()) do
        if v:IsA("Tool") or v:IsA("HopperBin") then
            v.Parent = speaker.Character
        end
    end
end)

addcmd('unequiptools', {}, function(args, speaker)
    speaker.Character:FindFirstChildOfClass('Humanoid'):UnequipTools()
end)

addcmd('dupetools', {'clonetools'}, function(args, speaker)
    local LOOP_NUM = tonumber(args[1]) or 1
    local OrigPos = speaker.Character.HumanoidRootPart.Position
    local Tools, TempPos = {}, Vector3.new(math.random(-2e5, 2e5), 2e5, math.random(-2e5, 2e5))
    for i = 1, LOOP_NUM do
        local Human = speaker.Character:WaitForChild("Humanoid")
        wait(.1, Human.Parent:MoveTo(TempPos))
        Human.RootPart.Anchored = speaker:ClearCharacterAppearance(wait(.1)) or true
        local t = GetHandleTools(speaker)
        while #t > 0 do
            for _, v in ipairs(t) do
                task.spawn(function()
                    for _ = 1, 25 do
                        v.Parent = speaker.Character
                        v.Handle.Anchored = true
                    end
                    for _ = 1, 5 do
                        v.Parent = workspace
                    end
                    table.insert(Tools, v.Handle)
                end)
            end
            t = GetHandleTools(speaker)
        end
        wait(.1)
        speaker.Character = speaker.Character:Destroy()
        speaker.CharacterAdded:Wait():WaitForChild("Humanoid").Parent:MoveTo(LOOP_NUM == i and OrigPos or TempPos, wait(.1))
        if i == LOOP_NUM or i % 5 == 0 then
            local HRP = speaker.Character.HumanoidRootPart
            if type(firetouchinterest) == "function" then
                for _, v in ipairs(Tools) do
                    v.Anchored = not firetouchinterest(v, HRP, 1, firetouchinterest(v, HRP, 0)) and false or false
                end
            else
                for _, v in ipairs(Tools) do
                    task.spawn(function()
                        local x = v.CanCollide
                        v.CanCollide = false
                        v.Anchored = false
                        for _ = 1, 10 do
                            v.CFrame = HRP.CFrame
                            wait()
                        end
                        v.CanCollide = x
                    end)
                end
            end
            wait(.1)
            Tools = {}
        end
        TempPos = TempPos + Vector3.new(10, math.random(-5, 5), 0)
    end
end)

addcmd('givetool', {'givetools'}, function(args, speaker)
    local v = Players[getPlayer(args[1], speaker)[1]].Character
    workspace.CurrentCamera.CameraSubject = v
    local Char = speaker.Character or workspace:FindFirstChild(speaker.Name)
    local hum = Char and Char:FindFirstChildWhichIsA('Humanoid')
    local hrp = hum and hum.RootPart
    local hrppos = hrp.CFrame
    hum = hum:Destroy() or hum:Clone()
    hum.Parent = Char
    hum:ClearAllChildren()
    speaker:ClearCharacterAppearance()
    task.spawn(function()
        speaker.CharacterAdded:Wait():WaitForChild('Humanoid').RootPart.CFrame = wait() and hrppos
    end)
    local vHRP = getRoot(v)
    while Char and Char.Parent and vHRP and vHRP.Parent do
        local Tools = false
        for _, v in ipairs(Char:GetChildren()) do
            if v:IsA('BackpackItem') and v:FindFirstChild('Handle') then
                Tools = true
                firetouchinterest(v.Handle, vHRP, 0)
                firetouchinterest(v.Handle, vHRP, 1)
            end
        end
        if not Tools then
            break
        end
        hrp.CFrame = vHRP.CFrame
        RunService.RenderStepped:Wait()
    end
    execCmd('re')
end)

addcmd('touchinterests', {'touchinterest', 'firetouchinterests', 'firetouchinterest'}, function(args, speaker)
    if not firetouchinterest then
        notify("Incompatible Exploit", "Your exploit does not support this command (missing firetouchinterest)")
        return
    end

    local root = getRoot(speaker.Character) or speaker.Character:FindFirstChildWhichIsA("BasePart")

    local function touch(x)
        x = x:FindFirstAncestorWhichIsA("Part")
        if x then
            if firetouchinterest then
                task.spawn(function()
                    firetouchinterest(x, root, 1)
                    wait()
                    firetouchinterest(x, root, 0)
                end)
            end
            x.CFrame = root.CFrame
        end
    end

    if args[1] then
        local name = getstring(1)
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant:IsA("TouchTransmitter") and descendant.Name == name or descendant.Parent.Name == name then
                touch(descendant)
            end
        end
    else
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant:IsA("TouchTransmitter") then
                touch(descendant)
            end
        end
    end
end)

addcmd('fullbright', {'fb', 'fullbrightness'}, function(args, speaker)
    Lighting.Brightness = 2
    Lighting.ClockTime = 14
    Lighting.FogEnd = 100000
    Lighting.GlobalShadows = false
    Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
end)

addcmd('loopfullbright', {'loopfb'}, function(args, speaker)
    if brightLoop then
        brightLoop:Disconnect()
    end
    local function brightFunc()
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    end

    brightLoop = RunService.RenderStepped:Connect(brightFunc)
end)

addcmd('unloopfullbright', {'unloopfb'}, function(args, speaker)
    if brightLoop then
        brightLoop:Disconnect()
    end
end)

addcmd('ambient', {}, function(args, speaker)
    Lighting.Ambient = Color3.new(args[1], args[2], args[3])
    Lighting.OutdoorAmbient = Color3.new(args[1], args[2], args[3])
end)

addcmd('day', {}, function(args, speaker)
    Lighting.ClockTime = 14
end)

addcmd('night', {}, function(args, speaker)
    Lighting.ClockTime = 0
end)

addcmd('nofog', {}, function(args, speaker)
    Lighting.FogEnd = 100000
    for _, v in pairs(Lighting:GetDescendants()) do
        if v:IsA("Atmosphere") then
            v:Destroy()
        end
    end
end)

addcmd('brightness', {}, function(args, speaker)
    Lighting.Brightness = args[1]
end)

addcmd('globalshadows', {'gshadows'}, function(args, speaker)
    Lighting.GlobalShadows = true
end)

addcmd('unglobalshadows', {'nogshadows', 'ungshadows', 'noglobalshadows'}, function(args, speaker)
    Lighting.GlobalShadows = false
end)

addcmd('restorelighting', {'rlighting'}, function(args, speaker)
    Lighting.Ambient = origsettings.abt
    Lighting.OutdoorAmbient = origsettings.oabt
    Lighting.Brightness = origsettings.brt
    Lighting.ClockTime = origsettings.time
    Lighting.FogEnd = origsettings.fe
    Lighting.FogStart = origsettings.fs
    Lighting.GlobalShadows = origsettings.gs
end)

addcmd('stun', {'platformstand'}, function(args, speaker)
    speaker.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
end)

addcmd('unstun', {'nostun', 'unplatformstand', 'noplatformstand'}, function(args, speaker)
    speaker.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
end)

addcmd('norotate', {'noautorotate'}, function(args, speaker)
    speaker.Character:FindFirstChildOfClass('Humanoid').AutoRotate = false
end)

addcmd('unnorotate', {'autorotate'}, function(args, speaker)
    speaker.Character:FindFirstChildOfClass('Humanoid').AutoRotate = true
end)

addcmd('enablestate', {}, function(args, speaker)
    local x = args[1]
    if not tonumber(x) then
        x = Enum.HumanoidStateType[args[1]]
    end
    speaker.Character:FindFirstChildOfClass("Humanoid"):SetStateEnabled(x, true)
end)

addcmd('disablestate', {}, function(args, speaker)
    local x = args[1]
    if not tonumber(x) then
        x = Enum.HumanoidStateType[args[1]]
    end
    speaker.Character:FindFirstChildOfClass("Humanoid"):SetStateEnabled(x, false)
end)

addcmd('drophats', {'drophat'}, function(args, speaker)
    if speaker.Character then
        for _, v in pairs(speaker.Character:FindFirstChildOfClass('Humanoid'):GetAccessories()) do
            v.Parent = workspace
        end
    end
end)

addcmd('deletehats', {'nohats', 'rhats'}, function(args, speaker)
    for _, v in next, speaker.Character:GetDescendants() do
        if v:IsA("Accessory") then
            for _, p in next, v:GetDescendants() do
                if p:IsA("Weld") then
                    p:Destroy()
                end
            end
        end
    end
end)

addcmd('droptools', {'droptool'}, function(args, speaker)
    for _, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
        if v:IsA("Tool") then
            v.Parent = Players.LocalPlayer.Character
        end
    end
    wait()
    for _, v in pairs(Players.LocalPlayer.Character:GetChildren()) do
        if v:IsA("Tool") then
            v.Parent = workspace
        end
    end
end)

addcmd('droppabletools', {}, function(args, speaker)
    if speaker.Character then
        for _, obj in pairs(speaker.Character:GetChildren()) do
            if obj:IsA("Tool") then
                obj.CanBeDropped = true
            end
        end
    end
    if speaker:FindFirstChildOfClass("Backpack") then
        for _, obj in pairs(speaker:FindFirstChildOfClass("Backpack"):GetChildren()) do
            if obj:IsA("Tool") then
                obj.CanBeDropped = true
            end
        end
    end
end)

addcmd('reach', {}, function(args, speaker)
    execCmd('unreach')
    wait()
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("Tool") then
            if args[1] then
                currentToolSize = v.Handle.Size
                currentGripPos = v.GripPos
                local a = Instance.new("SelectionBox")
                a.Name = "SelectionBoxCreated"
                a.Parent = v.Handle
                a.Adornee = v.Handle
                v.Handle.Massless = true
                v.Handle.Size = Vector3.new(0.5, 0.5, args[1])
                v.GripPos = Vector3.new(0, 0, 0)
                speaker.Character:FindFirstChildOfClass('Humanoid'):UnequipTools()
            else
                currentToolSize = v.Handle.Size
                currentGripPos = v.GripPos
                local a = Instance.new("SelectionBox")
                a.Name = "SelectionBoxCreated"
                a.Parent = v.Handle
                a.Adornee = v.Handle
                v.Handle.Massless = true
                v.Handle.Size = Vector3.new(0.5, 0.5, 60)
                v.GripPos = Vector3.new(0, 0, 0)
                speaker.Character:FindFirstChildOfClass('Humanoid'):UnequipTools()
            end
        end
    end
end)

addcmd("boxreach", {}, function(args, speaker)
    execCmd("unreach")
    wait()
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("Tool") then
            local size = tonumber(args[1]) or 60
            currentToolSize = v.Handle.Size
            currentGripPos = v.GripPos
            local a = Instance.new("SelectionBox")
            a.Name = "SelectionBoxCreated"
            a.Parent = v.Handle
            a.Adornee = v.Handle
            v.Handle.Massless = true
            v.Handle.Size = Vector3.new(size, size, size)
            v.GripPos = Vector3.new(0, 0, 0)
            speaker.Character:FindFirstChildOfClass("Humanoid"):UnequipTools()
        end
    end
end)

addcmd('unreach', {'noreach', 'unboxreach'}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("Tool") then
            v.Handle.Size = currentToolSize
            v.GripPos = currentGripPos
            v.Handle.SelectionBoxCreated:Destroy()
        end
    end
end)

addcmd('grippos', {}, function(args, speaker)
    for _, v in pairs(speaker.Character:GetDescendants()) do
        if v:IsA("Tool") then
            v.Parent = speaker:FindFirstChildOfClass("Backpack")
            v.GripPos = Vector3.new(args[1], args[2], args[3])
            v.Parent = speaker.Character
        end
    end
end)

addcmd('usetools', {}, function(args, speaker)
    local Backpack = speaker:FindFirstChildOfClass("Backpack")
    local ammount = tonumber(args[1]) or 1
    local delay_ = tonumber(args[2]) or false
    for _, v in ipairs(Backpack:GetChildren()) do
        v.Parent = speaker.Character
        task.spawn(function()
            for _ = 1, ammount do
                v:Activate()
                if delay_ then
                    wait(delay_)
                end
            end
            v.Parent = Backpack
        end)
    end
end)

addcmd('logs', {}, function(args, speaker)
    logs:TweenPosition(UDim2.new(0, 0, 1, -265), "InOut", "Quart", 0.3, true, nil)
end)

addcmd('chatlogs', {'clogs'}, function(args, speaker)
    join.Visible = false
    chat.Visible = true
    table.remove(shade3, table.find(shade3, selectChat))
    table.remove(shade2, table.find(shade2, selectJoin))
    table.insert(shade2, selectChat)
    table.insert(shade3, selectJoin)
    selectJoin.BackgroundColor3 = currentShade3
    selectChat.BackgroundColor3 = currentShade2
    logs:TweenPosition(UDim2.new(0, 0, 1, -265), "InOut", "Quart", 0.3, true, nil)
end)

addcmd('joinlogs', {'jlogs'}, function(args, speaker)
    chat.Visible = false
    join.Visible = true
    table.remove(shade3, table.find(shade3, selectJoin))
    table.remove(shade2, table.find(shade2, selectChat))
    table.insert(shade2, selectJoin)
    table.insert(shade3, selectChat)
    selectChat.BackgroundColor3 = currentShade3
    selectJoin.BackgroundColor3 = currentShade2
    logs:TweenPosition(UDim2.new(0, 0, 1, -265), "InOut", "Quart", 0.3, true, nil)
end)

addcmd("chatlogswebhook", {"logswebhook"}, function(args, speaker)
    if httprequest then
        logsWebhook = args[1] or nil
        updatesaves()
    else
        notify("Incompatible Exploit", "Your exploit does not support this command (missing request)")
    end
end)

addcmd("antichatlogs", {"antichatlogger"}, function(args, speaker)
    if not isLegacyChat then
        return notify("antichatlogs", "Game needs the legacy chat")
    end
    local MessagePosted, _ = pcall(function()
        rawset(require(speaker:FindFirstChild("PlayerScripts"):FindFirstChild("ChatScript").ChatMain), "MessagePosted", {
            ["fire"] = function(msg)
                return msg
            end,
            ["wait"] = function()
                return
            end,
            ["connect"] = function()
                return
            end
        })
    end)
    notify("antichatlogs", MessagePosted and "Enabled" or "Failed to enable antichatlogs")
end)

addcmd('fling', {}, function(args, speaker)
    flinging = false
    for _, child in pairs(speaker.Character:GetDescendants()) do
        if child:IsA("BasePart") then
            child.CustomPhysicalProperties = PhysicalProperties.new(math.huge, 0.3, 0.5)
        end
    end
    execCmd('noclip')
    wait(.1)
    local bambam = Instance.new("BodyAngularVelocity")
    bambam.Name = randomString()
    bambam.Parent = getRoot(speaker.Character)
    bambam.AngularVelocity = Vector3.new(0, 99999, 0)
    bambam.MaxTorque = Vector3.new(0, math.huge, 0)
    bambam.P = math.huge
    local Char = speaker.Character:GetChildren()
    for _, v in next, Char do
        if v:IsA("BasePart") then
            v.CanCollide = false
            v.Massless = true
            v.Velocity = Vector3.new(0, 0, 0)
        end
    end
    flinging = true
    local function flingDiedF()
        execCmd('unfling')
    end
    flingDied = speaker.Character:FindFirstChildOfClass('Humanoid').Died:Connect(flingDiedF)
    repeat
        bambam.AngularVelocity = Vector3.new(0, 99999, 0)
        wait(.2)
        bambam.AngularVelocity = Vector3.new(0, 0, 0)
        wait(.1)
    until flinging == false
end)

addcmd('unfling', {'nofling'}, function(args, speaker)
    execCmd('clip')
    if flingDied then
        flingDied:Disconnect()
    end
    flinging = false
    wait(.1)
    local speakerChar = speaker.Character
    if not speakerChar or not getRoot(speakerChar) then return end
    for _, v in pairs(getRoot(speakerChar):GetChildren()) do
        if v.ClassName == 'BodyAngularVelocity' then
            v:Destroy()
        end
    end
    for _, child in pairs(speakerChar:GetDescendants()) do
        if child.ClassName == "Part" or child.ClassName == "MeshPart" then
            child.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5)
        end
    end
end)

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")

local flinging = false
local flingDied = nil
local walkflinging = false
local antifling = nil
local xrayEnabled = false
local xrayLoop = nil
local autoclicking = false
local cancelAutoClick = nil
local tpwalking = false
local walltpTouch = nil
local stareLoop = nil
local RolewatchData = {Group = 0, Role = "", Leave = false}
local RolewatchConnection = nil

addcmd('togglefling', {}, function(args, speaker)
    if flinging then
        execCmd('unfling')
    else
        execCmd('fling')
    end
end)

addcmd("flyfling", {}, function(args, speaker)
    execCmd("unvehiclefly\\unwalkfling")
    wait()
    if args[1] and isNumber(args[1]) then
        vehicleflyspeed = args[1]
    end
    execCmd("vehiclefly\\walkfling")
end)

addcmd("unflyfling", {}, function(args, speaker)
    execCmd("unvehiclefly\\unwalkfling\\breakvelocity")
end)

addcmd("toggleflyfling", {}, function(args, speaker)
    execCmd(flinging and "unflyfling" or "flyfling")
end)

addcmd("walkfling", {}, function(args, speaker)
    execCmd("unwalkfling")
    local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            execCmd("unwalkfling")
        end)
    end

    execCmd("noclip nonotify")
    walkflinging = true
    repeat RunService.Heartbeat:Wait()
        local character = speaker.Character
        local root = getRoot(character)
        local vel, movel = nil, 0.1

        while not (character and character.Parent and root and root.Parent) do
            RunService.Heartbeat:Wait()
            character = speaker.Character
            root = getRoot(character)
        end

        vel = root.Velocity
        root.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)

        RunService.RenderStepped:Wait()
        if character and character.Parent and root and root.Parent then
            root.Velocity = vel
        end

        RunService.Stepped:Wait()
        if character and character.Parent and root and root.Parent then
            root.Velocity = vel + Vector3.new(0, movel, 0)
            movel = movel * -1
        end
    until walkflinging == false
end)

addcmd("unwalkfling", {"nowalkfling"}, function(args, speaker)
    walkflinging = false
    execCmd("unnoclip nonotify")
end)

addcmd("togglewalkfling", {}, function(args, speaker)
    execCmd(walkflinging and "unwalkfling" or "walkfling")
end)

addcmd('invisfling', {}, function(args, speaker)
    local ch = speaker.Character
    local prt = Instance.new("Model")
    prt.Parent = speaker.Character
    local z1 = Instance.new("Part")
    z1.Name = "Torso"
    z1.CanCollide = false
    z1.Anchored = true
    local z2 = Instance.new("Part")
    z2.Name = "Head"
    z2.Parent = prt
    z2.Anchored = true
    z2.CanCollide = false
    local z3 = Instance.new("Humanoid")
    z3.Name = "Humanoid"
    z3.Parent = prt
    z1.Position = Vector3.new(0, 9999, 0)
    speaker.Character = prt
    wait(3)
    speaker.Character = ch
    wait(3)
    local Hum = Instance.new("Humanoid")
    z2:Clone()
    Hum.Parent = speaker.Character
    local root = getRoot(speaker.Character)
    for _, v in pairs(speaker.Character:GetChildren()) do
        if v ~= root and v.Name ~= "Humanoid" then
            v:Destroy()
        end
    end
    root.Transparency = 0
    root.Color = Color3.new(1, 1, 1)
    local invisflingStepped
    invisflingStepped = RunService.Stepped:Connect(function()
        if speaker.Character and getRoot(speaker.Character) then
            getRoot(speaker.Character).CanCollide = false
        else
            invisflingStepped:Disconnect()
        end
    end)
    sFLY()
    workspace.CurrentCamera.CameraSubject = root
    local bambam = Instance.new("BodyThrust")
    bambam.Parent = getRoot(speaker.Character)
    bambam.Force = Vector3.new(99999, 99999 * 10, 99999)
    bambam.Location = getRoot(speaker.Character).Position
end)

addcmd("antifling", {}, function(args, speaker)
    if antifling then
        antifling:Disconnect()
        antifling = nil
    end
    antifling = RunService.Stepped:Connect(function()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= speaker and player.Character then
                for _, v in pairs(player.Character:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.CanCollide = false
                    end
                end
            end
        end
    end)
end)

addcmd("unantifling", {}, function(args, speaker)
    if antifling then
        antifling:Disconnect()
        antifling = nil
    end
end)

addcmd("toggleantifling", {}, function(args, speaker)
    execCmd(antifling and "unantifling" or "antifling")
end)

local function attach(speaker, target)
    if tools(speaker) then
        local char = speaker.Character
        local tchar = target.Character
        local hum = speaker.Character:FindFirstChildOfClass("Humanoid")
        local hrp = getRoot(speaker.Character)
        local hrp2 = getRoot(target.Character)
        hum.Name = "1"
        local newHum = hum:Clone()
        newHum.Parent = char
        newHum.Name = "Humanoid"
        wait()
        hum:Destroy()
        workspace.CurrentCamera.CameraSubject = char
        newHum.DisplayDistanceType = "None"
        local tool = speaker:FindFirstChildOfClass("Backpack"):FindFirstChildOfClass("Tool") or speaker.Character:FindFirstChildOfClass("Tool")
        tool.Parent = char
        hrp.CFrame = hrp2.CFrame * CFrame.new(0, 0, 0) * CFrame.new(math.random(-100, 100) / 200, math.random(-100, 100) / 200, math.random(-100, 100) / 200)
        local n = 0
        repeat
            wait(.1)
            n = n + 1
            hrp.CFrame = hrp2.CFrame
        until (tool.Parent ~= char or not hrp or not hrp2 or not hrp.Parent or not hrp2.Parent or n > 250) and n > 2
    else
        notify('Tool Required', 'You need to have an item in your inventory to use this command')
    end
end

addcmd('attach', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        attach(speaker, Players[v])
    end
end)

local function kill(speaker, target, fast)
    if tools(speaker) then
        if target ~= nil then
            local NormPos = getRoot(speaker.Character).CFrame
            if not fast then
                refresh(speaker)
                wait()
                repeat wait() until speaker.Character ~= nil and getRoot(speaker.Character)
                wait(0.3)
            end
            local hrp = getRoot(speaker.Character)
            attach(speaker, target)
            repeat
                wait()
                hrp.CFrame = CFrame.new(999999, workspace.FallenPartsDestroyHeight + 5, 999999)
            until not getRoot(target.Character) or not getRoot(speaker.Character)
            speaker.CharacterAdded:Wait():WaitForChild("HumanoidRootPart").CFrame = NormPos
        end
    else
        notify('Tool Required', 'You need to have an item in your inventory to use this command')
    end
end

addcmd('kill', {'fekill'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        kill(speaker, Players[v])
    end
end)

addcmd('handlekill', {'hkill'}, function(args, speaker)
    if not firetouchinterest then
        return notify('Incompatible Exploit', 'Your exploit does not support this command (missing firetouchinterest)')
    end
    local RS = RunService.RenderStepped
    local Tool = speaker.Character.FindFirstChildWhichIsA(speaker.Character, "Tool")
    local Handle = Tool and Tool.FindFirstChild(Tool, "Handle")
    if not Tool or not Handle then
        return notify("Handle Kill", "You need to hold a \"Tool\" that does damage on touch. For example the default \"Sword\" tool.")
    end
    for _, v in ipairs(getPlayer(args[1], speaker)) do
        v = Players[v]
        task.spawn(function()
            while Tool and speaker.Character and v.Character and Tool.Parent == speaker.Character do
                local Human = v.Character.FindFirstChildWhichIsA(v.Character, "Humanoid")
                if not Human or Human.Health <= 0 then
                    break
                end
                for _, v1 in ipairs(v.Character.GetChildren(v.Character)) do
                    v1 = ((v1.IsA(v1, "BasePart") and firetouchinterest(Handle, v1, 1, (RS.Wait(RS) and nil) or firetouchinterest(Handle, v1, 0)) and nil) or v1
                end
            end
            notify("Handle Kill Stopped!", v.Name .. " died/left or you unequipped the tool!")
        end)
    end
end)

addcmd('tpwalk', {'teleportwalk'}, function(args, speaker)
    tpwalking = true
    local chr = speaker.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
    while tpwalking and chr and hum and hum.Parent do
        local delta = RunService.Heartbeat:Wait()
        if hum.MoveDirection.Magnitude > 0 then
            if args[1] and isNumber(args[1]) then
                chr:TranslateBy(hum.MoveDirection * tonumber(args[1]) * delta * 10)
            else
                chr:TranslateBy(hum.MoveDirection * delta * 10)
            end
        end
    end
end)

addcmd('untpwalk', {'unteleportwalk'}, function(args, speaker)
    tpwalking = false
end)

addcmd('fastkill', {'fastfekill'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        kill(speaker, Players[v], true)
    end
end)

local function bring(speaker, target, fast)
    if tools(speaker) then
        if target ~= nil then
            local NormPos = getRoot(speaker.Character).CFrame
            if not fast then
                refresh(speaker)
                wait()
                repeat wait() until speaker.Character ~= nil and getRoot(speaker.Character)
                wait(0.3)
            end
            local hrp = getRoot(speaker.Character)
            attach(speaker, target)
            repeat
                wait()
                hrp.CFrame = NormPos
            until not getRoot(target.Character) or not getRoot(speaker.Character)
            speaker.CharacterAdded:Wait():WaitForChild("HumanoidRootPart").CFrame = NormPos
        end
    else
        notify('Tool Required', 'You need to have an item in your inventory to use this command')
    end
end)

addcmd('bring', {'febring'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        bring(speaker, Players[v])
    end
end)

addcmd('fastbring', {'fastfebring'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        bring(speaker, Players[v], true)
    end
end)

local function teleport(speaker, target, target2, fast)
    if tools(speaker) then
        if target ~= nil then
            local NormPos = getRoot(speaker.Character).CFrame
            if not fast then
                refresh(speaker)
                wait()
                repeat wait() until speaker.Character ~= nil and getRoot(speaker.Character)
                wait(0.3)
            end
            local hrp = getRoot(speaker.Character)
            local hrp2 = getRoot(target2.Character)
            attach(speaker, target)
            repeat
                wait()
                hrp.CFrame = hrp2.CFrame
            until not getRoot(target.Character) or not getRoot(speaker.Character)
            wait(1)
            speaker.CharacterAdded:Wait():WaitForChild("HumanoidRootPart").CFrame = NormPos
        end
    else
        notify('Tool Required', 'You need to have an item in your inventory to use this command')
    end
end

addcmd('tp', {'teleport'}, function(args, speaker)
    local players1 = getPlayer(args[1], speaker)
    local players2 = getPlayer(args[2], speaker)
    for _, v in pairs(players1) do
        if getRoot(Players[v].Character) and getRoot(Players[players2[1]].Character) then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            teleport(speaker, Players[v], Players[players2[1]])
        end
    end
end)

addcmd('fasttp', {'fastteleport'}, function(args, speaker)
    local players1 = getPlayer(args[1], speaker)
    local players2 = getPlayer(args[2], speaker)
    for _, v in pairs(players1) do
        if getRoot(Players[v].Character) and getRoot(Players[players2[1]].Character) then
            if speaker.Character:FindFirstChildOfClass('Humanoid') and speaker.Character:FindFirstChildOfClass('Humanoid').SeatPart then
                speaker.Character:FindFirstChildOfClass('Humanoid').Sit = false
                wait(.1)
            end
            teleport(speaker, Players[v], Players[players2[1]], true)
        end
    end
end)

addcmd('spin', {}, function(args, speaker)
    local spinSpeed = 20
    if args[1] and isNumber(args[1]) then
        spinSpeed = args[1]
    end
    for _, v in pairs(getRoot(speaker.Character):GetChildren()) do
        if v.Name == "Spinning" then
            v:Destroy()
        end
    end
    local Spin = Instance.new("BodyAngularVelocity")
    Spin.Name = "Spinning"
    Spin.Parent = getRoot(speaker.Character)
    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
    Spin.AngularVelocity = Vector3.new(0, spinSpeed, 0)
end)

addcmd('unspin', {}, function(args, speaker)
    for _, v in pairs(getRoot(speaker.Character):GetChildren()) do
        if v.Name == "Spinning" then
            v:Destroy()
        end
    end
end)

addcmd("xray", {}, function(args, speaker)
    xrayEnabled = true
    xray()
end)

addcmd("unxray", {"noxray"}, function(args, speaker)
    xrayEnabled = false
    xray()
end)

addcmd("togglexray", {}, function(args, speaker)
    xrayEnabled = not xrayEnabled
    xray()
end)

addcmd("loopxray", {}, function(args, speaker)
    if xrayLoop then
        xrayLoop:Disconnect()
    end
    xrayLoop = RunService.RenderStepped:Connect(function()
        xrayEnabled = true
        xray()
    end)
end)

addcmd("unloopxray", {}, function(args, speaker)
    if xrayLoop then
        xrayLoop:Disconnect()
    end
end)

addcmd('walltp', {}, function(args, speaker)
    local torso
    if r15(speaker) then
        torso = speaker.Character.UpperTorso
    else
        torso = speaker.Character.Torso
    end
    local function touchedFunc(hit)
        local Root = getRoot(speaker.Character)
        if hit:IsA("BasePart") and hit.Position.Y > Root.Position.Y - speaker.Character:FindFirstChildOfClass('Humanoid').HipHeight then
            local hitP = getRoot(hit.Parent)
            if hitP ~= nil then
                Root.CFrame = hit.CFrame * CFrame.new(Root.CFrame.lookVector.X, hitP.Size.Z / 2 + speaker.Character:FindFirstChildOfClass('Humanoid').HipHeight, Root.CFrame.lookVector.Z)
            elseif hitP == nil then
                Root.CFrame = hit.CFrame * CFrame.new(Root.CFrame.lookVector.X, hit.Size.Y / 2 + speaker.Character:FindFirstChildOfClass('Humanoid').HipHeight, Root.CFrame.lookVector.Z)
            end
        end
    end
    walltpTouch = torso.Touched:Connect(touchedFunc)
end)

addcmd('unwalltp', {'nowalltp'}, function(args, speaker)
    if walltpTouch then
        walltpTouch:Disconnect()
    end
end)

addcmd('autoclick', {}, function(args, speaker)
    if mouse1press and mouse1release then
        execCmd('unautoclick')
        wait()
        local clickDelay = 0.1
        local releaseDelay = 0.1
        if args[1] and isNumber(args[1]) then clickDelay = args[1] end
        if args[2] and isNumber(args[2]) then releaseDelay = args[2] end
        autoclicking = true
        cancelAutoClick = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
            if not gameProcessedEvent then
                if (input.KeyCode == Enum.KeyCode.Backspace and UserInputService:IsKeyDown(Enum.KeyCode.Equals)) or (input.KeyCode == Enum.KeyCode.Equals and UserInputService:IsKeyDown(Enum.KeyCode.Backspace)) then
                    autoclicking = false
                    cancelAutoClick:Disconnect()
                end
            end
        end)
        notify('Auto Clicker', "Press [backspace] and [=] at the same time to stop")
        repeat wait(clickDelay)
            mouse1press()
            wait(releaseDelay)
            mouse1release()
        until autoclicking == false
    else
        notify('Auto Clicker', "Your exploit doesn't have the ability to use the autoclick")
    end
end)

addcmd('unautoclick', {'noautoclick'}, function(args, speaker)
    autoclicking = false
    if cancelAutoClick then cancelAutoClick:Disconnect() end
end)

addcmd('mousesensitivity', {'ms'}, function(args, speaker)
    UserInputService.MouseDeltaSensitivity = args[1]
end)

addcmd('hovername', {}, function(args, speaker)
    execCmd('unhovername')
    wait()
    nameBox = Instance.new("TextLabel")
    nameBox.Name = randomString()
    nameBox.Parent = ScaledHolder
    nameBox.BackgroundTransparency = 1
    nameBox.Size = UDim2.new(0, 200, 0, 30)
    nameBox.Font = Enum.Font.Code
    nameBox.TextSize = 16
    nameBox.Text = ""
    nameBox.TextColor3 = Color3.new(1, 1, 1)
    nameBox.TextStrokeTransparency = 0
    nameBox.TextXAlignment = Enum.TextXAlignment.Left
    nameBox.ZIndex = 10
    nbSelection = Instance.new('SelectionBox')
    nbSelection.Name = randomString()
    nbSelection.LineThickness = 0.03
    nbSelection.Color3 = Color3.new(1, 1, 1)
    local function updateNameBox()
        local t
        local target = IYMouse.Target

        if target then
            local humanoid = target.Parent:FindFirstChildOfClass("Humanoid") or target.Parent.Parent:FindFirstChildOfClass("Humanoid")
            if humanoid then
                t = humanoid.Parent
            end
        end

        if t ~= nil then
            local x = IYMouse.X
            local y = IYMouse.Y
            local xP
            local yP
            if IYMouse.X > 200 then
                xP = x - 205
                nameBox.TextXAlignment = Enum.TextXAlignment.Right
            else
                xP = x + 25
                nameBox.TextXAlignment = Enum.TextXAlignment.Left
            end
            nameBox.Position = UDim2.new(0, xP, 0, y)
            nameBox.Text = t.Name
            nameBox.Visible = true
            nbSelection.Parent = t
            nbSelection.Adornee = t
        else
            nameBox.Visible = false
            nbSelection.Parent = nil
            nbSelection.Adornee = nil
        end
    end
    nbUpdateFunc = IYMouse.Move:Connect(updateNameBox)
end)

addcmd('unhovername', {'nohovername'}, function(args, speaker)
    if nbUpdateFunc then
        nbUpdateFunc:Disconnect()
        nameBox:Destroy()
        nbSelection:Destroy()
    end
end)

addcmd('headsize', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        if Players[v] ~= speaker and Players[v].Character:FindFirstChild('Head') then
            local sizeArg = tonumber(args[2])
            local Size = Vector3.new(sizeArg, sizeArg, sizeArg)
            local Head = Players[v].Character:FindFirstChild('Head')
            if Head:IsA("BasePart") then
                if not args[2] or sizeArg == 1 then
                    Head.Size = Vector3.new(2, 1, 1)
                else
                    Head.Size = Size
                end
            end
        end
    end
end)

addcmd('hitbox', {}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    local transparency = args[3] and tonumber(args[3]) or 0.4
    for _, v in pairs(players) do
        if Players[v] ~= speaker and Players[v].Character:FindFirstChild('HumanoidRootPart') then
            local sizeArg = tonumber(args[2])
            local Size = Vector3.new(sizeArg, sizeArg, sizeArg)
            local Root = Players[v].Character:FindFirstChild('HumanoidRootPart')
            if Root:IsA("BasePart") then
                if not args[2] or sizeArg == 1 then
                    Root.Size = Vector3.new(2, 1, 1)
                    Root.Transparency = transparency
                else
                    Root.Size = Size
                    Root.Transparency = transparency
                end
            end
        end
    end
end)

addcmd('stareat', {'stare'}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    for _, v in pairs(players) do
        if stareLoop then
            stareLoop:Disconnect()
        end
        if not Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and Players[v].Character:FindFirstChild("HumanoidRootPart") then return end
        local function stareFunc()
            if Players.LocalPlayer.Character.PrimaryPart and Players:FindFirstChild(v) and Players[v].Character ~= nil and Players[v].Character:FindFirstChild("HumanoidRootPart") then
                local chrPos = Players.LocalPlayer.Character.PrimaryPart.Position
                local tPos = Players[v].Character:FindFirstChild("HumanoidRootPart").Position
                local modTPos = Vector3.new(tPos.X, chrPos.Y, tPos.Z)
                local newCF = CFrame.new(chrPos, modTPos)
                Players.LocalPlayer.Character:SetPrimaryPartCFrame(newCF)
            elseif not Players:FindFirstChild(v) then
                stareLoop:Disconnect()
            end
        end

        stareLoop = RunService.RenderStepped:Connect(stareFunc)
    end
end)

addcmd('unstareat', {'unstare', 'nostare', 'nostareat'}, function(args, speaker)
    if stareLoop then
        stareLoop:Disconnect()
    end
end)

addcmd("rolewatch", {}, function(args, speaker)
    local groupId = tonumber(args[1] or 0)
    local roleName = args[2] and tostring(getstring(2))
    if groupId and roleName then
        RolewatchData.Group = groupId
        RolewatchData.Role = roleName
        notify("Rolewatch", "Watching Group ID \"" .. tostring(groupId) .. "\" for Role \"" .. roleName .. "\"")
    end
end)

addcmd("rolewatchstop", {}, function(args, speaker)
    RolewatchData.Group = 0
    RolewatchData.Role = ""
    RolewatchData.Leave = false
    notify("Rolewatch", "Disabled")
end)

addcmd("rolewatchleave", {"unrolewatch"}, function(args, speaker)
    RolewatchData.Leave = not RolewatchData.Leave
    notify("Rolewatch", RolewatchData.Leave and "Leave has been Enabled" or "Leave has been Disabled")
end)

local function getStaffRole(player)
    local playerRole = player:GetRoleInGroup(game.CreatorId)
    local result = {Role = playerRole, Staff = false}
    if player:IsInGroup(1200769) then
        result.Role = "Roblox Employee"
        result.Staff = true
    end
    for _, role in pairs(staffRoles) do
        if string.find(string.lower(playerRole), role) then
            result.Staff = true
        end
    end
    return result
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local SoundService = game:GetService("SoundService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local TextChatService = game:GetService("TextChatService")
local HttpService = game:GetService("HttpService")

local staffwatchjoin = nil
local antivoidloop = nil
local alignmentKeys = nil
local alignmentKeysEmotes = nil
local listentoChar = nil
local freezingua = nil
local frozenParts = {}
local autoKeyPressing = false
local cancelAutoKeyPress = nil
local OrgDestroyHeight = Workspace.FallenPartsDestroyHeight
local guiScale = 1
local defaultGuiScale = 1
local currentVersion = "1.0.0"

local function notify(title, message)
    -- Implementation for notifying the user
end

local function getStaffRole(player)
    -- Implementation for getting staff role
    return { Staff = false, Role = "None" }
end

local function formatUsername(player)
    return player.Name
end

local function getRoot(character)
    return character:FindFirstChild("HumanoidRootPart")
end

local function isNumber(value)
    return tonumber(value) ~= nil
end

local function getPlayer(name, speaker)
    -- Implementation for getting player by name
    return { speaker }
end

local function execCmd(command)
    -- Implementation for executing a command
end

local function r15(player)
    -- Implementation for checking if player is R15
    return false
end

addcmd("staffwatch", {}, function(args, speaker)
    if staffwatchjoin then
        staffwatchjoin:Disconnect()
    end
    if game.CreatorType == Enum.CreatorType.Group then
        local found = {}
        staffwatchjoin = Players.PlayerAdded:Connect(function(player)
            local result = getStaffRole(player)
            if result.Staff then
                notify("Staffwatch", formatUsername(player) .. " is a " .. result.Role)
            end
        end)
        for _, player in pairs(Players:GetPlayers()) do
            local result = getStaffRole(player)
            if result.Staff then
                table.insert(found, formatUsername(player) .. " is a " .. result.Role)
            end
        end
        if #found > 0 then
            notify("Staffwatch", table.concat(found, ",\n"))
        else
            notify("Staffwatch", "Enabled")
        end
    else
        notify("Staffwatch", "Game is not owned by a Group")
    end
end)

addcmd("unstaffwatch", {}, function(args, speaker)
    if staffwatchjoin then
        staffwatchjoin:Disconnect()
    end
    notify("Staffwatch", "Disabled")
end)

addcmd('removeterrain', {'rterrain', 'noterrain'}, function(args, speaker)
    Workspace:FindFirstChildOfClass('Terrain'):Clear()
end)

addcmd('clearnilinstances', {'nonilinstances', 'cni'}, function(args, speaker)
    if getnilinstances then
        for _, v in pairs(getnilinstances()) do
            v:Destroy()
        end
    else
        notify('Incompatible Exploit', 'Your exploit does not support this command (missing getnilinstances)')
    end
end)

addcmd('destroyheight', {'dh'}, function(args, speaker)
    local dh = args[1] or -500
    if isNumber(dh) then
        Workspace.FallenPartsDestroyHeight = dh
    end
end)

addcmd("fakeout", {}, function(args, speaker)
    local root = getRoot(speaker.Character)
    local oldpos = root.CFrame
    Workspace.FallenPartsDestroyHeight = 0 / 1 / 0
    root.CFrame = CFrame.new(Vector3.new(0, OrgDestroyHeight - 25, 0))
    wait(1)
    root.CFrame = oldpos
    Workspace.FallenPartsDestroyHeight = OrgDestroyHeight
end)

addcmd("antivoid", {}, function(args, speaker)
    execCmd("unantivoid nonotify")
    wait()
    antivoidloop = RunService.Stepped:Connect(function()
        local root = getRoot(speaker.Character)
        if root and root.Position.Y <= OrgDestroyHeight + 25 then
            root.Velocity = root.Velocity + Vector3.new(0, 250, 0)
        end
    end)
    notify("antivoid", "Enabled")
end)

addcmd("unantivoid", {"noantivoid"}, function(args, speaker)
    antivoidloop:Disconnect()
    antivoidloop = nil
    if args[1] ~= "nonotify" then notify("antivoid", "Disabled") end
end)

addcmd('trip', {}, function(args, speaker)
    if speaker and speaker.Character and speaker.Character:FindFirstChildOfClass("Humanoid") and getRoot(speaker.Character) then
        local hum = speaker.Character:FindFirstChildOfClass("Humanoid")
        local root = getRoot(speaker.Character)
        hum:ChangeState(0)
        root.Velocity = root.CFrame.LookVector * 30
    end
end)

addcmd("removeads", {"adblock"}, function(args, speaker)
    while wait() do
        pcall(function()
            for _, v in pairs(Workspace:GetDescendants()) do
                if v:IsA("PackageLink") then
                    if v.Parent:FindFirstChild("ADpart") then
                        v.Parent:Destroy()
                    end
                    if v.Parent:FindFirstChild("AdGuiAdornee") then
                        v.Parent.Parent:Destroy()
                    end
                end
            end
        end)
    end
end)

addcmd("scare", {"spook"}, function(args, speaker)
    local players = getPlayer(args[1], speaker)
    local oldpos = nil

    for _, v in pairs(players) do
        local root = speaker.Character and getRoot(speaker.Character)
        local target = Players[v]
        local targetRoot = target and target.Character and getRoot(target.Character)

        if root and targetRoot and target ~= speaker then
            oldpos = root.CFrame
            root.CFrame = targetRoot.CFrame + targetRoot.CFrame.lookVector * 2
            root.CFrame = CFrame.new(root.Position, targetRoot.Position)
            task.wait(0.5)
            root.CFrame = oldpos
        end
    end
end)

addcmd("alignmentkeys", {}, function(args, speaker)
    alignmentKeys = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.Comma then Workspace.CurrentCamera:PanUnits(-1) end
        if input.KeyCode == Enum.KeyCode.Period then Workspace.CurrentCamera:PanUnits(1) end
    end)
    alignmentKeysEmotes = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu)
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, false)
end)

addcmd("unalignmentkeys", {"noalignmentkeys"}, function(args, speaker)
    if type(alignmentKeysEmotes) == "boolean" then
        StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.EmotesMenu, alignmentKeysEmotes)
    end
    alignmentKeys:Disconnect()
end)

addcmd("ctrllock", {}, function(args, speaker)
    local mouseLockController = speaker.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("MouseLockController")
    local boundKeys = mouseLockController:FindFirstChild("BoundKeys")

    if boundKeys then
        boundKeys.Value = "LeftControl"
    else
        boundKeys = Instance.new("StringValue")
        boundKeys.Name = "BoundKeys"
        boundKeys.Value = "LeftControl"
        boundKeys.Parent = mouseLockController
    end
end)

addcmd("unctrllock", {}, function(args, speaker)
    local mouseLockController = speaker.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("CameraModule"):WaitForChild("MouseLockController")
    local boundKeys = mouseLockController:FindFirstChild("BoundKeys")

    if boundKeys then
        boundKeys.Value = "LeftShift"
    else
        boundKeys = Instance.new("StringValue")
        boundKeys.Name = "BoundKeys"
        boundKeys.Value = "LeftShift"
        boundKeys.Parent = mouseLockController
    end
end)

addcmd("listento", {}, function(args, speaker)
    execCmd("unlistento")
    if not args[1] then return end

    local player = Players:FindFirstChild(getPlayer(args[1], speaker)[1])
    local root = player and player.Character and getRoot(player.Character)

    if root then
        SoundService:SetListener(Enum.ListenerType.ObjectPosition, root)
        listentoChar = player.CharacterAdded:Connect(function()
            repeat task.wait() until Players[player.Name].Character ~= nil and getRoot(Players[player.Name].Character)
            SoundService:SetListener(Enum.ListenerType.ObjectPosition, getRoot(Players[player.Name].Character))
        end)
    end
end)

addcmd("unlistento", {}, function(args, speaker)
    SoundService:SetListener(Enum.ListenerType.Camera)
    listentoChar:Disconnect()
end)

eventEditor.RegisterEvent("OnExecute")
eventEditor.RegisterEvent("OnSpawn", {
    { Type = "Player", Name = "Player Filter ($1)" }
})
eventEditor.RegisterEvent("OnDied", {
    { Type = "Player", Name = "Player Filter ($1)" }
})
eventEditor.RegisterEvent("OnDamage", {
    { Type = "Player", Name = "Player Filter ($1)" },
    { Type = "Number", Name = "Below Health ($2)" }
})
eventEditor.RegisterEvent("OnKilled", {
    { Type = "Player", Name = "Victim Player ($1)" },
    { Type = "Player", Name = "Killer Player ($2)", Default = 1 }
})
eventEditor.RegisterEvent("OnJoin", {
    { Type = "Player", Name = "Player Filter ($1)", Default = 1 }
})
eventEditor.RegisterEvent("OnLeave", {
    { Type = "Player", Name = "Player Filter ($1)", Default = 1 }
})
eventEditor.RegisterEvent("OnChatted", {
    { Type = "Player", Name = "Player Filter ($1)", Default = 1 },
    { Type = "String", Name = "Message Filter ($2)" }
})

function hookCharEvents(plr, instant)
    task.spawn(function()
        local char = plr.Character
        if not char then return end

        local humanoid = char:WaitForChild("Humanoid", 10)
        if not humanoid then return end

        local oldHealth = humanoid.Health
        humanoid.HealthChanged:Connect(function(health)
            local change = math.abs(oldHealth - health)
            if oldHealth > health then
                eventEditor.FireEvent("OnDamage", plr.Name, tonumber(health))
            end
            oldHealth = health
        end)

        humanoid.Died:Connect(function()
            eventEditor.FireEvent("OnDied", plr.Name)

            local killedBy = humanoid:FindFirstChild("creator")
            if killedBy and killedBy.Value and killedBy.Value.Parent then
                eventEditor.FireEvent("OnKilled", plr.Name, killedBy.Name)
            end
        end)
    end)
end

Players.PlayerAdded:Connect(function(plr)
    eventEditor.FireEvent("OnJoin", plr.Name)
    if isLegacyChat then plr.Chatted:Connect(function(msg) eventEditor.FireEvent("OnChatted", tostring(plr), msg) end) end
    plr.CharacterAdded:Connect(function() eventEditor.FireEvent("OnSpawn", tostring(plr)) hookCharEvents(plr) end)
    JoinLog(plr)
    if isLegacyChat then ChatLog(plr) end
    if ESPenabled then
        repeat wait(1) until plr.Character and getRoot(plr.Character)
        ESP(plr)
    end
    if CHMSenabled then
        repeat wait(1) until plr.Character and getRoot(plr.Character)
        CHMS(plr)
    end
end)

if not isLegacyChat then
    TextChatService.MessageReceived:Connect(function(message)
        if message.TextSource then
            local player = Players:GetPlayerByUserId(message.TextSource.UserId)
            if not player then return end

            if logsEnabled == true then
                CreateLabel(player.Name, message.Text)
            end
            if player.UserId == Players.LocalPlayer.UserId then
                do_exec(message.Text, Players.LocalPlayer)
            end
            eventEditor.FireEvent("OnChatted", player.Name, message.Text)
            sendChatWebhook(player, message.Text)
        end
    end)
end

for _, plr in pairs(Players:GetPlayers()) do
    pcall(function()
        plr.CharacterAdded:Connect(function() eventEditor.FireEvent("OnSpawn", tostring(plr)) hookCharEvents(plr) end)
        hookCharEvents(plr)
    end)
end

if spawnCmds and #spawnCmds > 0 then
    for _, v in pairs(spawnCmds) do
        eventEditor.AddCmd("OnSpawn", { v.COMMAND or "", { 0 }, v.DELAY or 0 })
    end
    updatesaves()
end

if loadedEventData then eventEditor.LoadData(loadedEventData) end
eventEditor.Refresh()

eventEditor.FireEvent("OnExecute")

if aliases and #aliases > 0 then
    local cmdMap = {}
    for _, v in pairs(cmds) do
        cmdMap[v.NAME:lower()] = v
        for _, alias in pairs(v.ALIAS) do
            cmdMap[alias:lower()] = v
        end
    end
    for i = 1, #aliases do
        local cmd = string.lower(aliases[i].CMD)
        local alias = string.lower(aliases[i].ALIAS)
        if cmdMap[cmd] then
            customAlias[alias] = cmdMap[cmd]
        end
    end
    refreshaliases()
end

IYMouse.Move:Connect(checkTT)

CaptureService.CaptureBegan:Connect(function()
    Holder.Visible = false
end)

CaptureService.CaptureEnded:Connect(function()
    task.delay(0.1, function()
        Holder.Visible = true
    end)
end)

task.spawn(function()
    local success, latestVersionInfo = pcall(function()
        local versionJson = game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/version')
        return HttpService:JSONDecode(versionJson)
    end)

    if success then
        if currentVersion ~= latestVersionInfo.Version then
            notify('Outdated', 'Get the new version at infyiff.github.io')
        end

        if latestVersionInfo.Announcement and latestVersionInfo.Announcement ~= '' then
            local AnnGUI = Instance.new("Frame")
            local background = Instance.new("Frame")
            local TextBox = Instance.new("TextLabel")
            local shadow = Instance.new("Frame")
            local PopupText = Instance.new("TextLabel")
            local Exit = Instance.new("TextButton")
            local ExitImage = Instance.new("ImageLabel")

            AnnGUI.Name = randomString()
            AnnGUI.Parent = ScaledHolder
            AnnGUI.Active = true
            AnnGUI.BackgroundTransparency = 1
            AnnGUI.Position = UDim2.new(0.5, -180, 0, -500)
            AnnGUI.Size = UDim2.new(0, 360, 0, 20)
            AnnGUI.ZIndex = 10

            background.Name = "background"
            background.Parent = AnnGUI
            background.Active = true
            background.BackgroundColor3 = currentShade1
            background.BorderSizePixel = 0
            background.Position = UDim2.new(0, 0, 0, 20)
            background.Size = UDim2.new(0, 360, 0, 150)
            background.ZIndex = 10

            TextBox.Parent = background
            TextBox.BackgroundTransparency = 1
            TextBox.Position = UDim2.new(0, 5, 0, 5)
            TextBox.Size = UDim2.new(0, 350, 0, 140)
            TextBox.Font = Enum.Font.SourceSans
            TextBox.TextSize = 18
            TextBox.TextWrapped = true
            TextBox.Text = latestVersionInfo.Announcement
            TextBox.TextColor3 = currentText1
            TextBox.TextXAlignment = Enum.TextXAlignment.Left
            TextBox.TextYAlignment = Enum.TextYAlignment.Top
            TextBox.ZIndex = 10

            shadow.Name = "shadow"
            shadow.Parent = AnnGUI
            shadow.BackgroundColor3 = currentShade2
            shadow.BorderSizePixel = 0
            shadow.Size = UDim2.new(0, 360, 0, 20)
            shadow.ZIndex = 10

            PopupText.Name = "PopupText"
            PopupText.Parent = shadow
            PopupText.BackgroundTransparency = 1
            PopupText.Size = UDim2.new(1, 0, 0.95, 0)
            PopupText.ZIndex = 10
            PopupText.Font = Enum.Font.SourceSans
            PopupText.TextSize = 14
            PopupText.Text = "Server Announcement"
            PopupText.TextColor3 = currentText1
            PopupText.TextWrapped = true

            Exit.Name = "Exit"
            Exit.Parent = shadow
            Exit.BackgroundTransparency = 1
            Exit.Position = UDim2.new(1, -20, 0, 0)
            Exit.Size = UDim2.new(0, 20, 0, 20)
            Exit.Text = ""
            Exit.ZIndex = 10

            ExitImage.Parent = Exit
            ExitImage.BackgroundColor3 = Color3.new(1, 1, 1)
            ExitImage.BackgroundTransparency = 1
            ExitImage.Position = UDim2.new(0, 5, 0, 5)
            ExitImage.Size = UDim2.new(0, 10, 0, 10)
            ExitImage.Image = "rbxassetid://5054663650"
            ExitImage.ZIndex = 10

            wait(1)
            AnnGUI:TweenPosition(UDim2.new(0.5, -180, 0, 150), "InOut", "Quart", 0.5, true, nil)

            Exit.MouseButton1Click:Connect(function()
                AnnGUI:TweenPosition(UDim2.new(0.5, -180, 0, -500), "InOut", "Quart", 0.5, true, nil)
                wait(0.6)
                AnnGUI:Destroy()
            end)
        end
    end
end)

task.spawn(function()

    wait()

    Credits:TweenPosition(UDim2.new(0, 0, 0.9, 0), "Out", "Quart", 0.2)
    Logo:TweenSizeAndPosition(UDim2.new(0, 175, 0, 175), UDim2.new(0, 37, 0, 45), "Out", "Quart", 0.3)

    wait(1)

    local OutInfo = TweenInfo.new(1.6809, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 0, false, 0)

    TweenService:Create(Logo, OutInfo, { ImageTransparency = 1 }):Play()
    TweenService:Create(IntroBackground, OutInfo, { BackgroundTransparency = 1 }):Play()

    Credits:TweenPosition(UDim2.new(0, 0, 0.9, 30), "Out", "Quart", 0.2)

    wait(0.2)

    Logo:Destroy()
    Credits:Destroy()
    IntroBackground:Destroy()

    minimizeHolder()

    if IsOnMobile then
        notify("Unstable Device", "On mobile, Infinite Yield may have issues or features that are not functioning correctly.")
    end
end)
